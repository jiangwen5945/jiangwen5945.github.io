<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS 常用效果</title>
    <url>/2020/02/28/CSS/CSS%20%E5%B8%B8%E7%94%A8%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<ul>
<li><p><a class="link"   href="https://codepen.io/jiangwen5945/pen/EBEree" >制造模糊文本<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.blurry-text</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: transparent;</span><br><span class="line">   <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><a class="link"   href="https://codepen.io/jiangwen5945/pen/LKdvEx" >CSS动画实现省略号动画<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.loading</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">    <span class="attribute">animation</span>: ellipsis <span class="number">2s</span> infinite;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\2026&quot;</span>; <span class="comment">/* ascii code for the ellipsis character */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> ellipsis &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><a class="link"   href="https://codepen.io/jiangwen5945/pen/qzozGN" >CSS悬浮提示文本<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; </span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#bbb</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">text-decoration</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#36c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">1px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Tooltip styling */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">8px</span> solid <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">8px</span> solid <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">0%</span>,.<span class="number">85</span>);</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">8px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">8px</span> solid transparent;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">0%</span>,.<span class="number">85</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(data-tooltip);</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">32px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="built_in">hsla</span>(<span class="number">0</span>,<span class="number">0%</span>,<span class="number">0%</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    -o-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">9px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">41px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[data-tooltip]</span><span class="selector-pseudo">:active</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>在可打印的网页中显示URL</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> print   &#123;  </span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:after</span> &#123;  </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; [&quot;</span> <span class="built_in">attr</span>(href) <span class="string">&quot;] &quot;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>CSS font属性缩写</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: italic small-caps bold <span class="number">1.2em</span>/<span class="number">1.0em</span> Arial, Tahoma, Helvetica;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>content属性</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>块级格式化上下文(BFC)</title>
    <url>/2020/02/28/CSS/BFC%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="BFC是什么？"><a href="#BFC是什么？" class="headerlink" title="BFC是什么？"></a>BFC是什么？</h2><blockquote>
<p>块级格式化上下文（Block Formatting Context，BFC）是一个独立的渲染区域，只有Block-level box参与。</p>
</blockquote>
<h2 id="BFC-的特征："><a href="#BFC-的特征：" class="headerlink" title="BFC 的特征："></a>BFC 的特征：</h2><ol>
<li><p>内部的box会在垂直方向顺序排列</p>
<blockquote>
<p>个人备注:display:black不会触发新的bfc,属于同一个bfc环境中,所以满足该特征</p>
</blockquote>
</li>
<li><p>box间垂直方向的距离由margin决定，属于同一个BFC的box的margin会发生重叠</p>
<blockquote>
<p>个人备注:要想不发生margin重叠,可以使该元素脱离同一个bfc环境,即:可以通过包裹一层使其脱离</p>
</blockquote>
</li>
<li><p>每个元素的margin box的左边， 与包含块border box的左边相接触。即使存在浮动也是如此</p>
<blockquote>
<p>即:从左往右排列,可以想象成’回’字,里面的口margin box,与外面的口border box 左侧相邻</p>
</blockquote>
</li>
<li><p>BFC的区域内所有元素不会与浮动 (float) 元素重叠</p>
<blockquote>
<p>使一个元素生成bfc就可以避免该元素与浮动元素的重叠</p>
</blockquote>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的元素与外面的元素互不影响</p>
</li>
<li><p>计算BFC的高度时，浮动元素也参与计算</p>
<blockquote>
<p>解决父元素塌陷的情况</p>
</blockquote>
</li>
</ol>
<h2 id="如何触发-BFC？"><a href="#如何触发-BFC？" class="headerlink" title="如何触发 BFC？"></a>如何触发 BFC？</h2><p><strong>以下任意一条即可</strong>：</p>
<ol>
<li>根元素</li>
<li>float 的值不为none。</li>
<li>position 的值不为static或者relative。</li>
<li>display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个。</li>
<li>overflow的值不为visible。</li>
</ol>
<h2 id="BFC-的应用场景："><a href="#BFC-的应用场景：" class="headerlink" title="BFC 的应用场景："></a>BFC 的应用场景：</h2><ol>
<li><h3 id="解决-margin-叠加问题"><a href="#解决-margin-叠加问题" class="headerlink" title="解决 margin 叠加问题"></a>解决 <code>margin</code> 叠加问题</h3><p><strong>产生叠加的条件</strong>：</p>
<ul>
<li><p>处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个 BFC </p>
</li>
<li><p>没有inline盒子，没有空隙，没有 padding 和 border 将他们分隔开</p>
</li>
</ul>
<p><strong>解决方案:</strong></p>
<ul>
<li>将其中一个元素形成BFC区域，使其与其他元素互不影响</li>
<li>通过给元素加边框或者边距来解决</li>
</ul>
</li>
<li><h3 id="用于布局"><a href="#用于布局" class="headerlink" title="用于布局"></a>用于布局</h3><ul>
<li>三列布局（圣杯布局、双飞燕布局）</li>
</ul>
</li>
<li><h3 id="用于清除浮动，计算BFC高度"><a href="#用于清除浮动，计算BFC高度" class="headerlink" title="用于清除浮动，计算BFC高度"></a>用于清除浮动，计算BFC高度</h3><p><strong>解决方案：</strong></p>
<ul>
<li>利用 <code>clear</code> 属性清除浮动。</li>
<li>overflow:hidden使父容器形成BFC</li>
</ul>
</li>
</ol>
<blockquote>
<p><a class="link"   href="https://juejin.im/post/583bb606a22b9d006c141286" >参考链接：细说CSS中的BFC<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css属性继承</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS中可继承的属性</title>
    <url>/2020/02/28/CSS/CSS%E4%B8%AD%E5%8F%AF%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>css样式表继承指的是，特定的css属性向下传递到后代元素，那么css哪些属性可以继承呢？</p>
<p><strong>1、字体系列属性</strong></p>
<ul>
<li>font：组合字体</li>
<li>font-family：规定元素的字体系列</li>
<li>font-weight：设置字体的粗细</li>
<li>font-size：设置字体的尺寸</li>
<li>font-style：定义字体的风格</li>
<li>font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为</li>
<li>大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。</li>
<li>font-stretch：允许你使文字变宽或变窄。所有主流浏览器都不支持。</li>
<li>font-size-adjust：为某个元素规定一个 aspect 值，字体的小写字母 “x” 的高度与</li>
<li>“font-size” 高度之间的比率被称为一个字体的 aspect 值。这</li>
<li>样就可以保持首选字体的 x-height。</li>
</ul>
<p><strong>2、文本系列属性</strong></p>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：增加或减少单词间的空白（即字间隔）</li>
<li>letter-spacing：增加或减少字符间的空白（字符间距）</li>
<li>text-transform：控制文本大小写</li>
<li>direction：规定文本的书写方向</li>
<li>color：文本颜色</li>
</ul>
<p><strong>3、元素可见性：visibility</strong></p>
<p><strong>4、表格布局属性：</strong></p>
<p>caption-side、border-collapse、border-spacing、empty-cells、table-layout</p>
<p><strong>5、列表属性：</strong>list-style-type、list-style-image、list-style-position、list-style</p>
<p><strong>6、生成内容属性：</strong>quotes</p>
<p><strong>7、光标属性：</strong>cursor</p>
<p><strong>8、页面样式属性：</strong>page、page-break-inside、windows、orphans</p>
<p><strong>9、声音样式属性：</strong></p>
<p>speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation</p>
<hr>
<p><strong>所有元素可以继承的属性：</strong></p>
<p>1、元素可见性：visibility、opacity</p>
<p>2、光标属性：cursor</p>
<p><strong>内联元素可以继承的属性:</strong></p>
<p>1、字体系列属性</p>
<p>2、除text-indent、text-align之外的文本系列属性</p>
<p><strong>块级元素可以继承的属性:</strong></p>
<p>1、text-indent、text-align</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css属性继承</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS中浮动和定位概念区分</title>
    <url>/2020/02/28/CSS/CSS%E4%B8%AD%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86/</url>
    <content><![CDATA[<h2 id="首先明确元素进行布局时的两个状态："><a href="#首先明确元素进行布局时的两个状态：" class="headerlink" title="首先明确元素进行布局时的两个状态："></a>首先明确元素进行布局时的两个状态：</h2><p>​	脱离文档流：该元素不进行占位，其他元素在其下方排列。</p>
<p>​	脱离文本流：文字是否会在其周围进行环绕布局</p>
<table>
<thead>
<tr>
<th></th>
<th>脱离文档流</th>
<th>脱离文本流</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>是√</td>
<td>否×</td>
</tr>
<tr>
<td>absolute</td>
<td>是√</td>
<td>是√</td>
</tr>
<tr>
<td>relative</td>
<td>是√</td>
<td>是√</td>
</tr>
<tr>
<td>fixed</td>
<td>否×</td>
<td>是√</td>
</tr>
</tbody></table>
<p>对父元素overflow: hidden进行清除浮动，在脱离文档流的方式中只对float有效，其他两种<code>absolute</code>、<code>fixed</code>无效，即无法撑开父级高度</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS小结</title>
    <url>/2020/02/28/CSS/CSS%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
盒模型</p>
<ul>
<li>盒模型由内而外为：内容（content）、内边距（padding）、边框（border）、外边距（margin）</li>
<li>CSS的盒子模型分为：IE 盒模型和标准 W3C 盒模型</li>
<li><strong>区别</strong>：设置宽度时标准模型只包含内容（content），而IE盒模型还包含内边距（padding）和边框（border）</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
flex弹性布局</p>
<ul>
<li><strong>基本概念：</strong>采用 Flex 布局的元素，称为 Flex 容器（flex container）；它的所有子元素自动成为容器成员，称为 Flex 项目（flex item）</li>
</ul>
<p>容器属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明介绍</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>flex-direction</td>
<td>项目的排列方向</td>
<td>row</td>
</tr>
<tr>
<td>flex-wrap</td>
<td>项目是否换行</td>
<td>nowrap</td>
</tr>
<tr>
<td>flex-flow</td>
<td><code>flex-direction</code>和<code>flex-wrap</code>简写组合</td>
<td>row  nowrap</td>
</tr>
<tr>
<td>justify-content</td>
<td>项目在主轴上的对齐方式</td>
<td>flex-start</td>
</tr>
<tr>
<td>align-items</td>
<td>项目在交叉轴上如何对齐</td>
<td>stretch</td>
</tr>
<tr>
<td>align-content</td>
<td>定义多根轴线的对齐方式（单轴线无效）</td>
<td>stretch</td>
</tr>
</tbody></table>
<p>项目属性：</p>
<p>| 属性名      | 说明介绍                                         | 默认值                              |</p>
</li>
</ul>
<p>| ———– | ———————————————— | ———————————– |<br>  | flex-grow   | 项目的放大比例                                   | 0：即使剩余空间，该项目也不放大     |<br>  | flex-shrink | 项目的缩小比例                                   | 1：如果空间不足，该项目将缩小       |<br>  | flex-basis  | 分配多余空间之前，项目占据的主轴空间             | autoC即项目的本来大小               |<br>  | flex        | <code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写 | 0  [1]  [auto] ：后两个属性可选     |<br>  | align-self  | 允许单个项目有与其他项目不一样的对齐方式         | auto：继承父元素的<code>align-items</code>属性 |<br>  | order       | 项目的排列顺序                                   | 0 ：数值越小，排列越靠前            |</p>
<blockquote>
<p>tip ：<code>flex</code>属性有两个快捷值：auto <code>(1 1 auto)</code> 和 none <code>(0 0 auto)</code> ；<br>        <code>flex：1</code>、<code>flex：auto</code>、<code>flex：1 1 auto</code>三者表达的意思相同 ；</p>
</blockquote>
<ul>
<li><p><input checked="" disabled="" type="checkbox"> 
css单位</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
css选择器</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
BFC清除浮动</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
层叠上下文</p>
</li>
<li><p><strong>什么是层叠上下文：</strong>元素拥有z轴叠层环境</p>
</li>
<li><p><strong>什么是层叠等级：</strong></p>
<ol>
<li>简单理解拥有层叠上下文环境 层叠等级高与普通元素；</li>
<li>处于同一个层叠上下文中(层叠环境)，比较层叠等级；否则比较他们所处的层叠上下文(层叠环境)的层叠等级。</li>
</ol>
</li>
<li><p><strong>如何产生层叠上下文：</strong></p>
<ol>
<li>根元素html</li>
<li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值</li>
<li>CSS3中的新属性也可以产生层叠上下文</li>
</ol>
</li>
<li><p><strong>“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则</strong></p>
</li>
<li><p><strong>层叠顺序</strong>：正z-index &gt; 定位元素 &gt; 内联元素 &gt; 浮动元素 &gt; 块级元素 &gt; border &gt; background &gt; 负z-index</p>
</li>
</ul>
<blockquote>
<p>参考链接：<a class="link"   href="https://www.jianshu.com/p/0f88946a0746" >彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 常用页面布局</li>
<li><input checked="" disabled="" type="checkbox"> 响应式布局</li>
<li><input checked="" disabled="" type="checkbox"> CSS预处理（sass、less）、后处理（postcss）</li>
<li><input checked="" disabled="" type="checkbox"> css3新特性</li>
<li><input checked="" disabled="" type="checkbox"> display有哪些取值</li>
<li><input checked="" disabled="" type="checkbox"> 相邻的两个inline-block节点为什么会出现间隔，怎么解决</li>
<li><input checked="" disabled="" type="checkbox"> meta viewport移动端适配</li>
<li><input checked="" disabled="" type="checkbox"> CSS实现宽度自适应100%，宽高16:9的比例矩形</li>
<li><input checked="" disabled="" type="checkbox"> rem单位布局的优缺点</li>
<li><input checked="" disabled="" type="checkbox"> 画三角形</li>
<li><input checked="" disabled="" type="checkbox"> 1像素边框问题</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局最后一行列表左对齐的N种方法</title>
    <url>/2023/01/18/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>在CSS flex布局中，<code>justify-content</code>属性可以控制列表的水平对齐方式，例如<code>space-between</code>值可以实现两端对齐。但是，如果最后一行的列表的个数不满，则就会出现最后一行没有完全垂直对齐的问题。</p>
</blockquote>
<p>如下代码：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24%</span>; <span class="attribute">height</span>: <span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;    </span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后列表的个数不多不少正好7个：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>此时最后一行的小方块的排列就显得很尴尬了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005711005.png"
                      alt="图片"
                ></p>
<p>您可以狠狠地点击这里：最后一行flex列表没有对齐demo</p>
<p>此时，最后一行应该左对齐排列才是我们想要的效果，如何实现呢？</p>
<p>其实实现的思路和display:inline-block的两端对齐是一样的。</p>
<h3 id="二、如果每一行列数是固定的"><a href="#二、如果每一行列数是固定的" class="headerlink" title="二、如果每一行列数是固定的"></a><strong>二、如果每一行列数是固定的</strong></h3><p>如果每一行列数是固定的，则下面两种方法可以实现最后一行左对齐。</p>
<h4 id="方法一：模拟space-between和间隙"><a href="#方法一：模拟space-between和间隙" class="headerlink" title="方法一：模拟space-between和间隙"></a>方法一：模拟space-between和间隙</h4><p>也就是我们不使用<code>justify-content:space-between</code>声明在模拟两端对齐效果。中间的gap间隙我们使用margin进行控制。</p>
<p>例如：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    </span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24%</span>; <span class="attribute">height</span>: <span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;    </span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>n)) &#123;    </span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="built_in">calc</span>(<span class="number">4%</span> / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时，布局效果是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005710826.png"
                      alt="图片"
                ></p>
<h4 id="方法二：-根据个数最后一个元素动态margin"><a href="#方法二：-根据个数最后一个元素动态margin" class="headerlink" title="方法二：****根据个数最后一个元素动态margin"></a><strong>方法二：****根据个数最后一个元素动态margin</strong></h4><p>由于每一列的数目都是固定的，因此，我们可以计算出不同个数列表应当多大的<code>margin</code>值才能保证完全左对齐。</p>
<p>例如，假设每行4个元素，结果最后一行只有3个元素，则最后一个元素的<code>margin-right</code>大小是“列表宽度+间隙大小”的话，那最后3个元素也是可以完美左对齐的。</p>
<p>然后，借助树结构伪类数量匹配技术（这篇文章“伪类匹配列表数目实现微信群头像CSS布局的技巧”中的布局技巧就是借助这种技术实现），我们可以知道最后一行有几个元素。</p>
<p>例如：</p>
<ul>
<li><code>.list:last-child:nth-child(4n - 1)</code>说明最后一行，要么3个元素，要么7个元素……</li>
<li><code>.list:last-child:nth-child(4n - 2)</code>说明最后一行，要么2个元素，要么6个元素……</li>
</ul>
<p>在本例中，一行就4个元素，因此，我们可以有如下CSS设置：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    <span class="comment">/* 两端对齐 */</span>    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;    </span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24%</span>; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;    </span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果最后一行是3个元素 */</span></span><br><span class="line"><span class="selector-class">.list</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>n - <span class="number">1</span>) &#123;    </span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="built_in">calc</span>(<span class="number">24%</span> + <span class="number">4%</span> / <span class="number">3</span>);&#125;</span><br><span class="line"><span class="comment">/* 如果最后一行是2个元素 */</span><span class="selector-class">.list</span><span class="selector-pseudo">:last-child</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>n - <span class="number">2</span>) &#123;    </span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="built_in">calc</span>(<span class="number">48%</span> + <span class="number">8%</span> / <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>效果如下GIF示意，删除列表后，布局依然稳稳地左对齐。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005709403.gif"
                      alt="图片"
                ></p>
<p>眼见为实，您可以狠狠地点击这里：动态匹配数量实现flex子项左对齐demo</p>
<h3 id="三、如果每一子项宽度不固定"><a href="#三、如果每一子项宽度不固定" class="headerlink" title="三、如果每一子项宽度不固定"></a><strong>三、如果每一子项宽度不固定</strong></h3><p>有时候，每一个flex子项的宽度都是不固定的，这个时候希望最后一行左对齐该如何实现呢？</p>
<p>由于此时间隙的大小不固定，对齐不严格，因此，我们可以直接让最后一行左对齐即可。具体方法有两个：</p>
<h4 id="方法一：-最后一项margin-right-auto"><a href="#方法一：-最后一项margin-right-auto" class="headerlink" title="方法一：****最后一项margin-right:auto"></a><strong>方法一：****最后一项margin-right:auto</strong></h4><p>CSS代码如下：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;    </span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;   </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;    </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 最后一项margin-right:auto */</span></span><br><span class="line"><span class="selector-class">.list</span><span class="selector-pseudo">:last-child</span> &#123;    </span><br><span class="line">    <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终效果如下GIF：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005709618.gif"
                      alt="图片"
                ></p>
<h4 id="方法二：-创建伪元素并设置flex-auto或flex-1"><a href="#方法二：-创建伪元素并设置flex-auto或flex-1" class="headerlink" title="方法二：****创建伪元素并设置flex:auto或flex:1"></a><strong>方法二：****创建伪元素并设置flex:auto或flex:1</strong></h4><p>CSS代码如下：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;    </span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;  </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用伪元素辅助左对齐 */</span></span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span> &#123;    </span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">flex</span>: auto;    <span class="comment">/* 或者flex: 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终效果如下GIF：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005709618.gif"
                      alt="图片"
                ></p>
<hr>
<p>这两个方法我合在一个demo页面了，您可以狠狠的点击这里：flex子元素宽度不固定最后一行左对齐demo</p>
<h3 id="四、如果每一行列数不固定"><a href="#四、如果每一行列数不固定" class="headerlink" title="四、如果每一行列数不固定"></a><strong>四、如果每一行列数不固定</strong></h3><p>如果每一行的列数不固定，则上面的这些方法均不适用，需要使用其他技巧来实现最后一行左对齐。</p>
<p>这个方法其实很简单，也很好理解，就是使用足够的空白标签进行填充占位，具体的占位数量是由最多列数的个数决定的，例如这个布局最多7列，那我们可以使用7个空白标签进行填充占位，最多10列，那我们需要使用10个空白标签。</p>
<p>如下HTML示意：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>相关CSS如下，实现的关键就是占位的<code>&lt;i&gt;</code>元素宽度和<code>margin</code>大小设置得和<code>.list</code>列表元素一样即可，其他样式都不需要写。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: flex;    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;    </span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;    </span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;   </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">15px</span> <span class="number">10px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 和列表一样的宽度和margin值 */</span></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">i</span> &#123;    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于<code>&lt;i&gt;</code>元素高度为0，因此，并不会影响垂直方向上的布局呈现。</p>
<p>最后的效果如下GIF图示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005709595.gif"
                      alt="图片"
                ></p>
<h3 id="五、如果列数不固定HTML又不能调整"><a href="#五、如果列数不固定HTML又不能调整" class="headerlink" title="五、如果列数不固定HTML又不能调整"></a><strong>五、如果列数不固定HTML又不能调整</strong></h3><p>然而有时候，由于客观原因，前端重构人员没有办法去调整html结构，同时布局的列表个数又不固定，这个时候该如何实现我们最后一行左对齐效果呢？</p>
<p>我们不妨可以试试使用Grid布局。</p>
<p>Grid布局天然有gap间隙，且天然格子对齐排布，因此，实现最后一行左对齐可以认为是天生的效果。</p>
<p>CSS代码如下：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    </span><br><span class="line">    <span class="attribute">display</span>: grid;    </span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;    </span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>);    </span><br><span class="line">    <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> &#123;    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;    </span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到CSS代码非常简洁。</p>
<p>HTML代码就是非常规整非常普通的代码片段：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;container&quot;&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;    </span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;list&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>最后的效果如下GIF：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/CSS/flex%E5%B8%83%E5%B1%80%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%88%97%E8%A1%A8%E5%B7%A6%E5%AF%B9%E9%BD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95.assets/640-20230626005709595.gif"
                      alt="图片"
                ></p>
<h3 id="六、这几种实现方法点评"><a href="#六、这几种实现方法点评" class="headerlink" title="六、这几种实现方法点评"></a><strong>六、这几种实现方法点评</strong></h3><p>首先最后一行需要左对齐的布局更适合使用CSS grid布局实现，但是，<code>repeat()</code>函数兼容性有些要求，IE浏览器并不支持。如果项目需要兼容IE，则此方法需要斟酌。</p>
<p>然后，适用范围最广的方法是使用空的元素进行占位，此方法不仅适用于列表个数不固定的场景，对于列表个数固定的场景也可以使用这个方法。但是有些人代码洁癖，看不惯这种空的占位的html标签，则可以试试一开始的两个方法，一是动态计算margin，模拟两端对齐，另外一个是根据列表的个数，动态控制最后一个列表元素的margin值实现左对齐。</p>
<p>累计6种方法，各有各的优缺点，大家根据自己项目的实际场景，选择合适的方法。</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>实现移动端Retina屏幕1px边框</title>
    <url>/2021/11/18/CSS/%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AFRetina%E5%B1%8F%E5%B9%951px%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<blockquote>
<p>前言：在Reina（视网膜）屏幕的手机上，使用CSS设置的1px的边框实际会比视觉稿粗很多，因为不同的手机有不同的像素密度，因此在css中的1px并不等于移动设备的1px。在window对象中有一个<code>devicePixelRatio</code>属性（物理像素 &#x2F; 设备独立像素），他可以反应css中的像素与设备的像素比。</p>
</blockquote>
<h2 id="使用background-image-x2F-border-image实现"><a href="#使用background-image-x2F-border-image实现" class="headerlink" title="使用background-image&#x2F;border-image实现"></a>使用background-image&#x2F;border-image实现</h2><p>你要先准备一张符合你要求的图片。然后将边框模拟在背景上。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* background-image方案 */</span></span><br><span class="line"><span class="selector-class">.border-bottom-1px</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">linenew.png</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">linenew.png</span>) <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* border-image方案 */</span></span><br><span class="line"><span class="selector-class">.background-image-1px</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../img/line.png</span>) repeat-x left bottom;</span><br><span class="line">  -webkit-<span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点：</strong></p>
<ul>
<li><p>可以设置单条,多条边框</p>
</li>
<li><p>没有性能瓶颈的问题</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>修改颜色麻烦, 需要替换图片</p>
</li>
<li><p>圆角需要特殊处理，并且边缘会模糊</p>
</li>
</ul>
<h2 id="多背景渐变实现"><a href="#多背景渐变实现" class="headerlink" title="多背景渐变实现"></a>多背景渐变实现</h2><p>与background-image方案类似，只是将图片替换为css3渐变。设置1px的渐变背景，50%有颜色，50%透明。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.background-gradient-1px</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">#000</span>, <span class="number">#000</span> <span class="number">100%</span>, transparent <span class="number">100%</span>) left / <span class="number">1px</span> <span class="number">100%</span> no-repeat,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">#000</span>, <span class="number">#000</span> <span class="number">100%</span>, transparent <span class="number">100%</span>) right / <span class="number">1px</span> <span class="number">100%</span> no-repeat,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">#000</span>,<span class="number">#000</span> <span class="number">100%</span>, transparent <span class="number">100%</span>) top / <span class="number">100%</span> <span class="number">1px</span> no-repeat,</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">#000</span>,<span class="number">#000</span> <span class="number">100%</span>, transparent <span class="number">100%</span>) bottom / <span class="number">100%</span> <span class="number">1px</span> no-repeat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点：</strong></p>
<ul>
<li><p>可以实现单条、多条边框</p>
</li>
<li><p>边框的颜色随意设置</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>代码量不少</p>
</li>
<li><p>圆角没法实现</p>
</li>
<li><p>多背景图片有兼容性问题</p>
</li>
</ul>
<h2 id="使用box-shadow模拟边框"><a href="#使用box-shadow模拟边框" class="headerlink" title="使用box-shadow模拟边框"></a>使用box-shadow模拟边框</h2><p>利用css 对阴影处理的方式实现0.5px的效果</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box-shadow-1px</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">0px</span> -<span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> <span class="number">#c8c7cc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点：</strong></p>
<ul>
<li><p>代码量少</p>
</li>
<li><p>所有场景都能满足</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>边框有阴影，颜色变浅</li>
</ul>
<h2 id="viewport-rem-实现"><a href="#viewport-rem-实现" class="headerlink" title="viewport + rem 实现"></a>viewport + rem 实现</h2><p>同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 在devicePixelRatio = 2 时，输出viewport：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 在devicePixelRatio = 3 时，输出viewport：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.33, maximum-scale=0.33, minimum-scale=0.33, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这种兼容方案相对比较完美，<strong>适合新的项目</strong>，老的项目修改成本过大。可以看看《使用Flexible实现手淘H5页面的终端适配》</p>
<p><strong>优点：</strong></p>
<ul>
<li><p>所有场景都能满足</p>
</li>
<li><p>一套代码，可以兼容基本所有布局</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>老项目修改代价过大，只适用于新项目</li>
</ul>
<h2 id="伪类-transform-实现（推荐）"><a href="#伪类-transform-实现（推荐）" class="headerlink" title="伪类 + transform 实现（推荐）"></a>伪类 + transform 实现（推荐）</h2><p>对于老项目，有没有什么办法能兼容1px的尴尬问题了，个人认为伪类+transform是比较完美的方法了。<br>原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。</p>
<p><strong>单条border样式设置：</strong></p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">border</span>:none;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line"></span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>四条boder样式设置:</strong></p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.scale-1px</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">border</span>:none;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.scale-1px</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line"></span><br><span class="line">  -webkit-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line"></span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: left top;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最好在使用前也判断一下，结合 JS 代码，判断是否 Retina 屏：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> &amp;&amp; devicePixelRatio &gt;= <span class="number">2</span>)&#123;</span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="property">className</span> = <span class="string">&#x27;scale-1px&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点：</strong></p>
<ul>
<li><p>所有场景都能满足</p>
</li>
<li><p>支持圆角(伪类和本体类都需要加border-radius)</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对于已经使用伪类的元素(例如clearfix)，可能需要多层嵌套</li>
</ul>
<p>🔗: <a class="link"   href="https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&amp;mid=2649088476&amp;idx=3&amp;sn=44893ca9980310c02a8b1b63f2145fd5&amp;chksm=be5bc671892c4f6791cd6a60dbcd72918c682cf5e5cf36baf421e9829d7f48014f92cc50fc2a&amp;scene=27" >参考链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>移动端适配</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>等高布局的几种实现方式</title>
    <url>/2021/11/18/CSS/%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	 <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-class">.container</span> &#123;</span><br><span class="line">		<span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h2><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	 <span class="attribute">display</span>: grid;</span><br><span class="line">   <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h2 id="负maigin"><a href="#负maigin" class="headerlink" title="负maigin"></a>负maigin</h2><div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	 <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">	<span class="attribute">margin</span>: -<span class="number">99999px</span></span><br><span class="line">	padding: <span class="number">99999px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>H5</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello git</title>
    <url>/2022/09/28/Git/hello-git/</url>
    <content><![CDATA[<h2 id="git起步"><a href="#git起步" class="headerlink" title="git起步"></a>git起步</h2><h5 id="…在命令行上创建新的存储库"><a href="#…在命令行上创建新的存储库" class="headerlink" title="…在命令行上创建新的存储库"></a>…在命令行上创建新的存储库</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# article-img&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:jiangwen5945/article-img.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></div>

<h5 id="…从命令行推送现有存储库"><a href="#…从命令行推送现有存储库" class="headerlink" title="…从命令行推送现有存储库"></a>…从命令行推送现有存储库</h5><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:jiangwen5945/article-img.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5一览</title>
    <url>/2020/01/01/HTML/HTML5%E4%B8%80%E8%A7%88/</url>
    <content><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
语义化</p>
<ul>
<li>页面结构更加清晰和可读性，有利于团队开发和维护</li>
<li>方便其他设备解析</li>
<li>有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重</li>
<li>易于用户阅读，样式丢失的时候能让页面呈现清晰的结构</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
H5新增标签特性</p>
<table>
<thead>
<tr>
<th align="center">标签名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><article></td>
<td align="center">定义文章，规定独立的自包含内容</td>
</tr>
<tr>
<td align="center"><aside></td>
<td align="center">定义页面内容之外的内容</td>
</tr>
<tr>
<td align="center"><section></td>
<td align="center">定义文档中的小节、区段</td>
</tr>
<tr>
<td align="center"><header></td>
<td align="center">定义section或page的页眉</td>
</tr>
<tr>
<td align="center"><footer></td>
<td align="center">定义section或page的页脚</td>
</tr>
<tr>
<td align="center"><main></td>
<td align="center">定义文档的主要内容</td>
</tr>
<tr>
<td align="center"><nav></td>
<td align="center">定义导航链接</td>
</tr>
<tr>
<td align="center"><bdi></td>
<td align="center">定义文本的文本方向，使其脱离其周围文本的方向设置</td>
</tr>
<tr>
<td align="center"><canvas></td>
<td align="center">定义图形画布</td>
</tr>
<tr>
<td align="center"><command></td>
<td align="center">定义命令按钮  (仅ie9支持这个标签)</td>
</tr>
<tr>
<td align="center"><datalist></td>
<td align="center">定义下拉列表（配合input使用）</td>
</tr>
<tr>
<td align="center"><details></td>
<td align="center">定义元素的细节:页面只显示summary里的内容，点击之后才显示详细内容</td>
</tr>
<tr>
<td align="center"><summary></td>
<td align="center">为<details>元素定义可见的标题</td>
</tr>
<tr>
<td align="center"><embed></td>
<td align="center">定义外部交互内容或插件</td>
</tr>
<tr>
<td align="center"><figcaption></td>
<td align="center">定义figure元素的标题</td>
</tr>
<tr>
<td align="center"><figure></td>
<td align="center">定义媒介</td>
</tr>
<tr>
<td align="center"><keygen></td>
<td align="center">定义生成密钥</td>
</tr>
<tr>
<td align="center"><mark></td>
<td align="center">定义有记号的文本</td>
</tr>
<tr>
<td align="center"><meter></td>
<td align="center">定义预定义范围内的度量</td>
</tr>
<tr>
<td align="center"><output></td>
<td align="center">定义输出的一些类型</td>
</tr>
<tr>
<td align="center"><progress></td>
<td align="center">定义任何类型的任务的进度</td>
</tr>
<tr>
<td align="center"><audio></td>
<td align="center">定义声音内容，比如音乐或其他音频流</td>
</tr>
<tr>
<td align="center"><source></td>
<td align="center">定义媒介源</td>
</tr>
<tr>
<td align="center"><dialog></td>
<td align="center">定义对话框或窗口</td>
</tr>
<tr>
<td align="center"><time></td>
<td align="center">定义日期&#x2F;时间</td>
</tr>
<tr>
<td align="center"><track></td>
<td align="center">定义用在媒体播放器中的文本轨道</td>
</tr>
<tr>
<td align="center"><video></td>
<td align="center">定义视频</td>
</tr>
<tr>
<td align="center"><wbr></td>
<td align="center">定义英文字符自动进行软换行</td>
</tr>
</tbody></table>
<blockquote>
<p>tip : 对于一段主题性的内容，则就适用<code>section</code>，而假如这段内容可以脱离上下文，作为完整的独立存在的一段内容，则就适用 <code>article</code>  </p>
</blockquote>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
input和textarea的区别</p>
<ul>
<li>有无value属性</li>
<li>是否闭合标签</li>
</ul>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
用div模拟textarea的实现</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.editBox</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span><br><span class="line">    _height: <span class="number">100px</span>; <span class="comment">/* IE6 */</span></span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#a0b3d6</span>;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto; <span class="comment">/* 超过最大高度就出现滚动条 */</span></span><br><span class="line">    _overflow-<span class="attribute">y</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;editBox&quot; contenteditable&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><input checked="" disabled="" type="checkbox"> 
移动设备忽略将页面的数字识别为电话号码</p>
<meta name = "format-detection" content = "telephone=no"></li>
</ul>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2022/09/28/Hexo/Hello%20Hexo/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="快速开始111"><a href="#快速开始111" class="headerlink" title="快速开始111"></a>快速开始111</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h2><blockquote>
<p>Hexo-theme-Redefine reimagines simplicity, speed, and purity, without sacrificing functionality or design. Its sleek, modern aesthetic is packed with useful features, blending style and practicality seamlessly.<br>Building on the solid foundation of hexo-theme-keep, “Redefine” elevates the style and incorporates valuable writing tools and plugins. It offers extensive customization options, allowing you to tailor every detail to your preferences. With Redefine, your blogging experience becomes unique and effortless, showcasing your personal style and needs.</p>
</blockquote>
<h3 id="🌐-Demo"><a href="#🌐-Demo" class="headerlink" title="🌐 Demo"></a>🌐 Demo</h3><ul>
<li><a class="link"   href="https://redefine.ohevan.com/" >Theme Redefine Demo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine.ohevan.com/showcase" >Redefine Theme Showcase<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
<p>If you are also using Redefine, please go to <a class="link"   href="https://redefine.ohevan.com/showcase" >Redefine Theme Showcase<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> to add your blog link.</p>
<h3 id="⛰️-Features"><a href="#⛰️-Features" class="headerlink" title="⛰️ Features"></a>⛰️ Features</h3><ul>
<li><a class="link"   href="https://redefine-docs.ohevan.com/modules/notes" >Note Module<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/page_templates/friends" >Friend Link Page<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/plugins/mathjax" >Mathjax Support<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Code block language display</li>
<li>Light&#x2F;Dark mode switching</li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/basic/fontawesome" >Font Awesome 6.2.1 Pro<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> (contains different styles like Duotone&#x2F;Regular&#x2F;Thin&#x2F;Sharp)</li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/dhome/navbar#%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8" >Drop-down menu<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/footer" >Customizable footer<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/footer#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4" >Site Uptime Display<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/article_customize/banner" >Article Header Image<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/plugins/mermaid" >Mermaid JS support<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>SEO friendly</li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/plugins/aplayer" >Aplayer support<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/shuoshuo" >Shuoshuo support<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://redefine-docs.ohevan.com/basic/global#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93" >Customizable Font<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Tailwind CSS Included</li>
</ul>
<h3 id="☁️-Installation"><a href="#☁️-Installation" class="headerlink" title="☁️ Installation"></a>☁️ Installation</h3><p>The easiest way to install Theme Redefine is by using <strong>npm</strong> (after your hexo version has been up to <code>5.0</code>+)</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div>

<p>Another method is by <strong>git clone</strong></p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> your-hexo-site</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine</span><br></pre></td></tr></table></figure></div>

<p>After the installation, go to the <code>_config.yml</code> of your hexo site and set</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">redefine</span></span><br></pre></td></tr></table></figure></div>

<h3 id="⏫-Update"><a href="#⏫-Update" class="headerlink" title="⏫ Update"></a>⏫ Update</h3><p>To update hexo-theme-redefine, you can run the same <strong>npm</strong> command</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-theme-redefine@latest</span><br></pre></td></tr></table></figure></div>

<p>If you installed the theme by <strong>git clone</strong>, you can update the theme by running the following command</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/redefine</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure></div>



<h3 id="📄-Documentations"><a href="#📄-Documentations" class="headerlink" title="📄 Documentations"></a>📄 Documentations</h3><p>Please read <a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine Docs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> when installing</p>
<p>It’s very easy to understand.</p>
<h3 id="☕-Support"><a href="#☕-Support" class="headerlink" title="☕ Support"></a>☕ Support</h3><p>Feel free to <strong>pull request</strong> and <strong>send issues</strong>.</p>
<p>If you have any questions, please send an email to <a class="link"   href="mailto:contact@ohevan.com" >contact@ohevan.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. I will reply in time.</p>
<p>Please <strong>give me a star</strong> to support me, thanks!</p>
<p>Also, if you are using <a class="link"   href="https://typora.io/" >Typora<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>, check out <a class="link"   href="https://github.com/EvanNotFound/typora-theme-redefine" >Typora Theme Redefine<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> so that you can preview the styles of your blog in Typora.</p>
<h3 id="💗-Donations"><a href="#💗-Donations" class="headerlink" title="💗 Donations"></a>💗 Donations</h3><p>Thanks to all the people who have donated to me. Your support is my greatest motivation.</p>
<p>If you like this theme, please give a star. You can also support me by <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine/blob/dev/DONATION.md" >donating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<p>This is the list of all the people who have donated to me: <a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine/blob/dev/DONATION.md" >Donation List<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>如果你想要使用OpenAI GPT-4，但不想每月支付 20 美元吗，来看看我的 <a class="link"   href="https://gpt.oknice.ca/" >GPT Plus Share<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> GPT Plus 共享站，使用多达 100 个 ChatGPT Plus 账户，每月仅 17 人民币起步！</p>
<p><a href="https://gpt.oknice.ca/"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://github.com/EvanNotFound/hexo-theme-redefine/assets/68590232/55346629-cd54-45a4-9b31-3f979750b0c0"
                      alt="GPT Billboard"
                ></a></p>
<h3 id="🌟-Star-History"><a href="#🌟-Star-History" class="headerlink" title="🌟 Star History"></a>🌟 Star History</h3><p align="center">
<a href="https://star-history.com/#EvanNotFound/hexo-theme-redefine&Date">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=EvanNotFound/hexo-theme-redefine&type=Date&theme=dark" />
    <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=EvanNotFound/hexo-theme-redefine&type=Date" />
    <img  alt="Star History Chart" 
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://api.star-history.com/svg?repos=EvanNotFound/hexo-theme-redefine&type=Date"
                      
                >
  </picture>
</a>
</p>

<h3 id="💻-Development"><a href="#💻-Development" class="headerlink" title="💻 Development"></a>💻 Development</h3><p>If you want to contribute to this project, you can clone the <code>dev</code> branch and check out the <a class="link"   href="https://redefine-docs.ohevan.com/developer" >Development Docs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> to get started.</p>
<h2 id="进阶优化"><a href="#进阶优化" class="headerlink" title="进阶优化"></a>进阶优化</h2><h3 id="新增文章时自动打开Markdown编辑器"><a href="#新增文章时自动打开Markdown编辑器" class="headerlink" title="新增文章时自动打开Markdown编辑器"></a>新增文章时自动打开Markdown编辑器</h3><blockquote>
<p>需求：由于每次在使用 <code>hexo n &quot;文章名称&quot;</code> 时还要去打开编辑器，这太麻烦了！我们可以通过一个监听的<code> js</code>代码去监听<code>hexo</code>新建文章的命令，并自动打开相应的 Markdown编辑器来实现联动，这样岂不是即方便且优雅！</p>
</blockquote>
<ol>
<li><p>首先在 <code>hexo/scripts</code> 下新建一个 <code>editArticle.js</code> 文件，如果没有 <code>scripts</code> 文件可以手动创建一个。</p>
</li>
<li><p>在<code>editArticle.js</code> 文件并写入如下内容即可</p>
</li>
</ol>
  <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建文档时，启动typora打开文章</span></span><br><span class="line">hexo.<span class="title function_">on</span>(<span class="string">&quot;new&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = data.<span class="property">path</span>;</span><br><span class="line">  <span class="keyword">const</span> typoraPath = <span class="title function_">getTyporaPath</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (typoraPath) &#123;</span><br><span class="line">    <span class="title function_">spawn</span>(typoraPath, [filename]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前的操作系统，设置启动应用的路径（编辑器可执行文件的位置,要根据自己实际情况更改）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTyporaPath</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> platform = os.<span class="title function_">type</span>();</span><br><span class="line">  <span class="keyword">if</span> (platform === <span class="string">&quot;Darwin&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// MacOS</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/Applications/Typora.app/Contents/MacOS/Typora&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (platform === <span class="string">&quot;Windows_NT&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// Windows</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;D:\\Typora\\Typora.exe&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Unsupported platform:&quot;</span>, platform);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>EvenLoop队列中的执行顺序</title>
    <url>/2023/03/28/Javascript/EvenLoop%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>前言：谈谈<code>promise.resove</code>,<code>setTimeout</code>,<code>setImmediate</code>,<code>process.nextTick</code>在EvenLoop队列中的执行顺序</p>
</blockquote>
<h2 id="1-问题的引出"><a href="#1-问题的引出" class="headerlink" title="1. 问题的引出"></a>1. 问题的引出</h2><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//输出2,1</span></span><br></pre></td></tr></table></figure></div>

<p>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>
<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出为  1  2 3</span></span><br></pre></td></tr></table></figure></div>

<p>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>
<h2 id="2-Job-queue中的执行顺序"><a href="#2-Job-queue中的执行顺序" class="headerlink" title="2 . Job queue中的执行顺序"></a>2 . Job queue中的执行顺序</h2><p>在Job queue中的队列分为两种类型：微任务(macro-task)和宏任务(micro-task)。我们举例来看执行顺序的规定，我们设</p>
<p>macro-task队列包含任务: <em><strong>a1, a2 , a3</strong></em><br>micro-task队列包含任务: <em><strong>b1, b2 , b3</strong></em></p>
<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 <em><strong>a1</strong></em> 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行<em><strong>b1, b2 , b3</strong></em>，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>
<p>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>
<p>macro-task队列真实包含任务：</p>
<p><strong>script(主程序代码),setTimeout, setInterval, setImmediate, I&#x2F;O, UI rendering</strong></p>
<p>micro-task队列真实包含任务：<br><em><strong>process.nextTick, Promises, Object.observe, MutationObserver</strong></em></p>
<p>由此我们得到的执行顺序应该为：</p>
<p><em><strong>script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I&#x2F;O——&gt;UI rendering</strong></em></p>
<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>
<h2 id="3-真实环境中执行顺序的举例"><a href="#3-真实环境中执行顺序的举例" class="headerlink" title="3 . 真实环境中执行顺序的举例"></a>3 . 真实环境中执行顺序的举例</h2><h3 id="1-setTimeout和promise"><a href="#1-setTimeout和promise" class="headerlink" title="(1) setTimeout和promise"></a>(1) setTimeout和promise</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们先以第1小节的例子为例，这里遵循的顺序为：</p>
<p><em><strong>script(主程序代码)——&gt;promise——&gt;setTimeout</strong></em><br>对应的输出依次为：1 ——&gt;2——&gt;3</p>
<h3 id="2-process-nextTick和promise、setTimeout"><a href="#2-process-nextTick和promise、setTimeout" class="headerlink" title="(2) process.nextTick和promise、setTimeout"></a>(2) process.nextTick和promise、setTimeout</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//输出2,6,5,3,4,1</span></span><br></pre></td></tr></table></figure></div>

<p>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>
<p>首先分析Job queue的执行顺序：</p>
<p><em><strong>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</strong></em></p>
<p>I) <em><strong>主体部分</strong></em>： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</p>
<p>II)<em><strong>process.nextTick</strong></em>: 输出5</p>
<p>III）<em><strong>promise</strong></em>： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4</p>
<p>IV) <em><strong>setTimeout</strong></em> ： 最后输出1</p>
<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>
<h3 id="3-更复杂的例子"><a href="#3-更复杂的例子" class="headerlink" title="(3)更复杂的例子"></a>(3)更复杂的例子</h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125;,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">resolve</span>()&#125;,<span class="number">0</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出的是  2 6 5 1 3 4</span></span><br></pre></td></tr></table></figure></div>

<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>
<blockquote>
<p>文章转载来源：: <a class="link"   href="https://github.com/forthealllight/blog/issues/5" >https://github.com/forthealllight/blog/issues/5<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>EvenLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>提升幸福度的JS小技巧</title>
    <url>/2020/02/28/Javascript/JS%E5%A5%87%E6%B7%AB%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="1、类型强制转换"><a href="#1、类型强制转换" class="headerlink" title="1、类型强制转换"></a>1、类型强制转换</h2><h3 id="1-1-string强制转换为数字"><a href="#1-1-string强制转换为数字" class="headerlink" title="1.1 string强制转换为数字"></a><strong>1.1 string强制转换为数字</strong></h3><p>可以用 <code>*1</code>来转化为数字(实际上是调用 <code>.valueOf</code>方法)</p>
<p>然后使用 <code>Number.isNaN</code>来判断是否为 <code>NaN</code>，或者使用 <code>a!==a</code> 来判断是否为 <code>NaN</code>，因为 <code>NaN!==NaN</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;32&#x27; * 1            // 32</span><br><span class="line">&#x27;ds&#x27; * 1            // NaN</span><br><span class="line">null * 1            // 0</span><br><span class="line">undefined * 1    // NaN</span><br><span class="line">1  * &#123; valueOf: ()=&gt;&#x27;3&#x27; &#125;        // 3</span><br></pre></td></tr></table></figure></div>

<p><strong>常用：</strong> 也可以使用 <code>+</code>来转化字符串为数字</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ &#x27;123&#x27;            // 123</span><br><span class="line">+ &#x27;ds&#x27;               // NaN</span><br><span class="line">+ &#x27;&#x27;                    // 0</span><br><span class="line">+ null              // 0</span><br><span class="line">+ undefined    // NaN</span><br><span class="line">+ &#123; valueOf: ()=&gt;&#x27;3&#x27; &#125;    // 3</span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-object强制转化为string"><a href="#1-2-object强制转化为string" class="headerlink" title="1.2 object强制转化为string"></a><strong>1.2 object强制转化为string</strong></h3><p>可以使用 <code>字符串+Object</code> 的方式来转化对象为字符串(实际上是调用 <code>.toString()</code> 方法)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;the Math object:&#x27; + Math                // &quot;the Math object:[object Math]&quot;</span><br><span class="line">&#x27;the JSON object:&#x27; + JSON              // &quot;the JSON object:[object JSON]&quot;</span><br></pre></td></tr></table></figure></div>

<p>当然也可以覆盖对象的 <code>toString</code>和 <code>valueOf</code>方法来自定义对象的类型转换：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  * &#123; valueOf: ()=&gt;&#x27;3&#x27; &#125;                // 6</span><br><span class="line">&#x27;J&#x27; + &#123; toString: ()=&gt;&#x27;S&#x27; &#125;                // &quot;JS&quot;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>《Effective JavaScript》P11：当 <code>+</code>用在连接字符串时，当一个对象既有 <code>toString</code>方法又有 <code>valueOf</code>方法时候，JS通过盲目使用 <code>valueOf</code>方法来解决这种含糊。</p>
</blockquote>
<p>对象通过 <code>valueOf</code>方法强制转换为数字，通过 <code>toString</code>方法强制转换为字符串</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27; + &#123;toString:()=&gt;&#x27;S&#x27;,valueOf:()=&gt;&#x27;J&#x27;&#125;                // J</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-使用Boolean过滤数组中的所有假值"><a href="#1-3-使用Boolean过滤数组中的所有假值" class="headerlink" title="1.3 使用Boolean过滤数组中的所有假值"></a><strong>1.3 使用Boolean过滤数组中的所有假值</strong></h3><p>我们知道JS中有一些假值：<code>false</code>， <code>null</code>， <code>0</code>， <code>&quot;&quot;</code>， <code>undefined</code>， <code>NaN</code>，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const compact = arr =&gt; arr.filter(Boolean)</span><br><span class="line">compact([0, 1, false, 2, &#x27;&#x27;, 3, &#x27;a&#x27;, &#x27;e&#x27; * 23, NaN, &#x27;s&#x27;, 34])             // [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ]</span><br></pre></td></tr></table></figure></div>

<h3 id="1-4-双位运算符"><a href="#1-4-双位运算符" class="headerlink" title="1.4 双位运算符 ~~"></a><strong>1.4 双位运算符 ~~</strong></h3><p>可以使用双位操作符来替代正数的 <code>Math.floor()</code>，替代负数的 <code>Math.ceil()</code>。双否定位操作符的优势在于它执行相同的操作运行速度更快。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.floor(4.9) === 4      //true</span><br><span class="line">// 简写为：</span><br><span class="line">~~4.9 === 4      //true</span><br></pre></td></tr></table></figure></div>

<p>不过要注意，对正数来说 <code>~~</code> 运算结果与 <code>Math.floor()</code> 运算结果相同，而对于负数来说与 <code>Math.ceil()</code>的运算结果相同：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~4.5                // 4</span><br><span class="line">Math.floor(4.5)      // 4</span><br><span class="line">Math.ceil(4.5)       // 5</span><br><span class="line"></span><br><span class="line">~~-4.5                // -4</span><br><span class="line">Math.floor(-4.5)     // -5</span><br><span class="line">Math.ceil(-4.5)      // -4</span><br></pre></td></tr></table></figure></div>

<h3 id="1-5-短路运算符"><a href="#1-5-短路运算符" class="headerlink" title="1.5 短路运算符"></a><strong>1.5 短路运算符</strong></h3><p>我们知道逻辑与 <code>&amp;&amp;</code>与逻辑或 <code>||</code>是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了；</p>
<p>可以理解为：</p>
<ul>
<li><code>&amp;&amp;</code>为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值</li>
<li><code>||</code>为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let variable1</span><br><span class="line">let variable2 = variable1  || &#x27;foo&#x27;</span><br></pre></td></tr></table></figure></div>

<p>如果variable1是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的 <code>foo</code>。</p>
<p>也可以用来进行简单的判断，取代冗长的 <code>if</code>语句：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let variable = param &amp;&amp; param.prop</span><br></pre></td></tr></table></figure></div>

<p>如果 <code>param</code>如果为真值则返回 <code>param.prop</code>属性，否则返回 <code>param</code>这个假值，这样在某些地方防止 <code>param</code>为 <code>undefined</code>的时候还取其属性造成报错。</p>
<h3 id="1-6-取整"><a href="#1-6-取整" class="headerlink" title="**1.6 取整 **"></a>**1.6 取整 **</h3><p>对一个数字 <code>|0</code>可以取整，负数也同样适用， <code>num|0</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.3 | 0         // 1</span><br><span class="line">-1.9 | 0        // -1</span><br></pre></td></tr></table></figure></div>

<h3 id="1-7-判断奇偶数"><a href="#1-7-判断奇偶数" class="headerlink" title="**1.7 判断奇偶数 **"></a>**1.7 判断奇偶数 **</h3><p>对一个数字 <code>&amp;1</code>可以判断奇偶数，负数也同样适用， <code>num&amp;1</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const num=3;</span><br><span class="line">!!(num &amp; 1)                    // true</span><br><span class="line">!!(num % 2)                    // true</span><br></pre></td></tr></table></figure></div>

<h2 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数</h2><h3 id="2-1-函数默认值"><a href="#2-1-函数默认值" class="headerlink" title="2.1 函数默认值"></a><strong>2.1 函数默认值</strong></h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">func = (l, m = 3, n = 4 ) =&gt; (l * m * n);</span><br><span class="line">func(2)             //output: 24</span><br></pre></td></tr></table></figure></div>

<p>注意，传入参数为 <code>undefined</code>或者不传入的时候会使用默认参数，但是传入 <code>null</code>还是会覆盖默认参数。</p>
<h3 id="2-2-强制参数"><a href="#2-2-强制参数" class="headerlink" title="2.2 强制参数"></a><strong>2.2 强制参数</strong></h3><p>默认情况下，如果不向函数参数传值，那么JS 会将函数参数设置为 <code>undefined</code>。其它一些语言则会发出警告或错误。要执行参数分配，可以使用 <code>if</code>语句抛出未定义的错误，或者可以利用 <code>强制参数</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mandatory = ( ) =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;Missing parameter!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">foo = (bar = mandatory( )) =&gt; &#123;     // 这里如果不传入参数，就会执行manadatory函数报出错误</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-隐式返回值"><a href="#2-3-隐式返回值" class="headerlink" title="2.3 隐式返回值"></a><strong>2.3 隐式返回值</strong></h3><p>返回值是我们通常用来返回函数最终结果的关键字。只有一个语句的箭头函数，可以隐式返回结果（函数必须省略大括号 <code>&#123;&#125;</code>，以便省略返回关键字）。</p>
<p>要返回多行语句（例如对象文本），需要使用 <code>()</code>而不是 <code>&#123;&#125;</code>来包裹函数体。这样可以确保代码以单个语句的形式进行求值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function calcCircumference(diameter) &#123;</span><br><span class="line">  return Math.PI * diameter</span><br><span class="line">&#125;</span><br><span class="line">// 简写为：</span><br><span class="line">calcCircumference = diameter =&gt; (</span><br><span class="line">  Math.PI * diameter;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="2-4-惰性载入函数"><a href="#2-4-惰性载入函数" class="headerlink" title="2.4 惰性载入函数"></a><strong>2.4 惰性载入函数</strong></h3><p>在某个场景下我们的函数中有判断语句，这个判断依据在整个项目运行期间一般不会变化，所以判断分支在整个项目运行期间只会运行某个特定分支，那么就可以考虑惰性载入函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    if(a !== b)&#123;</span><br><span class="line">        console.log(&#x27;aaa&#x27;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#x27;bbb&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化后</span><br><span class="line">function foo()&#123;</span><br><span class="line">    if(a != b)&#123;</span><br><span class="line">        foo = function()&#123;</span><br><span class="line">            console.log(&#x27;aaa&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        foo = function()&#123;</span><br><span class="line">            console.log(&#x27;bbb&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。</p>
<h3 id="2-5-一次性函数"><a href="#2-5-一次性函数" class="headerlink" title="2.5 一次性函数"></a><strong>2.5 一次性函数</strong></h3><p>跟上面的惰性载入函数同理，可以在函数体里覆写当前函数，那么可以创建一个一次性的函数，重新赋值之前的代码相当于只运行了一次，适用于运行一些只需要执行一次的初始化代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var sca = function() &#123;</span><br><span class="line">    console.log(&#x27;msg&#x27;)</span><br><span class="line">    sca = function() &#123;</span><br><span class="line">        console.log(&#x27;foo&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sca()        // msg</span><br><span class="line">sca()        // foo</span><br><span class="line">sca()        // foo</span><br></pre></td></tr></table></figure></div>

<h2 id="3、字符串"><a href="#3、字符串" class="headerlink" title="3、字符串"></a>3、字符串</h2><h3 id="3-1-字符串比较时间先后"><a href="#3-1-字符串比较时间先后" class="headerlink" title="3.1 字符串比较时间先后"></a><strong>3.1 字符串比较时间先后</strong></h3><p>比较时间先后顺序可以使用字符串：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &quot;2014-08-08&quot;;</span><br><span class="line">var b = &quot;2014-09-09&quot;;</span><br><span class="line"></span><br><span class="line">console.log(a&gt;b, a&lt;b); // false true</span><br><span class="line">console.log(&quot;21:00&quot;&lt;&quot;09:10&quot;);  // false</span><br><span class="line">console.log(&quot;21:00&quot;&lt;&quot;9:10&quot;);   // true   时间形式注意补</span><br></pre></td></tr></table></figure></div>

<p>因为字符串比较大小是按照字符串从左到右每个字符的 <code>charCode</code>来的，但所以特别要注意时间形式注意补0</p>
<h2 id="4、数字"><a href="#4、数字" class="headerlink" title="4、数字"></a>4、数字</h2><h3 id="4-1-不同进制表示法"><a href="#4-1-不同进制表示法" class="headerlink" title="4.1 不同进制表示法"></a><strong>4.1 不同进制表示法</strong></h3><p>ES6中新增了不同进制的书写格式，在后台传参的时候要注意这一点。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">29            // 10进制</span><br><span class="line">035            // 8进制29      原来的方式</span><br><span class="line">0o35            // 8进制29      ES6的方式</span><br><span class="line">0x1d            // 16进制29</span><br><span class="line">0b11101            // 2进制29</span><br></pre></td></tr></table></figure></div>

<h3 id="4-2-精确到指定位数的小数"><a href="#4-2-精确到指定位数的小数" class="headerlink" title="4.2 精确到指定位数的小数"></a><strong>4.2 精确到指定位数的小数</strong></h3><p>将数字四舍五入到指定的小数位数。使用 <code>Math.round()</code> 和模板字面量将数字四舍五入为指定的小数位数。 省略第二个参数 <code>decimals</code> ，数字将被四舍五入到一个整数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const round = (n, decimals = 0) =&gt; Number(`$&#123;Math.round(`$&#123;n&#125;e$&#123;decimals&#125;`)&#125;e-$&#123;decimals&#125;`)</span><br><span class="line">round(1.345, 2)                 // 1.35</span><br><span class="line">round(1.345, 1)                 // 1.3</span><br></pre></td></tr></table></figure></div>

<h3 id="4-3-数字补0操作"><a href="#4-3-数字补0操作" class="headerlink" title="4.3 数字补0操作"></a><strong>4.3 数字补0操作</strong></h3><p>有时候比如显示时间的时候有时候会需要把一位数字显示成两位，这时候就需要补0操作，可以使用 <code>slice</code>和string的 <code>padStart</code>方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const addZero1 = (num, len = 2) =&gt; (`0$&#123;num&#125;`).slice(-len)</span><br><span class="line">const addZero2 = (num, len = 2) =&gt; (`$&#123;num&#125;`).padStart( len   , &#x27;0&#x27;)</span><br><span class="line">addZero1(3) // 03</span><br><span class="line"></span><br><span class="line">addZero2(32,4)  // 0032</span><br></pre></td></tr></table></figure></div>

<h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><h3 id="5-1-reduce方法同时实现map和filter"><a href="#5-1-reduce方法同时实现map和filter" class="headerlink" title="5.1 reduce方法同时实现map和filter"></a><strong>5.1 reduce方法同时实现map和filter</strong></h3><p>假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。</p>
<p>在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const numbers = [10, 20, 30, 40];</span><br><span class="line">const doubledOver50 = numbers.reduce((finalList, num) =&gt; &#123;</span><br><span class="line">  num = num * 2;</span><br><span class="line">  if (num &gt; 50) &#123;</span><br><span class="line">    finalList.push(num);</span><br><span class="line">  &#125;</span><br><span class="line">  return finalList;</span><br><span class="line">&#125;, []);</span><br><span class="line">doubledOver50;            // [60, 80]</span><br></pre></td></tr></table></figure></div>

<h3 id="5-2-统计数组中相同项的个数"><a href="#5-2-统计数组中相同项的个数" class="headerlink" title="5.2 统计数组中相同项的个数"></a><strong>5.2 统计数组中相同项的个数</strong></h3><p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。</p>
<p>下面的代码将统计每一种车的数目然后把总数用一个对象表示。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var cars = [&#x27;BMW&#x27;,&#x27;Benz&#x27;, &#x27;Benz&#x27;, &#x27;Tesla&#x27;, &#x27;BMW&#x27;, &#x27;Toyota&#x27;];</span><br><span class="line">var carsObj = cars.reduce(function (obj, name) &#123;</span><br><span class="line">  obj[name] = obj[name] ? ++obj[name] : 1;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="5-3-使用解构来交换参数数值"><a href="#5-3-使用解构来交换参数数值" class="headerlink" title="5.3 使用解构来交换参数数值"></a><strong>5.3 使用解构来交换参数数值</strong></h3><p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let param1 = 1;</span><br><span class="line">let param2 = 2;</span><br><span class="line">[param1, param2] = [param2, param1];</span><br><span class="line">console.log(param1) // 2</span><br><span class="line">console.log(param2) // 1</span><br></pre></td></tr></table></figure></div>

<p>当然我们关于交换数值有不少其他办法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var temp = a; a = b; b = temp            </span><br><span class="line">b = [a, a = b][0]                     </span><br><span class="line">a = a + b; b = a - b; a = a - b        </span><br></pre></td></tr></table></figure></div>

<h3 id="5-4-接收函数返回的多个结果"><a href="#5-4-接收函数返回的多个结果" class="headerlink" title="5.4 接收函数返回的多个结果"></a><strong>5.4 接收函数返回的多个结果</strong></h3><p>在下面的代码中，我们从&#x2F;post中获取一个帖子，然后在&#x2F;comments中获取相关评论。由于我们使用的是async&#x2F;await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function getFullPost()&#123;</span><br><span class="line">  return await Promise.all([</span><br><span class="line">     fetch(&#x27;/post&#x27;),</span><br><span class="line">     fetch(&#x27;/comments&#x27;)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line">const [post, comments] = getFullPost();</span><br></pre></td></tr></table></figure></div>

<h3 id="5-5-将数组平铺到指定深度"><a href="#5-5-将数组平铺到指定深度" class="headerlink" title="5.5 将数组平铺到指定深度"></a><strong>5.5 将数组平铺到指定深度</strong></h3><p>使用递归，为每个深度级别 <code>depth</code> 递减 1 。 使用 <code>Array.reduce()</code> 和 <code>Array.concat()</code>来合并元素或数组。 基本情况下， <code>depth</code> 等于 1 停止递归。 省略第二个参数， <code>depth</code> 只能平铺到 1 (单层平铺) 的深度。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const flatten = (arr, depth = 1) =&gt;</span><br><span class="line">  depth != 1</span><br><span class="line">    ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), [])</span><br><span class="line">    : arr.reduce((a, v) =&gt; a.concat(v), []);</span><br><span class="line">flatten([1, [2], 3, 4]);                             // [1, 2, 3, 4]</span><br><span class="line">flatten([1, [2, [3, [4, 5], 6], 7], 8], 2);           // [1, 2, 3, [4, 5], 6, 7, 8]</span><br></pre></td></tr></table></figure></div>

<h3 id="5-6-数组的对象解构"><a href="#5-6-数组的对象解构" class="headerlink" title="5.6 数组的对象解构"></a><strong>5.6 数组的对象解构</strong></h3><p>数组也可以对象解构，可以方便的获取数组的第n个值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const csvFileLine = &#x27;1997,John Doe,US,john@doe.com,New York&#x27;;</span><br><span class="line">const &#123; 2: country, 4: state &#125; = csvFileLine.split(&#x27;,&#x27;);</span><br><span class="line"></span><br><span class="line">country            // US</span><br><span class="line">state            // New Yourk</span><br></pre></td></tr></table></figure></div>

<h2 id="6、对象"><a href="#6、对象" class="headerlink" title="6、对象"></a>6、对象</h2><h3 id="6-1-使用解构删除不必要属性"><a href="#6-1-使用解构删除不必要属性" class="headerlink" title="6.1 使用解构删除不必要属性"></a><strong>6.1 使用解构删除不必要属性</strong></h3><p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。</p>
<p>下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: &#x27;1&#x27;, _internal:&quot;secret&quot;, tooBig:&#123;&#125;, el2: &#x27;2&#x27;, el3: &#x27;3&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">console.log(cleanObject);                         // &#123;el1: &#x27;1&#x27;, el2: &#x27;2&#x27;, el3: &#x27;3&#x27;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-2-在函数参数中解构嵌套对象"><a href="#6-2-在函数参数中解构嵌套对象" class="headerlink" title="6.2 在函数参数中解构嵌套对象"></a><strong>6.2 在函数参数中解构嵌套对象</strong></h3><p>在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var car = &#123;</span><br><span class="line">  model: &#x27;bmw 2018&#x27;,</span><br><span class="line">  engine: &#123;</span><br><span class="line">    v6: true,</span><br><span class="line">    turbo: true,</span><br><span class="line">    vin: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const modelAndVIN = (&#123;model, engine: &#123;vin&#125;&#125;) =&gt; &#123;</span><br><span class="line">  console.log(`model: $&#123;model&#125; vin: $&#123;vin&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">modelAndVIN(car); // =&gt; model: bmw 2018  vin: 12345</span><br></pre></td></tr></table></figure></div>

<h2 id="7、代码复用"><a href="#7、代码复用" class="headerlink" title="7、代码复用"></a>7、代码复用</h2><h3 id="7-1-Object-key"><a href="#7-1-Object-key" class="headerlink" title="7.1 Object [key]"></a><strong>7.1 Object [key]</strong></h3><p>虽然将 <code>foo.bar</code> 写成 <code>foo[&#39;bar&#39;]</code> 是一种常见的做法，但是这种做法构成了编写可重用代码的基础。许多框架使用了这种方法，比如element的表单验证。</p>
<p>请考虑下面这个验证函数的简化示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function validate(values) &#123;</span><br><span class="line">  if(!values.first)</span><br><span class="line">    return false;</span><br><span class="line">  if(!values.last)</span><br><span class="line">    return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">console.log(validate(&#123;first:&#x27;Bruce&#x27;,last:&#x27;Wayne&#x27;&#125;)); // true</span><br></pre></td></tr></table></figure></div>

<p>上面的函数完美的完成验证工作。但是当有很多表单，则需要应用验证，此时会有不同的字段和规则。如果可以构建一个在运行时配置的通用验证函数，会是一个好选择。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// object validation rules</span><br><span class="line">const schema = &#123;</span><br><span class="line">  first: &#123;</span><br><span class="line">    required:true</span><br><span class="line">  &#125;,</span><br><span class="line">  last: &#123;</span><br><span class="line">    required:true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// universal validation function</span><br><span class="line">const validate = (schema, values) =&gt; &#123;</span><br><span class="line">  for(field in schema) &#123;</span><br><span class="line">    if(schema[field].required) &#123;</span><br><span class="line">      if(!values[field]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">console.log(validate(schema, &#123;first:&#x27;Bruce&#x27;&#125;)); // false</span><br><span class="line">console.log(validate(schema, &#123;first:&#x27;Bruce&#x27;,last:&#x27;Wayne&#x27;&#125;)); // true</span><br></pre></td></tr></table></figure></div>

<p>现在有了这个验证函数，我们就可以在所有窗体中重用，而无需为每个窗体编写自定义验证函数。</p>
<blockquote>
<p>参考：</p>
<p>1、JavaScript 开发人员需要知道的简写技巧<a class="link"   href="https://my.oschina.net/powertoolsteam/blog/1555271" >https://my.oschina.net/powertoolsteam/blog/1555271<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>2、《Effective Javascript》<a class="link"   href="https://book.douban.com/subject/25786138/" >https://book.douban.com/subject/25786138/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>3、<a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzUzOTM0MTE4OQ==&mid=2247484057&idx=1&sn=c6c213fe5d3c3b5b94a51a07982acc5b&scene=21#wechat_redirect" >不得不知的ES6小技巧<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>4、js运算符的一些特殊应用<a class="link"   href="https://www.cnblogs.com/daysme/p/6492398.html" >https://www.cnblogs.com/daysme/p/6492398.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>5、JS高级技巧(简洁版)<a class="link"   href="https://juejin.im/post/5aeff683f265da0ba351f786" >https://juejin.im/post/5aeff683f265da0ba351f786<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>6、 字符串比较大小<a class="link"   href="https://www.cnblogs.com/52cik/p/js-string-comparison.html" >https://www.cnblogs.com/52cik/p/js-string-comparison.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>常用js方法封装</title>
    <url>/2020/02/28/Javascript/JS%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="截取指定字节数的字符串"><a href="#截取指定字节数的字符串" class="headerlink" title="截取指定字节数的字符串"></a>截取指定字节数的字符串</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截取指定字节的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str 要截取的字符穿</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len 要截取的长度，根据字节计算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> suffix 截取前len个后，其余的字符的替换字符，一般用“…”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cutString</span>(<span class="params">str, len, suffix</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (!suffix) suffix = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> templen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="title function_">charCodeAt</span>(i) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      templen += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      templen++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (templen == len) &#123;</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">substring</span>(<span class="number">0</span>, i + <span class="number">1</span>) + suffix;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (templen &gt; len) &#123;</span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">substring</span>(<span class="number">0</span>, i) + suffix;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="常用日期时间函数"><a href="#常用日期时间函数" class="headerlink" title="常用日期时间函数"></a>常用日期时间函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 时间戳格式化显示</span></span><br><span class="line"><span class="comment">* @param notation: 格式化连接符号,默认以年月日格式显示</span></span><br><span class="line"><span class="comment">* @param timeStamp: 需要格式化的时间戳,默认为当前时间戳 </span></span><br><span class="line"><span class="comment">* @returns String </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTimeFormat</span>(<span class="params">notation,timeStamp</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tempStamp = timeStamp || <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(tempStamp);</span><br><span class="line">  <span class="keyword">let</span> Y = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">  <span class="keyword">let</span> M =(date.<span class="title function_">getMonth</span>()+<span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> D = date.<span class="title function_">getDate</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!notation) &#123;</span><br><span class="line">    <span class="keyword">let</span> strTime = <span class="string">`<span class="subst">$&#123;Y&#125;</span>年<span class="subst">$&#123;(M)&#125;</span>月<span class="subst">$&#123;D&#125;</span>日`</span></span><br><span class="line">     <span class="keyword">return</span> strTime</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> strTime = <span class="string">`<span class="subst">$&#123;Y&#125;</span><span class="subst">$&#123;notation&#125;</span><span class="subst">$&#123;(M)&#125;</span><span class="subst">$&#123;notation&#125;</span><span class="subst">$&#123;D&#125;</span>`</span></span><br><span class="line">      <span class="keyword">return</span> strTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时时间格式化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format_time</span>(<span class="params">timeStamp</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeStamp / (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> leave1 = timeStamp % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> hours = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave1 / (<span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> leave2 = leave1 % (<span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave2 / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> leave3 = leave2 % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> seconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave3 / <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">if</span> (day) <span class="keyword">return</span> day + <span class="string">&quot;天&quot;</span> + hours + <span class="string">&quot;小时&quot;</span> + minutes + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (hours) <span class="keyword">return</span> hours + <span class="string">&quot;小时&quot;</span> + minutes + <span class="string">&quot;分&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (minutes) <span class="keyword">return</span> minutes + <span class="string">&quot;分&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (seconds) <span class="keyword">return</span> seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;时间到！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h3 id="图片加载失败模块"><a href="#图片加载失败模块" class="headerlink" title="图片加载失败模块"></a>图片加载失败模块</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html代码</span></span><br><span class="line">&lt;img src=<span class="string">&quot;./1.webp&quot;</span> data-placeholder=<span class="string">&quot;placeholder&quot;</span>&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// javascript代码</span></span><br><span class="line"><span class="keyword">let</span> imgList = &#123;</span><br><span class="line">  <span class="attr">default</span>: <span class="string">&#x27;default.jpg&#x27;</span> ,</span><br><span class="line">  <span class="attr">base64</span>: <span class="string">&#x27;data:image/jpeg;base64,/9j/BLAD/4QEr&#x27;</span>,</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="string">&#x27;placeholder.jpg&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// 获取当前元素(对象解构赋值)</span></span><br><span class="line">  <span class="keyword">let</span> &#123;target&#125; = e;</span><br><span class="line">  <span class="comment">// 获取标签名和自定义属性对象</span></span><br><span class="line">  <span class="keyword">let</span> &#123;tagName,dataset&#125; = target;</span><br><span class="line">  <span class="comment">// 获取自定义属性对象默认的time和自定义的placeholder</span></span><br><span class="line">  <span class="keyword">let</span> &#123;time=<span class="number">1</span>,placeholder&#125; = dataset;</span><br><span class="line">	<span class="comment">// 判断是否为图片元素</span></span><br><span class="line">  <span class="keyword">if</span> (tagName === <span class="string">&#x27;IMG&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 当默认和自定义图片都加载失败3次以上则加载本地base64图片</span></span><br><span class="line">    <span class="keyword">if</span> (time&lt;<span class="number">3</span>) &#123;</span><br><span class="line">      target.<span class="property">src</span> = imgList[placeholder || <span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">      dataset.<span class="property">time</span> = time+<span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      target.<span class="property">src</span> = imgList[<span class="string">&#x27;base64&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></div>


<h3 id="获取URL的查询参数"><a href="#获取URL的查询参数" class="headerlink" title="获取URL的查询参数"></a>获取URL的查询参数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> q = &#123;&#125;;	<span class="comment">// 创建查询结果对象</span></span><br><span class="line">location.<span class="property">search</span>.<span class="title function_">replace</span>(<span class="regexp">/([^?&amp;=]+)=([^&amp;]+)/g</span>,<span class="function">(<span class="params">_,k,v</span>)=&gt;</span>q[k]=v);</span><br></pre></td></tr></table></figure></div>

<h3 id="创建特定大小的数组"><a href="#创建特定大小的数组" class="headerlink" title="创建特定大小的数组"></a>创建特定大小的数组</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">keys</span>()]	<span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数组去重（多种）"><a href="#数组去重（多种）" class="headerlink" title="数组去重（多种）"></a>数组去重（多种）</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique1</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr)) </span><br><span class="line">    <span class="comment">// 或 return [...new Set(arr)]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i, array</span>) =&gt;</span> array.<span class="title function_">indexOf</span>(v) === i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique3</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,cur</span>) =&gt;</span> prev.<span class="title function_">includes</span>(cur) ? prev : [...prev,cur],[]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique4</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="数组混淆"><a href="#数组混淆" class="headerlink" title="数组混淆"></a>数组混淆</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="function">()=&gt;</span><span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="生成随机十六进制代码（生成随机颜色）"><a href="#生成随机十六进制代码（生成随机颜色）" class="headerlink" title="生成随机十六进制代码（生成随机颜色）"></a>生成随机十六进制代码（生成随机颜色）</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;#&#x27;</span>+ <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">0xffffff</span>).<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">padEnd</span>(<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="生成随机11位ID"><a href="#生成随机11位ID" class="headerlink" title="生成随机11位ID"></a>生成随机11位ID</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">substring</span>(<span class="number">2</span>,<span class="number">13</span>)	<span class="comment">// hg7znok52x</span></span><br></pre></td></tr></table></figure></div>



<h3 id="检测平台（设备）类型"><a href="#检测平台（设备）类型" class="headerlink" title="检测平台（设备）类型"></a>检测平台（设备）类型</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">WIN</span> = <span class="variable language_">window</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">LOC</span> = <span class="variable constant_">WIN</span>[<span class="string">&quot;location&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">NA</span> = <span class="variable constant_">WIN</span>.<span class="property">navigator</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">UA</span> = <span class="variable constant_">NA</span>.<span class="property">userAgent</span>.<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">needle</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> needle.<span class="title function_">test</span>(<span class="variable constant_">UA</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsTouch</span> = <span class="string">&quot;ontouchend&quot;</span> <span class="keyword">in</span> <span class="variable constant_">WIN</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsAndroid</span> = <span class="title function_">test</span>(<span class="regexp">/android|htc/</span>) || <span class="regexp">/linux/i</span>.<span class="title function_">test</span>(<span class="variable constant_">NA</span>.<span class="property">platform</span> + <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsIPad</span> = !<span class="title class_">IsAndroid</span> &amp;&amp; <span class="title function_">test</span>(<span class="regexp">/ipad/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsIPhone</span> = !<span class="title class_">IsAndroid</span> &amp;&amp; <span class="title function_">test</span>(<span class="regexp">/ipod|iphone/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsIOS</span> = <span class="title class_">IsIPad</span> || <span class="title class_">IsIPhone</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsWinPhone</span> = <span class="title function_">test</span>(<span class="regexp">/windows phone/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsWebapp</span> = !!<span class="variable constant_">NA</span>[<span class="string">&quot;standalone&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsXiaoMi</span> = <span class="title class_">IsAndroid</span> &amp;&amp; <span class="title function_">test</span>(<span class="regexp">/mi\s+/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsUC</span> = <span class="title function_">test</span>(<span class="regexp">/ucbrowser/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsWeixin</span> = <span class="title function_">test</span>(<span class="regexp">/micromessenger/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsBaiduBrowser</span> = <span class="title function_">test</span>(<span class="regexp">/baidubrowser/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsChrome</span> = !!<span class="variable constant_">WIN</span>[<span class="string">&quot;chrome&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsBaiduBox</span> = <span class="title function_">test</span>(<span class="regexp">/baiduboxapp/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsPC</span> = !<span class="title class_">IsAndroid</span> &amp;&amp; !<span class="title class_">IsIOS</span> &amp;&amp; !<span class="title class_">IsWinPhone</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsHTC</span> = <span class="title class_">IsAndroid</span> &amp;&amp; <span class="title function_">test</span>(<span class="regexp">/htc\s+/</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">IsBaiduWallet</span> = <span class="title function_">test</span>(<span class="regexp">/baiduwallet/</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="常用的日期时间函数"><a href="#常用的日期时间函数" class="headerlink" title="常用的日期时间函数"></a>常用的日期时间函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 时间格式化显示</span></span><br><span class="line"><span class="comment">* @param notation: 格式化连接符号,默认以年月日格式显示</span></span><br><span class="line"><span class="comment">* @param timeStamp: 需要格式化的时间戳,默认为当前时间戳 </span></span><br><span class="line"><span class="comment">* @returns String </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTimeFormat</span>(<span class="params">notation,timeStamp</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> tempStamp = timeStamp || <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(tempStamp);</span><br><span class="line">  <span class="keyword">let</span> Y = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">  <span class="keyword">let</span> M =(date.<span class="title function_">getMonth</span>()+<span class="number">1</span>).<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> D = date.<span class="title function_">getDate</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!notation) &#123;</span><br><span class="line">    <span class="keyword">let</span> strTime = <span class="string">`<span class="subst">$&#123;Y&#125;</span>年<span class="subst">$&#123;(M)&#125;</span>月<span class="subst">$&#123;D&#125;</span>日`</span></span><br><span class="line">     <span class="keyword">return</span> strTime</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> strTime = <span class="string">`<span class="subst">$&#123;Y&#125;</span><span class="subst">$&#123;notation&#125;</span><span class="subst">$&#123;(M)&#125;</span><span class="subst">$&#123;notation&#125;</span><span class="subst">$&#123;D&#125;</span>`</span></span><br><span class="line">      <span class="keyword">return</span> strTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒计时时间格式化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format_time</span>(<span class="params">timeStamp</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> day = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timeStamp / (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave1 = timeStamp % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> hours = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave1 / (<span class="number">3600</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave2 = leave1 % (<span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave2 / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">let</span> leave3 = leave2 % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">let</span> seconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>(leave3 / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (day) <span class="keyword">return</span> day + <span class="string">&quot;天&quot;</span> + hours + <span class="string">&quot;小时&quot;</span> + minutes + <span class="string">&quot;分&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (hours) <span class="keyword">return</span> hours + <span class="string">&quot;小时&quot;</span> + minutes + <span class="string">&quot;分&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (minutes) <span class="keyword">return</span> minutes + <span class="string">&quot;分&quot;</span> + seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (seconds) <span class="keyword">return</span> seconds + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;时间到！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="跨端事件处理"><a href="#跨端事件处理" class="headerlink" title="跨端事件处理"></a>跨端事件处理</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持触摸事件</span></span><br><span class="line"><span class="keyword">let</span> isSupportTouch = (<span class="string">&quot;ontouchstart&quot;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">documentElement</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//禁用Enter键表单自动提交</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> target, code, tag;</span><br><span class="line">    <span class="keyword">if</span> (!event) &#123;</span><br><span class="line">        event = <span class="variable language_">window</span>.<span class="property">event</span>; <span class="comment">//针对ie浏览器</span></span><br><span class="line">        target = event.<span class="property">srcElement</span>;</span><br><span class="line">        code = event.<span class="property">keyCode</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">13</span>) &#123;</span><br><span class="line">            tag = target.<span class="property">tagName</span>;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="string">&quot;TEXTAREA&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        target = event.<span class="property">target</span>; <span class="comment">//针对遵循w3c标准的浏览器，如Firefox</span></span><br><span class="line">        code = event.<span class="property">keyCode</span>;</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">13</span>) &#123;</span><br><span class="line">            tag = target.<span class="property">tagName</span>;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="string">&quot;INPUT&quot;</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">doc, win</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.<span class="property">documentElement</span>,</span><br><span class="line">        resizeEvt = <span class="string">&#x27;orientationchange&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span> ? <span class="string">&#x27;orientationchange&#x27;</span> : <span class="string">&#x27;resize&#x27;</span>,</span><br><span class="line">        recalc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> clientWidth = docEl.<span class="property">clientWidth</span>;</span><br><span class="line">            <span class="keyword">var</span> fontSize = <span class="number">20</span>;</span><br><span class="line">            docEl.<span class="property">style</span>.<span class="property">fontSize</span> = fontSize + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            <span class="keyword">var</span> docStyles = <span class="title function_">getComputedStyle</span>(docEl);</span><br><span class="line">            <span class="keyword">var</span> realFontSize = <span class="built_in">parseFloat</span>(docStyles.<span class="property">fontSize</span>);</span><br><span class="line">            <span class="keyword">var</span> scale = realFontSize / fontSize;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;realFontSize: &quot;</span> + realFontSize + <span class="string">&quot;, scale: &quot;</span> + scale);</span><br><span class="line">            fontSize = clientWidth / <span class="number">667</span> * <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isIphoneX</span>()) fontSize = <span class="number">19</span>;</span><br><span class="line">            fontSize = fontSize / scale;</span><br><span class="line">            docEl.<span class="property">style</span>.<span class="property">fontSize</span> = fontSize + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// Abort if browser does not support addEventListener</span></span><br><span class="line">    <span class="keyword">if</span> (!doc.<span class="property">addEventListener</span>) <span class="keyword">return</span>;</span><br><span class="line">    win.<span class="title function_">addEventListener</span>(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    doc.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, recalc, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iphoneX判断</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isIphoneX</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="regexp">/iphone/gi</span>.<span class="title function_">test</span>(navigator.<span class="property">userAgent</span>) &amp;&amp; (screen.<span class="property">height</span> == <span class="number">812</span> &amp;&amp; screen.<span class="property">width</span> == <span class="number">375</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="variable language_">document</span>, <span class="variable language_">window</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="xss预防方式"><a href="#xss预防方式" class="headerlink" title="xss预防方式"></a>xss预防方式</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 敏感符号转义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">entities</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> e = &#123;</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span>: <span class="string">&#x27;&amp;quot;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&amp;&#x27;</span>: <span class="string">&#x27;&amp;amp;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&lt;&#x27;</span>: <span class="string">&#x27;&amp;lt;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&gt;&#x27;</span>: <span class="string">&#x27;&amp;gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">replace</span>(<span class="regexp">/[&quot;&lt;&gt;&amp;]/g</span>, <span class="function"><span class="params">m</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e[m]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Observer</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> t__messages = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">regist</span>: <span class="keyword">function</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> __messages[type] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        messages[type] = [fn];</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        __messages[type].<span class="title function_">push</span>(fn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fire</span>: <span class="keyword">function</span>(<span class="params">type, args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!__messages[type])&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> events = &#123;</span><br><span class="line">        <span class="attr">type</span>: type,</span><br><span class="line">        <span class="attr">args</span>: args || &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      len = __messages[type].<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">for</span>(;i&lt;len;i++)&#123;</span><br><span class="line">        __messages[type][i].<span class="title function_">call</span>(<span class="variable language_">this</span>, events);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">remove</span>: <span class="keyword">function</span>(<span class="params">type, fn</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(__messages[type] <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> i = __messages[type].<span class="property">length</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">          __messages[type][i] === fn &amp;&amp; __messages[type].<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></div>

<h3 id="模板渲染方法"><a href="#模板渲染方法" class="headerlink" title="模板渲染方法"></a>模板渲染方法</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">formatString</span>(<span class="params">str, data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/g</span>, <span class="keyword">function</span>(<span class="params">match, key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> data[key] === <span class="literal">undefined</span> ? <span class="string">&#x27;&#x27;</span> : data[key]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="置换函数"><a href="#置换函数" class="headerlink" title="置换函数"></a>置换函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, indexA, indexB</span>) &#123;</span><br><span class="line">    [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a !== b)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 惰性载入优化后的函数</span></span><br><span class="line"><span class="comment">// ps: 第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">        foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="一次性函数"><a href="#一次性函数" class="headerlink" title="一次性函数"></a>一次性函数</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sca = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">    sca = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sca</span>()        <span class="comment">// ==&gt;msg</span></span><br><span class="line"><span class="title function_">sca</span>()        <span class="comment">// ==&gt;foo</span></span><br><span class="line"><span class="title function_">sca</span>()        <span class="comment">// ==&gt;foo</span></span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型</title>
    <url>/2020/02/28/Javascript/JavaScript%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><blockquote>
<p>按照类型来分有<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p>
</blockquote>
<p><strong>基本数据类型：</strong><code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>Undefined</code>、<code>Symbol</code></p>
<p><strong>引用数据类型：</strong><code>Object</code>【Object是个大类，表示一种无序键值对的集合：function函数、array数组、date日期…等都归属于Object】</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\90856\Documents\思维导图\JavaScript的数据类型.png"
                      alt="JavaScript的数据类型"  
                >





<h2 id="JavaScript的内置对象-RegExp-正则表达式"><a href="#JavaScript的内置对象-RegExp-正则表达式" class="headerlink" title="JavaScript的内置对象_RegExp(正则表达式)"></a>JavaScript的内置对象_RegExp(正则表达式)</h2><blockquote>
<p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法，以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。下面介绍 JavaScript 正则表达式。</p>
</blockquote>
<p>RegExp中的方法：</p>
<ul>
<li><p>test():  </p>
<p>检索正则表达式与指定的字符串是否匹配。返回 <code>true</code> 或 <code>false</code>。</p>
</li>
<li><p>exec(): </p>
<p>在一个指定字符串中执行一个搜索匹配。返回一个结果<code>数组</code>或 <code>null</code></p>
</li>
<li><p>toString():  </p>
<p>返回一个表示该正则表达式的字符串</p>
</li>
</ul>
<p>String中用到正则的方法有：</p>
<ul>
<li><p>match():  </p>
<p>检索返回一个字符串匹配正则表达式的结果</p>
</li>
<li><p>replace():  </p>
<p>返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。                   原字符串不会改变</p>
</li>
<li><p>search():  </p>
</li>
<li><p>split():</p>
</li>
</ul>
<p>match: 提取匹配项</p>
<p>注意：<code>.match</code> 语法是目前为止一直使用的 <code>.test</code> 方法中的“反向”，即：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>String.prototype.match()</code></a></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;string&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/regex/</span>);</span><br><span class="line"><span class="regexp">/regex/</span>.<span class="title function_">test</span>(<span class="string">&#x27;string&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>多种模式匹配:  <code>/a|b|c/</code></p>
<p>精准匹配：<code>/abc/</code></p>
<p>范围匹配：<code>/[0-9a-z]/</code></p>
<p>字符集：<code>/q[abc]n/</code></p>
<p>字符组：<code>/P(engu|umpk)in/</code></p>
<p>否定字符集：[ ^0-9abc ] </p>
<p><a href="">g</a>：全局匹配</p>
<p><a href="">i</a> ：忽略大小写 <code>/Aa/i</code></p>
<p><a href="">+</a>：匹配一次或多次的字符</p>
<p><a href="">*</a>：匹配出现零次或多次的字符</p>
<p><a href="">?</a>：匹配零个或一个的字符</p>
<p><a href="">?</a>：懒惰匹配 <code>/a+?/</code></p>
<p><a href="">i</a>：贪婪匹配<code>/a+i/</code>（默认）</p>
<blockquote>
<p>tip: 用于设置数量符号<code>*</code>、<code>+</code>的匹配模式</p>
</blockquote>
<p><a href="/story$/">$</a>: 搜寻字符串末尾的匹配模式：<code>/Cal$/</code></p>
<p><a href="/story$/">^</a>: </p>
<ol>
<li>搜寻字符串开始的匹配模式：<code>/^Cal/</code></li>
<li>创建否定字符集 <code>[^0-9aeiou]</code></li>
</ol>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p><code>\w</code>：匹配大写字母和小写字母以及数字，等同于<code>[A-Za-z0-9_]</code></p>
<p><code>\W</code>：匹配模式是非字母数字字符，等同于<code>[^A-Za-z0-9_]</code></p>
<p><code>\d</code>：匹配数字字符，等同于元字符 <code>[0-9]</code></p>
<p><code>\D</code>：匹配非数字字符，等同于元字符 <code>[^0-9]</code></p>
<p><code>\s</code>：匹配空格、回车符、制表符、换页符和换行符，等同于元字符 <code>[ \r\t\f\n\v]</code></p>
<p><code>\S</code>：匹配非空白字符，等同于元字符 <code> [^ \r\t\f\n\v]</code></p>
<p><code>.</code> ： 匹配任何一个字符</p>
<p><a href="">{}</a>：数量说明符 </p>
<ol>
<li>指定匹配模式的上下限<code>/a&#123;3,5&#125;/</code></li>
<li>只指定匹配的下限<code>/a&#123;3,&#125;/</code></li>
<li>指定匹配的确切数量<code>/a&#123;3&#125;/</code></li>
</ol>
<p><strong>正向先行断言</strong>：正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 <code>(?=...)</code>，其中 <code>...</code> 就是需要存在但不会被匹配的部分</p>
<p><strong>负向先行断言</strong>：负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 <code>(?!...)</code>，其中 <code>...</code> 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在正则表达式 pwRegex 中使用先行断言以匹配大于 5 个字符且有两个连续数字的密码</span></span><br><span class="line"><span class="keyword">let</span> sampleWord = <span class="string">&quot;astronaut&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pwRegex = <span class="regexp">/(?=\w&#123;6&#125;)(?=\w*\d&#123;2&#125;)/</span>; </span><br><span class="line">pwRegex.<span class="title function_">test</span>(sampleWord); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure></div>



<p><strong>捕获组重用模式</strong>: 捕获组是通过把要捕获的正则表达式放在括号中来构建的。 </p>
<p>在下面这个例子里， 目标是捕获一个包含数字字符的词，所以捕获组是将 <code>\d+</code> 放在括号中：<code>/(\d+)/</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在reRegex中使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串。</span></span><br><span class="line"><span class="keyword">let</span> repeatNum = <span class="string">&quot;42 42 42&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reRegex = <span class="regexp">/^(\d+)\s\1\s\1$/</span>;</span><br><span class="line">repeatNum.<span class="title function_">match</span>(reRegex) <span class="comment">// =&gt; [ &#x27;42 42 42&#x27;,&#x27;42&#x27;]</span></span><br></pre></td></tr></table></figure></div>



<p><strong>使用捕获组搜索和替换</strong>：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用三个捕获组编写一个正则表达式 `fixRegex`，这三个捕获组将搜索字符串 `one two three` 中的每个单词。 然后更新 `replaceText` 变量，以字符串 `three two one` 替换 `one two three`，并将结果分配给 `result` 变量。 确保使用美元符号（`$`）语法在替换字符串中使用捕获组。</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;one two three&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> fixRegex = <span class="regexp">/([a-z]&#123;3,&#125;)\s([a-z]&#123;3,&#125;)\s([a-z]&#123;3,&#125;)/</span>; <span class="comment">// 用于匹配的字符串或正则表达式</span></span><br><span class="line"><span class="keyword">let</span> replaceText = <span class="string">&#x27;$3 $2 $1&#x27;</span>; <span class="comment">// 用于替换匹配的字符串</span></span><br><span class="line">str.<span class="title function_">replace</span>(fixRegex, replaceText); <span class="comment">// =&gt; three two one</span></span><br></pre></td></tr></table></figure></div>





<h2 id="JavaScript的对象"><a href="#JavaScript的对象" class="headerlink" title="JavaScript的对象"></a>JavaScript的对象</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\90856\Documents\Typora笔记\images\JS原型链详细图解.png"
                      alt="JS原型链详细图解"
                ></p>
<p><strong><code>constructor</code>:</strong> </p>
<blockquote>
<p>该属性是对创建这个实例(f)的<code>构造函数</code>(F)的一个引用</p>
</blockquote>
<p><strong><code>__proto__</code>:</strong> </p>
<blockquote>
<p>该属性是对实例对象(f)所在原型链上的<code>原型对象</code>(F.prototype)的引用,即：f._ <em>proto</em> _ 与 F.prototype 指向同一个原型对象</p>
<p><strong>tip</strong>: </p>
<ul>
<li><p>实例对象与其原型对象处于同一原型链，所以对象可以向上查找使用该原型对象的属性和方法，即：可以沿着<code>__proto__</code>逐层查找</p>
</li>
<li><p>自定义构造函数(F)在JS中也是一种特殊的对象,所以F的<code>__proto__</code>指向构造函数(Function)的原型对象，即<code>Foo.__proto__ === Function.__proto__ === Function.prototype</code></p>
</li>
</ul>
</blockquote>
<p><strong><code>instanceof</code>：</strong></p>
<blockquote>
<p>用于检测构造函数(F)的 <code>prototype</code> 属性是否出现在某个实例对象(f)的原型链上。 </p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">f <span class="keyword">instanceof</span> F <span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure></div>







<h2 id="编程方式"><a href="#编程方式" class="headerlink" title="编程方式"></a>编程方式</h2><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3>]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>关于apply,call,bind理解</title>
    <url>/2020/02/28/Javascript/%E5%85%B3%E4%BA%8Eapply,call,bind%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>首先明确一个基本概念：函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 定义一个A对象</span></span><br><span class="line"><span class="keyword">let</span> A = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    <span class="title function_">say</span>(<span class="params">e1,e2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e1 + <span class="string">&#x27; and &#x27;</span> + e2   + <span class="string">&#x27; is &#x27;</span>+ <span class="variable language_">this</span>.<span class="property">color</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个B对象</span></span><br><span class="line"><span class="keyword">let</span> B = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;black&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B对象需要用到A对象的方法或属性</span></span><br><span class="line">A.<span class="property">say</span>.<span class="title function_">call</span>(B,<span class="string">&#x27;hair&#x27;</span>,<span class="string">&#x27;eyes&#x27;</span>)  <span class="comment">// =&gt;hair and eyes is black</span></span><br><span class="line">A.<span class="property">say</span>.<span class="title function_">apply</span>(B,[<span class="string">&#x27;hair&#x27;</span>,<span class="string">&#x27;eyes&#x27;</span>])  <span class="comment">// =&gt;hair and eyes is black</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>以上例子说明了：</p>
<ul>
<li><p>call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，即：改变运行时候函数的<code>this</code>指向</p>
</li>
<li><p>对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样：apply和call接收的第一个参数是都是<code>this</code>本身，而第二个参数<code>apply</code>接收的是一个数组参数<code>[1,2,3]</code>，<code>call</code>接收的是列表参数（1,2,3），即：参数个数不确定时使用<code>apply</code>，参数个数确定时使用<code>call</code></p>
</li>
</ul>
<h2 id="常用用法："><a href="#常用用法：" class="headerlink" title="常用用法："></a>常用用法：</h2><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子1：数组之间的追加</span></span><br><span class="line"><span class="keyword">let</span> A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> B = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="title class_">Array</span>.<span class="property">prototypr</span>.<span class="property">push</span>.<span class="title function_">apply</span>(A,B)   <span class="comment">// [1,2,3,4,5,6]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property">prototypr</span>.<span class="property">push</span>.<span class="title function_">call</span>(A,B)    <span class="comment">// [1,2,3,[4,5,6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2：获取数组中的最大值和最小值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>,arr)</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子3：验证是否是数组（前提是toString()方法没有被重写过）</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">isArray</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(obj) === <span class="string">&#x27;[object Array]&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 例子4：类（伪）数组使用数组</span></span><br><span class="line"><span class="keyword">let</span> tagName= <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> domNodes = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(tagName);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>小结：</p>
<ul>
<li>apply、call、bind都是用来改变函数的this对象的指向</li>
<li>apply、call、bind第一个参数都是this要指向的对象</li>
<li>apply、call、bind都可以利用后续参数传参</li>
<li>bind返回的是对应函数；apply、call则是立即调用</li>
</ul>
<p>补充：</p>
<p>在函数内部，<code>arguments</code>是一个<code>类数组对象</code>，用于保存函数参数，其内部存在的2个属性：<code>callee</code>，<code>caller</code></p>
<ul>
<li><p><code>callee:</code>是一个指针，指向拥有这个<code>arguments</code>对象的函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cool</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">cool</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果打印出来（chrome下）：</span></span><br><span class="line">ƒ <span class="title function_">cool</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>);</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">10</span>);    <span class="comment">//3628800</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>caller</code>：保留着调用<code>当前函数</code>的<code>函数</code>的引用 (全局作用域下调用该函数，caller为null)</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">addChild</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addChild</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(addChild.<span class="property">caller</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在chrome下打印结果：</span></span><br><span class="line">ƒ <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">addChild</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript原型链</title>
    <url>/2020/02/28/Javascript/Javascript%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<p>直接上图！额(⊙o⊙)…，有点乱！不着急，让我们一步步来理解</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i.loli.net/2019/05/16/5cdd315c45bc895052.png"
                      alt="img"
                ></p>
<p>首先先来明确这三个属性的定义:</p>
<ul>
<li><code>prototype</code>：指向<code>原型对象</code>（函数特有属性）</li>
<li><code>__proto__</code>：指向构造该对象的构造函数的<code>原型对象</code></li>
<li><code>constructor</code>：指回该原型对象中的构造函数</li>
</ul>
<p>步骤分析：</p>
<ol>
<li>f1,f2是构造函数Foo()实例化出来的对象，<code>f1.__proto__</code>指向其构造函数的原型对象，和其构造函数<code>Foo.prototype </code>指向的是同一个原型对象，同时原型对象可以通过<code>constructor</code>指回构造函数（其他构造函数同理）</li>
<li>Foo函数原型对象使用<code>Foo.prototype.__proto__ </code>指向了对象类型的原型对象Object.prototype ：因为Foo原型对象本身也是一个对象，所以使用<code>__proto__</code>指向了对象构造函数<code>Object()</code>的原型对象<code>Object.prototype</code></li>
<li>Object函数原型对象<code>Object.prototype</code>是初始化的原型对象了，所以该对象的构造函数的原型对象为空null<code>Object.prototype.__proto__ == null</code>，也就是找不到创造它的对象了</li>
<li>Object构造函数和其他构造函数的区别就是它的原型对象就是兜底的<code>Object.prototype</code></li>
<li><code>Foo.__proto__</code>、<code>Object.__proto__</code>、<code>Function.__proto__</code>这些构造函数的构造函数都是<code>Function()</code>,所以它们的构造函数原型对象都是<code>Function.prototype</code></li>
<li>Function构造函数的原型对象<code>Function.prototype</code>是通过Object构造函数创建的，所以其原型对象为<code>Object.prototype</code></li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>__proto__</code>属性指向构造该对象的构造函数的原型对象：<ul>
<li>函数的<code>__proto__</code>都指向Object原型对象</li>
<li>对象的<code>__proto__</code>都指向其构造函数的原型对象</li>
</ul>
</li>
<li><code>prototype</code>属性指向<code>原型对象</code>：<ul>
<li>只有函数才有<code>prototype</code>属性</li>
<li><code>原型对象</code>存在<code>constructor</code>的构造函数，该属性指回其构造函数</li>
</ul>
</li>
<li>函数同时也是一个对象：即：<code>f.prototype.__proto__  == f.__proto__.__proto__</code>也就是图中的1+2 &#x3D;&#x3D; 5+ 6，最终都是指向Object原型对象</li>
<li><code>prototype</code>、<code>__proto__</code>两个最终都是指向同一个原型对象</li>
<li>Object原型对象的<code>__proto__</code>的属性值为null</li>
<li>任何函数最终的构造函数都是指向<code>函数构造函数Function</code>，任何对象最终的构造对象原型都是<code>对象原型对象Object.protutype</code></li>
</ul>
<blockquote>
<p>嘿嘿~当时，只有我和上帝两个人知道写的是什么，而现在只有上帝一个人知道了！</p>
</blockquote>
<p>参考链接：<a class="link"   href="http://www.cnblogs.com/smoothLily/p/4745856.html" >http://www.cnblogs.com/smoothLily/p/4745856.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的继承</title>
    <url>/2023/03/12/Javascript/%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<blockquote>
<p>在Javascript中实现继承主要是依靠原型链来实现的;其基本思想是通过原型实现一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<h4 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">super</span> = <span class="string">&#x27;SuperType&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">super</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="string">&#x27;SubType&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br></pre></td></tr></table></figure></div>

<p>优点： 写法方便简洁，容易理解</p>
<p>缺点：对象实例共享所有继承的属性和方法；无法向父类构造函数传参</p>
<h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h4><blockquote>
<p>子类型构造函数的内部调用父类型构造函数</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;     </span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;       </span><br><span class="line">    <span class="comment">//继承了 SuperType     </span></span><br><span class="line">    <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">c1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);  <span class="comment">// red,blue,green,black</span></span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); <span class="comment">// red,blue,green</span></span><br></pre></td></tr></table></figure></div>

<p>优点：解决了原型链继承不能传承和父类原型共享的问题</p>
<p>缺点：借用构造函数的方法都是在构造函数中定义的，因此无法实现函数复用；在父类的原型中定义的方法，对于子类型而言也是不可见的，所有的类型都只能使用构造函数模式</p>
<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h4><blockquote>
<p>将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是<strong>使用原型链实现对原型属性和方法的继承</strong>，而通过<strong>借用构造函数来实现对实例属性的继承</strong>。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。所以组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">// 原型链继承原型上的属性和方法</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name</span>)&#123;        </span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);  <span class="comment">//  借用构造函数来传递参数          </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(p1.<span class="property">colors</span>);      <span class="comment">//&quot;red,blue,green,black&quot; </span></span><br><span class="line">p1.<span class="title function_">sayName</span>();          <span class="comment">//&quot;Nicholas&quot;; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>); </span><br><span class="line"><span class="title function_">alert</span>(p2.<span class="property">colors</span>);      <span class="comment">//&quot;red,blue,green&quot; </span></span><br><span class="line">p2.<span class="title function_">sayName</span>();          <span class="comment">//&quot;Greg&quot;; </span></span><br></pre></td></tr></table></figure></div>

<p>优点：解决了原型链继承和借用构造函数继承的问题</p>
<p>缺点：无论在什么情况下，都会调用两次父类构造函数（一次在创建子类型的时候，另一次在子类构造函数内）</p>
<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h4><blockquote>
<p>将需要被继承的对象挂载到函数内部新创建的构造函数原型上并返回该构造函数的实例</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 模拟Object.create()方法</span></span><br><span class="line"><span class="comment">*  o: 需要被继承的对象</span></span><br><span class="line"><span class="comment">*  o2: 自定义参数对象,默认为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o,o2=&#123;&#125;</span>)&#123;</span><br><span class="line">   <span class="comment">// 创建一个构造函数F为接收自定义参数</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> o2) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key2 <span class="keyword">in</span> o2[key]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[key] = o2[key][key2]<span class="comment">//跳坑指南: 不能使用this.key,因为点赋值会将变量key转为字符串“key” </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o   <span class="comment">// 重写构造函数F原型对象为传入的对象o</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()  <span class="comment">//返回构造函数的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;no-Name&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="title function_">object</span>(person)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在传入一个参数的情况下，Object.create()与 object()方法的行为相同</span></span><br><span class="line"> <span class="keyword">var</span> person = &#123;     </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,     </span><br><span class="line">   <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line"> &#125;;  </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);      </span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>; </span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);  </span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure></div>



<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h4><blockquote>
<p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路 ,其与工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title function_">object</span>(original)  <span class="comment">//创建对象</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;			</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;     </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jiangwen&quot;</span>,     </span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>] </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person); </span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure></div>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h4 id="6-寄生组式继承"><a href="#6-寄生组式继承" class="headerlink" title="6.寄生组式继承"></a>6.寄生组式继承</h4><blockquote>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 ; 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;     </span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);     <span class="comment">//创建对象     </span></span><br><span class="line">	prototype.<span class="property">constructor</span> = subType;               <span class="comment">//增强对象     </span></span><br><span class="line">  	subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;                 <span class="comment">//指定对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="7-ES6的Class类继承"><a href="#7-ES6的Class类继承" class="headerlink" title="7. ES6的Class类继承"></a>7. ES6的Class类继承</h4><blockquote>
<p>class通过extends关键字实现继承</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类（动物类）</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span> (<span class="params">kind</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">kind</span> = kind</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">getKind</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;我是一只&#x27;</span> + <span class="variable language_">this</span>.<span class="property">kind</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 子类（猫类）</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">     <span class="variable language_">super</span>(<span class="string">&#x27;猫&#x27;</span>)  <span class="comment">// 子类的构造函数中必须先调用super方法</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">getCatInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;:&#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">getKind</span>() + <span class="string">&#x27;...喵喵喵...&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对象实例</span></span><br><span class="line"> <span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;没头脑&#x27;</span>)</span><br><span class="line"> c.<span class="title function_">getCatInfo</span>()</span><br></pre></td></tr></table></figure></div>

<p>优点：语法简单易懂，操作简便</p>
<p>缺点：浏览器没有全面兼容class关键字</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则</title>
    <url>/2023/03/12/Javascript/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配邮箱</span></span><br><span class="line"><span class="keyword">let</span> reg = /^([a-zA-Z]|[<span class="number">0</span>-<span class="number">9</span>])(\w|\-)+@[a-zA-<span class="variable constant_">Z0</span>-<span class="number">9</span>]+\.([a-zA-Z]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;)$</span><br><span class="line"></span><br><span class="line"><span class="comment">// (新)匹配手机号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^1[0-9]&#123;10&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (旧)匹配手机号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^1(3|4|5|7|8)[0-9]&#123;9&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配8-16位数字和字母密码的正则表达式</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;8,16&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配国内电话号码 0510-4305211</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配身份证号码</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配腾讯QQ号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[1-9][0-9]&#123;4,&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配ip地址</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+\.\d+\.\d+\.\d+/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配中文</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[\u4e00-\u9fa5]*$/</span>;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化开发</title>
    <url>/2020/02/28/Javascript/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>ES6之前，Javascript并没有模块体系。但在实际开发中，我们需要模块化编程的开发提高效率和维护性，于是产生了几类模块化的标准</p>
</blockquote>
<p>模块的概念：模块就是实现特定功能的一组方法</p>
<h2 id="原始写法"><a href="#原始写法" class="headerlink" title="原始写法"></a>原始写法</h2><hr>
<h3 id="函数写法："><a href="#函数写法：" class="headerlink" title="函数写法："></a><strong>函数写法：</strong></h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<ul>
<li>使用：直接调用方法就行了。</li>
<li>缺点：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</li>
</ul>
<hr>
<h3 id="对象写法："><a href="#对象写法：" class="headerlink" title="对象写法："></a>对象写法：</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">_count : <span class="number">0</span>,</span><br><span class="line"> m1 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;,</span><br><span class="line">m2 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>对象写法 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p>
<ul>
<li>使用：调用这个对象的属性</li>
<li>缺点：暴露所有模块成员，内部状态可以被外部改写</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">_count</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="立即执行函数写法："><a href="#立即执行函数写法：" class="headerlink" title="立即执行函数写法："></a>立即执行函数写法：</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(_count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(_count + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;m1,m2&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>
<p>使用”立即执行函数(IIFE)”，利用函数作用域中的外部函数无法访问内部函数规则，从而私有化内部属性，并函数结果以对象形式返回给module</p>
<ul>
<li>使用：调用返回对象中的方法属性</li>
</ul>
<hr>
<h2 id="主流模块规范"><a href="#主流模块规范" class="headerlink" title="主流模块规范"></a>主流模块规范</h2><p>​		ES6标准之前，JavaScript并没有模块体系，浏览器端通过<code>&lt;script&gt;</code>引入的代码被当作脚本执行。社区中则制定了一些标准：如<a class="link"   href="https://juejin.im/post/5ab28582518825611a40603e" >CommonJS、AMD、CMD<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，CommonJS同步加载主要用于服务端，AMD、CMD异步加载则用于浏览器端。</p>
<h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>​		<code>NodeJS是CommonJS规范的主要实践者，CommonJS</code>用同步的方式加载模块。在<code>Server</code>上模块文件都在本地磁盘，所以读取非常快没什么不妥，但是在<code>Browser</code>由于网络的原因，更合理的方案是异步加载。</p>
<h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>​		<code>AMD(Asynchronous Module Definition)</code>异步模块定义。<code>AMD</code>其实是<code>RequireJS</code>在推广的过程中对模块定义的范围化的产出，它是一个在浏览器端模块化开发的规范。 它不是<code>javascript</code>原生支持，所以使用AMD规范进行页面开发需要用到对应的库，也就是<code>RequireJS</code>。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义模块define(id?, dependencies?, factory)</span></span><br><span class="line"><span class="comment">//- id：模块名</span></span><br><span class="line"><span class="comment">//- dependencies：当前模块依赖的模块</span></span><br><span class="line"><span class="comment">//- factory：工厂方法，一般直接返回一个对象</span></span><br><span class="line"><span class="title function_">define</span>(<span class="string">&#x27;math&#x27;</span>,[<span class="string">&#x27;jquery&#x27;</span>], <span class="keyword">function</span> (<span class="params">$</span>) &#123;<span class="comment">//引入jQuery模块</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取模块require([modlue], callback)</span></span><br><span class="line"><span class="comment">//别名配置</span></span><br><span class="line">requirejs.<span class="title function_">config</span>(&#123;</span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">        <span class="attr">jquery</span>: <span class="string">&#x27;jquery.min&#x27;</span> <span class="comment">//可以省略.js</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//引入模块，用变量$表示jquery模块</span></span><br><span class="line"><span class="title function_">requirejs</span>([<span class="string">&#x27;jquery&#x27;</span>], <span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;background-color&#x27;</span>,<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><code>CMD（Common Module Definition）</code> 通用模块定义。 <code>CMD</code>是在<code>sea.js</code>推广的过程中产生的。在<code>CMD</code>规范中，一个模块就是一个文件。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, exprots, <span class="variable language_">module</span></span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);  <span class="comment">//接受模块标识作为唯一参数 	</span></span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">module</span> = &#123; 		<span class="comment">// exports，module则和CommonJS类似 	</span></span><br><span class="line">        <span class="attr">props</span>: <span class="string">&#x27;value&#x27;</span> 	</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.<span class="title function_">use</span>([<span class="string">&#x27;test.js&#x27;</span>], <span class="keyword">function</span>(<span class="params">test_exports</span>) &#123; </span><br><span class="line">    <span class="comment">// .... </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>



<h3 id="CMD和AMD的异同"><a href="#CMD和AMD的异同" class="headerlink" title="CMD和AMD的异同"></a>CMD和AMD的异同</h3><table>
<thead>
<tr>
<th align="left">\</th>
<th>AMD</th>
<th>CMD</th>
</tr>
</thead>
<tbody><tr>
<td align="left">对依赖模块的执行时机处理不同</td>
<td>推崇依赖前置，在定义的时候就要声明其依赖的模块</td>
<td>推崇就近依赖，只有在用到这个module的时候才去require</td>
</tr>
<tr>
<td align="left">加载方式</td>
<td>async异步加载</td>
<td>async异步加载</td>
</tr>
<tr>
<td align="left">适用环境</td>
<td>browser</td>
<td>browser</td>
</tr>
<tr>
<td align="left">执行module的方式</td>
<td>加载module完成后就会执行该module</td>
<td>加载完某个依赖后并不执行，只是下载而已。</td>
</tr>
</tbody></table>
<hr>
<h2 id="★ES6模块（服务器-amp-浏览器端通用方案）"><a href="#★ES6模块（服务器-amp-浏览器端通用方案）" class="headerlink" title="★ES6模块（服务器&amp;浏览器端通用方案）"></a>★ES6模块（服务器&amp;浏览器端通用方案）</h2><table>
<thead>
<tr>
<th>\</th>
<th><strong>CommonJS</strong></th>
<th><strong>ES6</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加载</strong></td>
<td>运行时加载</td>
<td>编译时输出接口</td>
</tr>
<tr>
<td><strong>导入次数</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>模块输出</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="引用参考："><a href="#引用参考：" class="headerlink" title="引用参考："></a>引用参考：</h2><ol>
<li><a class="link"   href="http://es6.ruanyifeng.com/#docs/module" >ES6标准入门——阮一峰<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> m1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> m2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(_count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    m1,m2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div>

<p>使用上面的写法，外部代码无法读取内部的_count变量,module就是Javascript模块的基本写法。</p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖&amp;节流函数</title>
    <url>/2020/09/18/Javascript/%E9%98%B2%E6%8A%96&amp;%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><blockquote>
<p>理解为电梯开门，有人进入重置一次关门时间，直到最后没人进入时，才执行关门<br>即: 在一段时间内只执行最后一次动作，重置清除之前执行的动作</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* func:需要执行防抖的函数</span></span><br><span class="line"><span class="comment">* delay: 时间间隔</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><blockquote>
<p>理解为蓝鲸呼吸，每间隔半小时浮出水面呼吸一次<br>即：在一定时间段内执行一次，忽略中间执行的动作</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* func:需要执行防抖的函数</span></span><br><span class="line"><span class="comment">* delay: 时间间隔</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thorttle</span>(<span class="params">func, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    nowTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      preTime = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定时器方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thorttle2</span>(<span class="params">func, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ol>
<li>要通过返回函数形成闭包，通过作用域链，实现返回的每个函数都可以保持timer时间标记变量的同一引用 </li>
<li>通过使用apply函数，使this保持对调用对象的正确指向</li>
</ol>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的程序设计</title>
    <url>/2020/02/28/Javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象?"></a>什么是对象?</h2><p>无序属性的集合， 其属性可以包含基本值、 对象或者函数（没对象的小盆友赶紧开始搞对象！）</p>
<h3 id="对象的属性类型"><a href="#对象的属性类型" class="headerlink" title="对象的属性类型"></a>对象的属性类型</h3><blockquote>
<p>ECMA-262定义了一些为实现JavaScript引擎用的属性，因此不能直接访问，为了表示其是特殊的内部值，把他们放在两对儿方括号中。例如[[[Enumerable]]。对象的属性分为数据属性和访问器属性</p>
</blockquote>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>一般数据属性的值都为基础数据类型。</p>
<ul>
<li>[[Configurable]] 表示能否通过delete删除属性从而从新定义…（默认为true PS:一旦修改，不能反悔）</li>
<li>[[Enumerable]] 表示能否通过for-in循环返回属性…（自定义属性默认为true,默认属性的默认值为false,例如:constructor ）</li>
<li>[[Writable]] 表示能否修改属性值…(默认为true）)</li>
<li>[[Value]] 包含属性的数据值…（就是上例中的‘Jiangwen’)</li>
</ul>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><ul>
<li><p>[[Configurable]] 表示能否通过delete删除属性从而从新定义…默认为true）</p>
</li>
<li><p>[[Enumerable]] 表示能否通过for-in循环返回属性…（默认为true）</p>
</li>
<li><p>[[get]]: 在读取属性时，调用的函数，默认undefined。</p>
</li>
<li><p>[[set]]: 在写入属性时，调用的函数，默认undefeated。</p>
</li>
</ul>
<h3 id="修改默认属性"><a href="#修改默认属性" class="headerlink" title="修改默认属性"></a>修改默认属性</h3><blockquote>
<p>ECMAScript给我提供了一个方法，Object.defineProperty()方法。这个方法接受三个参数：属性所在对象、属性的名字和一个描述对象。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person,<span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">    <span class="title class_">Writable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>:<span class="string">&#x27;jiangwen&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">//&#x27;jiangwen&#x27;</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;xiaoming&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// &#x27;jiangwen&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>修改默认属性为不允许修改，因此重新进行赋值修改无效</p>
<h3 id="定义多个对象属性"><a href="#定义多个对象属性" class="headerlink" title="定义多个对象属性"></a>定义多个对象属性</h3><blockquote>
<p>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 Object.definePro- perties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> people = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book,&#123; <span class="comment">//定义多个对象属性，用到Object.defineProperties();</span></span><br><span class="line">    <span class="attr">_year</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">name</span>:&#123;</span><br><span class="line">        <span class="attr">value</span>:<span class="string">&#x27;jiangwen&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>



<h3 id="获取描述属性"><a href="#获取描述属性" class="headerlink" title="获取描述属性"></a>获取描述属性</h3><blockquote>
<p>ECMAScript也给我们提供了一个方法：<code>Object.getOwnPropertyDescriptor()</code>这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称;返回值是一个对象</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;  </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;     </span><br><span class="line">  <span class="attr">_year</span>: &#123;          <span class="attr">value</span>: <span class="number">2004</span>     &#125;,      </span><br><span class="line">  <span class="attr">edition</span>: &#123;         <span class="attr">value</span>: <span class="number">1</span>     &#125;,      </span><br><span class="line">  <span class="attr">year</span>: &#123;         </span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;             </span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_year</span>;         </span><br><span class="line">	&#125;,          </span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123;             </span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;                 </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_year</span> = newValue;                 </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2004</span>;             </span><br><span class="line">      &#125;        </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book,<span class="string">&quot;_year&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">value</span>) <span class="comment">// 18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor.<span class="property">enumerable</span>);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>



<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h4 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="1.基本方法"></a>1.基本方法</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;JiangWen&quot;</span>; </span><br><span class="line">person.<span class="property">age</span> = <span class="number">29</span>; </span><br><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;  </span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  	<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-对象字面量方法"><a href="#2-对象字面量方法" class="headerlink" title="2.对象字面量方法"></a>2.对象字面量方法</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;     </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;JiangWen&quot;</span>,      </span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,     </span><br><span class="line">  <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,      </span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>虽然上面两种创建对象的方式，都可以用来创建单个对象，但是有个明显的缺点，使用同一接口创建很多对象，会产生大量的重复代码,因此就产生了不同模式满足不同情况下的需求</p>
</blockquote>
<h4 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3.工厂模式"></a>3.工厂模式</h4><blockquote>
<p>工厂模式是软件工程领域一种广为人知的设计模式,用函数来封装以特定接口创建对象的细节</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;     </span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();     </span><br><span class="line">  o.<span class="property">name</span> = name;     </span><br><span class="line">  o.<span class="property">age</span> = age;     </span><br><span class="line">  o.<span class="property">job</span> = job;     </span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);     </span><br><span class="line">  &#125;;         </span><br><span class="line">  <span class="keyword">return</span> o; &#125;  </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Jiangwen&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="4-构造函数模式"><a href="#4-构造函数模式" class="headerlink" title="4.构造函数模式"></a>4.构造函数模式</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">		<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);     </span><br><span class="line">  &#125;;     </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jiangwen&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>调用构造函数实际上会经历以下 4 个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋值给新对象（因此 this 就指向了这个新对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性方法）</li>
<li>返回新对象    (注:默认返回新创建的对象; 不过如果在构造函数中显式返回一个对象数据类型,那么将来new的对象就是该显式return的对象)</li>
</ol>
<blockquote>
<p>构造函数模式和工厂模式有以下几个不同之处</p>
</blockquote>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性方法赋值给this</li>
<li>没有return语句</li>
</ul>
<h4 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h4><blockquote>
<p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123; &#125;  </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Jiangwen&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">25</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;     </span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>); </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(); </span><br><span class="line">person1.<span class="title function_">sayName</span>();   <span class="comment">//&quot;Jiangwen&quot;  </span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>();   <span class="comment">//&quot;Jiangwen&quot;  </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<p>与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。也就是说，person1 和 person2 访问的都是同一组属性和同一个 sayName()函数,如下图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://mmbiz.qpic.cn/mmbiz/UibcI88f9TwKMoliaj4QxOJb2DQLgueSVTNVvpdLKhfyMm2y3SoZqIaygQssqndrTBdibSd7aJjddGf1micBxhTGSA/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1"
                      alt="img"
                ></p>
<p>一些关于原型的方法:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定实例对象和构造函数原型之间是否存在关系</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person1) <span class="comment">// true</span></span><br><span class="line">person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>)       <span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例的原型对象</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1).<span class="property">name</span>; <span class="comment">//&quot;Jiangwen&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测一个属性是存在于实例中，还是存在于原型中</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Owen&quot;</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)  <span class="comment">// false 来自原型 </span></span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&#x27;jiangwen&#x27;</span></span><br><span class="line">person1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)  <span class="comment">// true 来自实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测一个属性是存在于实例或者原型中,即该属性存在即可</span></span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得当前对象上所有可枚举的实例属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// &quot;name,age,job,sayName&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得当前对象上所有实例属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//&quot;constructor,name,age,job,sayName&quot;</span></span><br></pre></td></tr></table></figure></div>



<h4 id="6-组合构造函数模式和原型模式"><a href="#6-组合构造函数模式和原型模式" class="headerlink" title="6.组合构造函数模式和原型模式"></a>6.组合构造函数模式和原型模式</h4><blockquote>
<p>该模式是创建自定义类型的最常见方式: 构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>]; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;     </span><br><span class="line">  constructor : <span class="title class_">Person</span>,     <span class="comment">// 对象字面量的形式相当于重写了原型对象,所以需要重新指定</span></span><br><span class="line">  sayName : <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);  </span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span>);    <span class="comment">//&quot;Shelby,Count,Van&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">friends</span>);    <span class="comment">//&quot;Shelby,Count&quot; </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>);    <span class="comment">//false </span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>



<h4 id="7-动态原型模式"><a href="#7-动态原型模式" class="headerlink" title="7.动态原型模式"></a>7.动态原型模式</h4><blockquote>
<p>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型,从而避免改写原型上原有的同名属性或方法</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="comment">//属性     </span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法     </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>)&#123;              </span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;             </span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);         </span><br><span class="line">    &#125;;              </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该模式下只在 sayName()方法不存在于原型的情况下，才会将它添加到原型中</p>
<h4 id="8-寄生构造函数模式-不建议使用"><a href="#8-寄生构造函数模式-不建议使用" class="headerlink" title="8.寄生构造函数模式(不建议使用)"></a>8.寄生构造函数模式(不建议使用)</h4><blockquote>
<p>该模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;     </span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();     </span><br><span class="line">  o.<span class="property">name</span> = name;    </span><br><span class="line">  o.<span class="property">age</span> = age;     </span><br><span class="line">  o.<span class="property">job</span> = job;     </span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);     </span><br><span class="line">  &#125;;         </span><br><span class="line">  <span class="keyword">return</span> o; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>); </span><br><span class="line">friend.<span class="title function_">sayName</span>();  <span class="comment">//&quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。</p>
<h4 id="9-稳妥构造函数模式"><a href="#9-稳妥构造函数模式" class="headerlink" title="9.稳妥构造函数模式"></a>9.稳妥构造函数模式</h4><blockquote>
<p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;          </span><br><span class="line">  <span class="comment">//创建要返回的对象     </span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//可以在这里定义私有变量和函数      </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//添加方法     </span></span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;         </span><br><span class="line">    <span class="title function_">alert</span>(name);     </span><br><span class="line">  &#125;;              </span><br><span class="line">  <span class="comment">//返回对象     </span></span><br><span class="line">  <span class="keyword">return</span> o; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意， 在以这种模式创建的对象中， 除了使用 sayName()方法之外， 没有其他办法访问 name 的值</p>
<h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><blockquote>
<p>在Javascript中实现继承主要是依靠原型链来实现的;其基本思想是通过原型实现一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<h4 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1.原型链"></a>1.原型链</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">super</span> = <span class="string">&#x27;SuperType&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayType</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">super</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="string">&#x27;SubType&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>()</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">SubType</span>()</span><br></pre></td></tr></table></figure></div>



<h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2.借用构造函数"></a>2.借用构造函数</h4><blockquote>
<p>子类型构造函数的内部调用超类型构造函数</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123;     </span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123;       </span><br><span class="line"><span class="comment">//继承了 SuperType     </span></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>);    <span class="comment">//&quot;red,blue,green,black&quot;  </span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>);    <span class="comment">//&quot;red,blue,green&quot;</span></span><br></pre></td></tr></table></figure></div>



<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h4><blockquote>
<p>将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;     </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;     </span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;        </span><br><span class="line">  <span class="comment">//继承属性     </span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);          </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//继承方法 </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>; </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;     </span><br><span class="line">  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>); </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>);      <span class="comment">//&quot;red,blue,green,black&quot; </span></span><br><span class="line">instance1.<span class="title function_">sayName</span>();          <span class="comment">//&quot;Nicholas&quot;; </span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>();      			<span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>); </span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>);      <span class="comment">//&quot;red,blue,green&quot; </span></span><br><span class="line">instance2.<span class="title function_">sayName</span>();          <span class="comment">//&quot;Greg&quot;; </span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>();           <span class="comment">//27</span></span><br></pre></td></tr></table></figure></div>

<p>所以组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。</p>
<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h4><blockquote>
<p>将需要被继承的对象挂载到函数内部新创建的构造函数原型上并返回该构造函数的实例</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 模拟Object.create()方法</span></span><br><span class="line"><span class="comment">*  o: 需要被继承的对象</span></span><br><span class="line"><span class="comment">*  o2: 自定义参数对象,默认为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o,o2=&#123;&#125;</span>)&#123;</span><br><span class="line">   <span class="comment">// 创建一个构造函数F为接收自定义参数</span></span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> o2) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key2 <span class="keyword">in</span> o2[key]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[key] = o2[key][key2]<span class="comment">//跳坑指南: 不能使用this.key,因为点赋值会将变量key转为字符串“key” </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o   <span class="comment">// 重写构造函数F原型对象为传入的对象o</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()  <span class="comment">//返回构造函数的实例</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;no-Name&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="title function_">object</span>(person)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>ECMAScript 5 通过新增 Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在传入一个参数的情况下，Object.create()与 object()方法的行为相同</span></span><br><span class="line"> <span class="keyword">var</span> person = &#123;     </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,     </span><br><span class="line">   <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line"> &#125;;  </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);      </span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person); </span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>; </span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);  </span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure></div>



<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h4><blockquote>
<p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路 ,其与工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="title function_">object</span>(original)  <span class="comment">//创建对象</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;			</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;hi!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;     </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jiangwen&quot;</span>,     </span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>] </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person); </span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h4 id="6-寄生组式继承"><a href="#6-寄生组式继承" class="headerlink" title="6.寄生组式继承"></a>6.寄生组式继承</h4><blockquote>
<p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法 ; 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。</p>
</blockquote>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>)&#123;     </span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);     <span class="comment">//创建对象     </span></span><br><span class="line">	prototype.<span class="property">constructor</span> = subType;                 <span class="comment">//增强对象     </span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;               <span class="comment">//指定对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2快速上手</title>
    <url>/2020/02/28/NodeJs/Koa2%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h4 id="检查Node版本"><a href="#检查Node版本" class="headerlink" title="检查Node版本"></a>检查Node版本</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">node -v  // =&gt; 大于v7.6</span><br></pre></td></tr></table></figure></div>

<h4 id="安装Koa"><a href="#安装Koa" class="headerlink" title="安装Koa"></a>安装Koa</h4><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm init </span><br><span class="line">npm install koa</span><br></pre></td></tr></table></figure></div>

<h4 id="创建编写app-js文件"><a href="#创建编写app-js文件" class="headerlink" title="创建编写app.js文件"></a>创建编写app.js文件</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建koa对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>()</span><br><span class="line"><span class="comment">// 2. 编写响应函数（中间件 ）</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 绑定端口号</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure></div>

<h5 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></div>



<h2 id="Koa项目"><a href="#Koa项目" class="headerlink" title="Koa项目"></a>Koa项目</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Koa                                 源码</span><br><span class="line">├── node_modules                     - npm依赖包</span><br><span class="line">├── data                             - json模拟数据</span><br><span class="line">├── middleware                       - 中间件</span><br><span class="line">│   |── koa_response_data.js            - 业务逻辑中间件</span><br><span class="line">│   |── koa_response_duration.js        - 计算耗时中间件</span><br><span class="line">│   └── koa_response_header.js          - 响应头中间件</span><br><span class="line">├── utils                           - 工具模块</span><br><span class="line">│   └── fils_utils.js               	- 读取文件工具方法</span><br><span class="line">└── app.js                          - 入口文件</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>diff算法原理解析</title>
    <url>/2022/11/22/Vue/diff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>前言: <strong>diff算法</strong>可以看作是一种对比算法，对比的对象是<strong>新旧虚拟Dom</strong>。顾名思义，<strong>diff算法</strong>可以找到<strong>新旧虚拟Dom</strong>之间的差异，但<strong>diff算法</strong>中其实并不是只有对比<strong>虚拟DOM</strong>，还有根据对比后的结果更新<strong>真实Dom</strong></p>
</blockquote>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p> 在进行进一步了解之前，我们需要先明确<strong>虚拟DOM</strong>的概念：虚拟DOM就是一个用来描述真实DOM的 <strong>JS对象</strong>，它有6个属性：</p>
<ol>
<li>sel：当前节点标签名</li>
<li>data：节点内的所有属性</li>
<li>childen：当前节点的子节点</li>
<li>elm：虚拟节点对应的真实节点</li>
<li>key：当前节点的唯一标识</li>
<li>text：当前节点的文本</li>
</ol>
<p>结构类似这样：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode = &#123;</span><br><span class="line">    <span class="attr">sel</span>: <span class="string">&#x27;ul&#x27;</span>, </span><br><span class="line">    <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">children</span>: [ </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">sel</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">data</span>: &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, <span class="attr">text</span>: <span class="string">&#x27;son1&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">sel</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">data</span>: &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, <span class="attr">text</span>: <span class="string">&#x27;son2&#x27;</span></span><br><span class="line">        &#125;,    </span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">elm</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">key</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么虚拟Dom有什么用呢。我们其实可以把虚拟Dom理解成对应真实Dom的一种状态。当真实Dom发生变化后，虚拟Dom可以为我们提供这个真实Dom变化之前和变化之后的状态，我们通过对比这两个状态，即可得出真实Dom真正需要更新的部分，即可实现<strong>最小量</strong>更新。在一些比较复杂的Dom变化场景中，通过对比虚拟Dom后更新真实Dom会比直接更新真实Dom的效率高，这也就是虚拟Dom和diff算法真正存在的意义。</p>
<h3 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h3><p>要生成虚拟Dom，我们可以使用 <strong>h函数</strong>，就是render函数里面传入的那个<strong>h函数</strong>。它可以接受多种类型的参数，但其实它内部只干了一件事，就是执行<code>vnode函数</code>。根据传入<strong>h函数</strong>的参数来决定执行<code>vnode函数</code>时传入的参数。那么<code>vnode函数</code>又是干什么的呢？<code>vnode函数</code>其实也只干了一件事，就是把传入<strong>h函数</strong>的参数转化为一个对象，即虚拟Dom。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vnode.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">sel, data, children, text, elm</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = data.<span class="property">key</span> </span><br><span class="line">    <span class="keyword">return</span> &#123;sel, data, children, text, elm, key&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行<strong>h函数</strong>后，内部会通过<code>vnode函数</code>生成虚拟Dom，然后<strong>h函数</strong>返回这个虚拟Dom</p>
<h2 id="diff对比规则"><a href="#diff对比规则" class="headerlink" title="diff对比规则"></a>diff对比规则</h2><p>明确了<strong>h函数是干什么的</strong>，我们可以简单用<strong>h函数</strong>生成两个不同的虚拟节点，我们将通过一个简易版的diff算法代码介绍diff对比的具体流程。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数是sel 第二个参数是data 第三个参数是children</span></span><br><span class="line"><span class="keyword">const</span> myVnode1 = <span class="title function_">h</span>(<span class="string">&quot;h1&quot;</span>, &#123;&#125;, [</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&quot;p&quot;</span>, &#123;<span class="attr">key</span>: <span class="string">&quot;a&quot;</span>&#125;, <span class="string">&quot;a&quot;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&quot;p&quot;</span>, &#123;<span class="attr">key</span>: <span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;b&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myVnode2 = <span class="title function_">h</span>(<span class="string">&quot;h1&quot;</span>, &#123;&#125;, [</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&quot;p&quot;</span>, &#123;<span class="attr">key</span>: <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;c&quot;</span>),</span><br><span class="line">  <span class="title function_">h</span>(<span class="string">&quot;p&quot;</span>, &#123;<span class="attr">key</span>: <span class="string">&quot;d&quot;</span>&#125;, <span class="string">&quot;d&quot;</span>),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></div>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>比较的第一步就是执行<strong>patch</strong>，它相当于对比的入口。既然是对比两个虚拟Dom，那么就将两个虚拟Dom作为参数传入<strong>patch</strong>中。<strong>patch</strong>的主要作用是对比两个虚拟Dom的根节点，并根据对比结果操作真实Dom。</p>
<p>patch函数的核心代码如下，注意注释。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patch.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> vnode <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span></span><br><span class="line"><span class="keyword">import</span> patchDetails <span class="keyword">from</span> <span class="string">&quot;./patchVnode&quot;</span></span><br><span class="line"><span class="keyword">import</span> createEle <span class="keyword">from</span> <span class="string">&quot;./createEle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用来对比两个虚拟dom的根节点，并根据对比结果操作真实Dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; oldVnode </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; newVnode </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断oldVnode是否为虚拟节点，不是的话转化为虚拟节点</span></span><br><span class="line">  <span class="keyword">if</span>(!oldVnode.<span class="property">sel</span>) &#123;</span><br><span class="line">    <span class="comment">// 转化为虚拟节点</span></span><br><span class="line">    oldVnode = <span class="title function_">vnode</span>(oldVnode.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>(), &#123;&#125;, [], <span class="literal">undefined</span>, oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.判断oldVnode和newVnode是否为同一个节点</span></span><br><span class="line">  <span class="keyword">if</span>(oldVnode.<span class="property">key</span> == newVnode.<span class="property">key</span> &amp;&amp; oldVnode.<span class="property">sel</span> == newVnode.<span class="property">sel</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是同一个节点&#x27;</span>)</span><br><span class="line">    <span class="comment">// 比较子节点</span></span><br><span class="line">    <span class="title function_">patchDetails</span>(oldVnode, newVnode)</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;不是同一个节点&#x27;</span>)</span><br><span class="line">    <span class="comment">// 插入newVnode </span></span><br><span class="line">    <span class="keyword">const</span> newNode = <span class="title function_">createEle</span>(newVnode) <span class="comment">// 插入之前需要先将newVnode转化为dom</span></span><br><span class="line">    oldVnode.<span class="property">elm</span>.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(newNode, oldVnode.<span class="property">elm</span>) <span class="comment">// 插入操作</span></span><br><span class="line">    <span class="comment">// 删除oldVnode</span></span><br><span class="line">    oldVnode.<span class="property">elm</span>.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(oldVnode.<span class="property">elm</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>createEle：创建真实dom</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createEle.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 根据传入的虚拟Dom生成真实Dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; vnode </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> real node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createEle</span> (<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> realNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">sel</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子节点转换</span></span><br><span class="line">  <span class="keyword">if</span>(vnode.<span class="property">text</span> &amp;&amp; (vnode.<span class="property">children</span> == <span class="literal">undefined</span> || (vnode.<span class="property">children</span> &amp;&amp; vnode.<span class="property">children</span>.<span class="property">length</span> == <span class="number">0</span>)) ) &#123;</span><br><span class="line">    <span class="comment">// 子节点只含有文本</span></span><br><span class="line">    realNode.<span class="property">innerText</span> = vnode.<span class="property">text</span>  </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(vnode.<span class="property">children</span>) &amp;&amp; vnode.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 子节点为其他虚拟节点 递归添加node</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vnode.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> childNode = <span class="title function_">createEle</span>(vnode.<span class="property">children</span>[i])</span><br><span class="line">      realNode.<span class="title function_">appendChild</span>(childNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 补充vnode的elm属性</span></span><br><span class="line">  vnode.<span class="property">elm</span> = realNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p><strong>patchVnode</strong>用来比较两个虚拟节点的子节点并更新其子节点对应的真实Dom节点</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// patchVnode.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> updateChildren <span class="keyword">from</span> <span class="string">&quot;./updateChildren&quot;</span></span><br><span class="line"><span class="keyword">import</span> createEle <span class="keyword">from</span> <span class="string">&quot;./createEle&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 比较两个虚拟节点的子节点（children or text） 并更新其子节点对应的真实dom节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; oldVnode </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; newVnode </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">patchDetails</span>(<span class="params">oldVnode, newVnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断oldVnode和newVnode是否为同一个对象, 是的话直接不用比了</span></span><br><span class="line">  <span class="keyword">if</span>(oldVnode == newVnode) <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认newVnode和oldVnode只有text和children其中之一，真实的源码这里的情况会更多一些，不过大同小异。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="title function_">hasText</span>(newVnode)) &#123;</span><br><span class="line">    <span class="comment">// newVnode有text但没有children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  newVnode.text !== oldVnode.text 直接囊括了两种情况</span></span><br><span class="line"><span class="comment">     *  1.oldVnode有text无children 但是text和newVnode的text内容不同</span></span><br><span class="line"><span class="comment">     *  2.oldVnode无text有children 此时oldVnode.text为undefined </span></span><br><span class="line"><span class="comment">     *  两种情况都可以通过innerText属性直接完成dom更新 </span></span><br><span class="line"><span class="comment">     *  情况1直接更新text 情况2相当于去掉了children后加了新的text</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(newVnode.<span class="property">text</span> !== oldVnode.<span class="property">text</span>) &#123;</span><br><span class="line">      oldVnode.<span class="property">elm</span>.<span class="property">innerText</span> = newVnode.<span class="property">text</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">hasChildren</span>(newVnode)) &#123;</span><br><span class="line">    <span class="comment">// newVnode有children但是没有text</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">hasText</span>(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有text但是没有children</span></span><br><span class="line">      </span><br><span class="line">      oldVnode.<span class="property">elm</span>.<span class="property">innerText</span> = <span class="string">&#x27;&#x27;</span> <span class="comment">// 删除oldVnode的text</span></span><br><span class="line">      <span class="comment">// 添加newVnode的children</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newVnode.<span class="property">children</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        oldVnode.<span class="property">elm</span>.<span class="title function_">appendChild</span>(<span class="title function_">createEle</span>(newVnode.<span class="property">children</span>[i]))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">hasChildren</span>(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有children但是没有text</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对比两个节点的children 并更新对应的真实dom节点</span></span><br><span class="line">      <span class="title function_">updateChildren</span>(oldVnode.<span class="property">children</span>, newVnode.<span class="property">children</span>, oldVnode.<span class="property">elm</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有children没有text</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasChildren</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !node.<span class="property">text</span> &amp;&amp; (node.<span class="property">children</span> &amp;&amp; node.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 有text没有children</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasText</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> node.<span class="property">text</span> &amp;&amp; (node.<span class="property">children</span> == <span class="literal">undefined</span> || (node.<span class="property">children</span> &amp;&amp; node.<span class="property">children</span>.<span class="property">length</span> == <span class="number">0</span>))</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>该方法是diff算法中最复杂的方法（大的要来了）。对应上面patchVnode中oldVnode和newVnode都有children的情况。</p>
<p>首先我们需要介绍一下这里的对比规则。</p>
<p>对比过程中会引入四个指针，分别指向oldVnode子节点列表中的第一个节点和最后一个节点（后面我们简称为旧前和旧后）以及指向newVnode子节点列表中的第一个节点和最后一个节点（后面我们简称为新前和新后）</p>
<p>对比时，每一次对比按照以下顺序进行命中查找</p>
<ul>
<li>旧前与新前节点对比（1）</li>
<li>旧后与新后节点对比（2）</li>
<li>旧前与新后节点对比（3）</li>
<li>旧后与新前节点对比（4）</li>
</ul>
<p>上述四种情况，如果某一种情况两个指针对应的虚拟Dom相同，那么我们称之为命中。命中后就不会接着查找了，指针会移动，（还有可能会操作真实Dom，3或者4命中时会操作真实Dom移动节点）之后开始下一次对比。如果都没有命中，则去oldVnode子节点列表循环查找当前新前指针所指向的节点，如果查到了，那么操作真实Dom移动节点，没查到则新增真实Dom节点插入。</p>
<p>这种模式的对比会一直进行，直到满足了终止条件。即旧前指针移动到了旧后指针的后面或者新前指针移动到了新后指针的后面，我们可以理解为旧子节点先处理完毕和新子节点处理完毕。那么我们可以预想到新旧子节点中总会有其一先处理完，对比结束后，我们会根据没有处理完子节点的那一对前后指针决定是要插入真实Dom还是删除真实Dom。</p>
<p>如果旧子节点先处理完了，新子节点有剩余，说明有要新增的节点。将根据最终新前和新后之间的虚拟节点执行插入操作<br>如果新子节点先处理完了，旧子节点有剩余，说明有要删除的节点。将根据最终旧前和旧后之间的虚拟节点执行删除操作<br>下面将呈现代码，注意注释</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// updateChildren.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> patchDetails <span class="keyword">from</span> <span class="string">&quot;./patchVnode&quot;</span></span><br><span class="line"><span class="keyword">import</span> createEle <span class="keyword">from</span> <span class="string">&quot;./createEle&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对比子节点列表并更新真实Dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; oldCh 旧虚拟Dom子节点列表 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; newCh 新虚拟Dom子节点列表 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; parent 新旧虚拟节点对应的真实Dom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">updateChildren</span>(<span class="params">oldCh, newCh, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义四个指针 旧前 旧后 新前 新后 （四个指针两两一对，每一对前后指针所指向的节点以及其之间的节点为未处理的子节点）</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIndex = oldCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newEndIndex = newCh.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 四个指针对应的节点</span></span><br><span class="line">  <span class="keyword">let</span> oldStartNode = oldCh[oldStartIndex];</span><br><span class="line">  <span class="keyword">let</span> oldEndNode = oldCh[oldEndIndex];</span><br><span class="line">  <span class="keyword">let</span> newStartNode = newCh[newStartIndex];</span><br><span class="line">  <span class="keyword">let</span> newEndNode = newCh[newEndIndex];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oldCh中每个子节点 key 与 index的哈希表 用于四种对比规则都不匹配的情况下在oldCh中寻找节点</span></span><br><span class="line">  <span class="keyword">const</span> keyMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 开始遍历两个children数组进行细节对比</span></span><br><span class="line"><span class="comment">   * 对比规则：旧前-新前 旧后-新后 旧前-新后 旧后-新前</span></span><br><span class="line"><span class="comment">   * 对比之后指针进行移动</span></span><br><span class="line"><span class="comment">   * 直到指针不满足以下条件 意味着有一对前后指针之间再无未处理的子节点 则停止对比 直接操作DOM</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="comment">// 这四种情况是为了让指针在移动的过程中跳过空节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartNode == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      oldStartNode = oldCh[++oldStartIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndNode == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      oldEndNode = oldCh[--oldEndIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartNode == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      newStartNode = newCh[++newStartIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndNode == <span class="literal">undefined</span>) &#123;</span><br><span class="line">      newEndNode = newCh[--newEndIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSame</span>(oldStartNode, newStartNode)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">      <span class="comment">// 旧前-新前是同一个虚拟节点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 两个子节点再对比他们的子节点并更新dom （递归切入点）</span></span><br><span class="line">      <span class="title function_">patchDetails</span>(oldStartNode, newStartNode);</span><br><span class="line">      <span class="comment">// 指针移动</span></span><br><span class="line">      oldStartNode = oldCh[++oldStartIndex];</span><br><span class="line">      newStartNode = newCh[++newStartIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSame</span>(oldEndNode, newEndNode)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">      <span class="comment">// 旧后-新后是同一个虚拟节点</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 两个子节点再对比他们的子节点并更新dom （递归切入点）</span></span><br><span class="line">      <span class="title function_">patchDetails</span>(oldEndNode, newEndNode);</span><br><span class="line">      <span class="comment">// 指针移动</span></span><br><span class="line">      oldEndNode = oldCh[--oldEndIndex];</span><br><span class="line">      newEndNode = newCh[--newEndIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSame</span>(oldStartNode, newEndNode)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line">      <span class="comment">// 旧前-新后是同一个虚拟节点</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 两个子节点再对比他们的子节点并更新dom （递归切入点）</span></span><br><span class="line">      <span class="title function_">patchDetails</span>(oldStartNode, newEndNode);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  这一步多一个移动(真实)节点的操作</span></span><br><span class="line"><span class="comment">       *  需要把当前指针所指向的子节点 移动到 oldEndIndex所对应真实节点之后（也就是未处理真实节点的尾部）</span></span><br><span class="line"><span class="comment">       *  注意：这一步是在操作真实节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldStartNode.<span class="property">elm</span>, oldEndNode.<span class="property">elm</span>.<span class="property">nextSibling</span>);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 指针移动</span></span><br><span class="line">      oldStartNode = oldCh[++oldStartIndex];</span><br><span class="line">      newEndNode = newCh[--newEndIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSame</span>(oldEndNode, newStartNode)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method4&quot;</span>);</span><br><span class="line">      <span class="comment">// 旧后-新前 是同一个虚拟节点</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 两个子节点再对比他们的子节点并更新dom （递归切入点）</span></span><br><span class="line">      <span class="title function_">patchDetails</span>(oldEndNode, newStartNode);</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  这一步多一个移动(真实)节点的操作</span></span><br><span class="line"><span class="comment">       *  与method3不同在移动位置</span></span><br><span class="line"><span class="comment">       *  需要把当前指针所指向的子节点 移动到 oldStartIndex所对应真实节点之前（也就是未处理真实节点的顶部）</span></span><br><span class="line"><span class="comment">       *  注意：这一步是在操作真实节点</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(oldEndNode.<span class="property">elm</span>, oldCh[oldStartIndex].<span class="property">elm</span>);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 指针移动</span></span><br><span class="line">      oldEndNode = oldCh[--oldEndIndex];</span><br><span class="line">      newStartNode = newCh[++newStartIndex];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;does not match&quot;</span>);</span><br><span class="line">      <span class="comment">// 四种规则都不匹配</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 生成keyMap</span></span><br><span class="line">      <span class="keyword">if</span> (keyMap.<span class="property">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIndex; i &lt;= oldEndIndex; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oldCh[i].<span class="property">key</span>) keyMap.<span class="title function_">set</span>(oldCh[i].<span class="property">key</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 在oldCh中搜索当前newStartIndex所指向的节点</span></span><br><span class="line">      <span class="keyword">if</span> (keyMap.<span class="title function_">has</span>(newStartNode.<span class="property">key</span>)) &#123;</span><br><span class="line">        <span class="comment">// 搜索到了</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 先获取oldCh中该虚拟节点</span></span><br><span class="line">        <span class="keyword">const</span> oldMoveNode = oldCh[keyMap.<span class="title function_">get</span>(newStartNode.<span class="property">key</span>)];</span><br><span class="line">        <span class="comment">// 两个子节点再对比他们的子节点并更新dom （递归切入点）</span></span><br><span class="line">        <span class="title function_">patchDetails</span>(oldMoveNode, newStartNode);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 移动这个节点（移动的是真实节点）</span></span><br><span class="line">        parent.<span class="title function_">insertBefore</span>(oldMoveNode.<span class="property">elm</span>, oldStartNode.<span class="property">elm</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 该虚拟节点设置为undefined（还记得最开始的四个条件吗，因为这里会将子节点制空，所以加了那四个条件）</span></span><br><span class="line">        oldCh[keyMap.<span class="title function_">get</span>(newStartNode.<span class="property">key</span>)] = <span class="literal">undefined</span>;</span><br><span class="line">          </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没搜索到 直接插入</span></span><br><span class="line">        parent.<span class="title function_">insertBefore</span>(<span class="title function_">createEle</span>(newStartNode), oldStartNode.<span class="property">elm</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 指针移动</span></span><br><span class="line">      newStartNode = newCh[++newStartIndex];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 插入和删除节点</span></span><br><span class="line"><span class="comment">   * while结束后 有一对前后指针之间仍然有未处理的子节点，那么就会进行插入或者删除操作</span></span><br><span class="line"><span class="comment">   * oldCh的双指针中有未处理的子节点，进行删除操作</span></span><br><span class="line"><span class="comment">   * newCh的双指针中有未处理的子节点，进行插入操作</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIndex &lt;= oldEndIndex) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIndex; i &lt;= oldEndIndex; i++) &#123;</span><br><span class="line">      <span class="comment">// 加判断是因为oldCh[i]有可能为undefined</span></span><br><span class="line">      <span class="keyword">if</span>(oldCh[i]) parent.<span class="title function_">removeChild</span>(oldCh[i].<span class="property">elm</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * 这里需要注意的点是从哪里插入，也就是appendChild的第二个参数</span></span><br><span class="line"><span class="comment">     * 应该从oldStartIndex对应的位置插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIndex; i &lt;= newEndIndex; i++) &#123;</span><br><span class="line">      <span class="comment">// oldCh[oldStartIndex]存在是从头部插入</span></span><br><span class="line">      parent.<span class="title function_">insertBefore</span>(<span class="title function_">createEle</span>(newCh[i]), oldCh[oldStartIndex] ? oldCh[oldStartIndex].<span class="property">elm</span> : <span class="literal">undefined</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个虚拟节点是否为同一个虚拟节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isSame</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="property">sel</span> == b.<span class="property">sel</span> &amp;&amp; a.<span class="property">key</span> == b.<span class="property">key</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的逻辑稍微比较复杂，需要大家多理几遍，必要的话，自己手画一张图自己移动一下指针。着重需要注意的地方是操作真实Dom时，插入、移动节点应该将节点从哪里插入或者移动到哪里，其实基本插入到oldStartIndex对应的真实Dom的前面，除了第三种命中后的移动节点操作，是移动到oldEndIndex所对应真实节点之后</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于diff算法对比的是虚拟Dom，而虚拟Dom是呈树状的，所以我们可以发现，diff算法中充满了递归。总结起来，其实diff算法就是一个 patch —&gt; patchVnode —&gt; updateChildren —&gt; patchVnode —&gt; updateChildren —&gt; patchVnode这样的一个循环递归的过程。</p>
<p>这里再提一嘴key，我们面试中经常会被问到vue中key的作用。根据上面我们分析的，key的主要作用其实就是对比两个虚拟节点时，判断其是否为相同节点。加了key以后，我们可以更为明确的判断两个节点是否为同一个虚拟节点，是的话判断子节点是否有变更（有变更更新真实Dom），不是的话继续比。如果不加key的话，如果两个不同节点的标签名恰好相同，那么就会被判定为同一个节点（key都为undefined），结果一对比这两个节点的子节点发现不一样，这样会凭空增加很多对真实Dom的操作，从而导致页面更频繁得进行重绘和回流。</p>
<p>所以我认为合理利用key可以有效减少真实Dom的变动，从而减少页面重绘和回流的频率，进而提高页面更新的效率。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>setup中如何使用mapState</title>
    <url>/2020/02/28/Vue/setup%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8mapState/</url>
    <content><![CDATA[<blockquote>
<p>vuex提供了mapState、mapMutations…辅助函数，让我们能够方便的映射vuex中的state、getters、mutations以及actions</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	...<span class="title function_">mapState</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>]),</span><br><span class="line">	<span class="comment">// otherComputed...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>mapState函数实际生成的是一个如下的对象，我们将其展开到组件的配置中</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">age</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">age</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...otherComputed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>但是setup中没有computed选项，的计算属性只能使用computed组合式api进行创建，如下</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// store等同于this.$store，setup中没有this，只能这个书写</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.<span class="property">name</span>)</span><br><span class="line"><span class="keyword">const</span> age = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> store.<span class="property">state</span>.<span class="property">age</span>)</span><br></pre></td></tr></table></figure></div>

<p>因此我们只需要将mapState返回的对象改造为setup的组合式API写法即可解决这个问题</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处省略依赖导入...</span></span><br><span class="line"><span class="keyword">const</span> stateObj = <span class="title function_">mapState</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// stateObj结果</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    name: function()&#123;</span></span><br><span class="line"><span class="comment">        return this.$store.state.name</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    age: function()&#123;</span></span><br><span class="line"><span class="comment">        return this.$store.state.age</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> myState = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stateObj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(stateObj, key)) &#123;</span><br><span class="line">        <span class="comment">// fn函数中需要使用到this.$store，因为setup中没有this，因此需要手动修改该函数的this指向</span></span><br><span class="line">        <span class="keyword">const</span> fn = stateObj[key].<span class="title function_">bind</span>(&#123; <span class="attr">$store</span>: <span class="title function_">useStore</span>() &#125;)</span><br><span class="line">        myState[key] = <span class="title function_">computed</span>(fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后就可以正常使用我们仓库的数据了</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = myState</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>, age.<span class="property">value</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote>
<p> 每次这么写会很麻烦，不仅会使键盘的寿命缩减，还容易把手上磨出茧子，因此我们可以对这些东西进行封装</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略导入语法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupMapState</span> (<span class="params">keys</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用仓库对象</span></span><br><span class="line">    <span class="keyword">const</span> $store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 根据参数进行映射</span></span><br><span class="line">    <span class="keyword">const</span> stateFn = <span class="title function_">mapState</span>(keys)</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stateFn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(stateFn, key)) &#123;</span><br><span class="line">            <span class="comment">// 修改计算函数内部this指向</span></span><br><span class="line">            <span class="keyword">const</span> fn = stateFn[key].<span class="title function_">bind</span>(&#123; $store &#125;)</span><br><span class="line">            <span class="comment">// 存储</span></span><br><span class="line">            res[key] = <span class="title function_">computed</span>(fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将映射结果返回</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>大功告成，接下来就可以正常使用了</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">setupMapState</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>, age.<span class="property">value</span>);</span><br></pre></td></tr></table></figure></div>



<h2 id="vuex的模块化"><a href="#vuex的模块化" class="headerlink" title="vuex的模块化"></a>vuex的模块化</h2><blockquote>
<p>如果vuex进行了模块化拆分，我们在进行映射时需要传递对应的模块名，显然现在的一个参数难以满足我们的需求，展开运算符可以帮上大忙</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略导入语法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setupMapState</span> (<span class="params">...arg</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用仓库对象</span></span><br><span class="line">    <span class="keyword">const</span> $store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 根据参数进行映射</span></span><br><span class="line">    <span class="keyword">const</span> stateFn = <span class="title function_">mapState</span>(...arg)</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stateFn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(stateFn, key)) &#123;</span><br><span class="line">            <span class="comment">// 修改计算函数内部this指向</span></span><br><span class="line">            <span class="keyword">const</span> fn = stateFn[key].<span class="title function_">bind</span>(&#123; $store &#125;)</span><br><span class="line">            <span class="comment">// 存储</span></span><br><span class="line">            res[key] = <span class="title function_">computed</span>(fn)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将映射结果返回</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>这样就能支持其他模块的导入了</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">setupMapState</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">value</span>, age.<span class="property">value</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: otherModuleName &#125; = <span class="title function_">setupMapState</span>(<span class="string">&#x27;otherModule&#x27;</span> ,[<span class="string">&#x27;name&#x27;</span>]) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherModuleName.<span class="property">value</span>);</span><br></pre></td></tr></table></figure></div>

<h2 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h2><blockquote>
<p> 其他的映射函数也可以进行处理，这样就更加方便了</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 相关辅助函数导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions, mapGetters, mapMutations, mapState, useStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapAll</span> (<span class="params">keys, mapFn</span>) &#123;</span><br><span class="line">    <span class="comment">// 导入仓库对象</span></span><br><span class="line">    <span class="keyword">const</span> $store = <span class="title function_">useStore</span>()</span><br><span class="line">    <span class="comment">// 根据传入的辅助函数和其他参数进行映射</span></span><br><span class="line">    <span class="keyword">const</span> stateFn = <span class="title function_">mapFn</span>(...keys)</span><br><span class="line">    <span class="comment">// 记录映射结果</span></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="comment">// 如果映射的是state或getters需要使用computed组合式API包裹，因此做了这样一个判断</span></span><br><span class="line">    <span class="keyword">const</span> isMapData = [mapState, mapGetters].<span class="title function_">includes</span>(mapFn)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> stateFn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(stateFn, key)) &#123;</span><br><span class="line">            <span class="comment">// 修改映射函数内部this指向</span></span><br><span class="line">            <span class="keyword">const</span> fn = stateFn[key].<span class="title function_">bind</span>(&#123; $store &#125;)</span><br><span class="line">            <span class="comment">// 记录：state或getters使用computed进行包裹，其他的直接记录</span></span><br><span class="line">            res[key] = isMapData ? <span class="title function_">computed</span>(fn) : fn</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出对应的setup映射函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setupMapState</span> (<span class="params">...keys</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mapAll</span>(keys, mapState)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setupMapMutations</span> (<span class="params">...keys</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mapAll</span>(keys, mapMutations)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setupMapGetters</span> (<span class="params">...keys</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mapAll</span>(keys, mapGetters)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setupMapActions</span> (<span class="params">...keys</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">mapAll</span>(keys, mapActions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


<p>使用说明: 封装完成之后只需要进行导入，然后和使用正常的辅助函数用法相同</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射state</span></span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = <span class="title function_">setupMapState</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"><span class="comment">// 其他模块的state</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: homeName &#125; = <span class="title function_">setupMapState</span>(<span class="string">&#x27;home&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="comment">// 映射mutations</span></span><br><span class="line"><span class="keyword">const</span> &#123; setName &#125; = <span class="title function_">setupMapMutations</span>([<span class="string">&#x27;setName&#x27;</span>])</span><br><span class="line"><span class="comment">// 映射getters</span></span><br><span class="line"><span class="keyword">const</span> &#123; names &#125; = <span class="title function_">setupMapGetters</span>(&#123;</span><br><span class="line">  <span class="attr">names</span>: <span class="string">&#x27;getName&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 映射actions</span></span><br><span class="line"><span class="keyword">const</span> &#123; postName &#125; = <span class="title function_">setupMapActions</span>([<span class="string">&#x27;postName&#x27;</span>])</span><br><span class="line"><span class="comment">// 传参方式和vuex辅助函数相同</span></span><br></pre></td></tr></table></figure></div>





]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 前端代码风格指南</title>
    <url>/2020/02/28/Vue/Vue%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a><strong>一、命名规范</strong></h2><p>市面上常用的命名规范：</p>
<ul>
<li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li>
<li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li>
<li><code>kebab-case</code>（短横线连接式）</li>
<li><code>Snake</code>（下划线连接式）</li>
</ul>
<h3 id="1-1-项目文件命名"><a href="#1-1-项目文件命名" class="headerlink" title="1.1 项目文件命名"></a><strong>1.1 项目文件命名</strong></h3><h3 id="1-1-1-项目名"><a href="#1-1-1-项目名" class="headerlink" title="1.1.1 项目名"></a><strong>1.1.1 项目名</strong></h3><p>全部采用小写方式， 以<strong>短横线</strong>分隔。例：<code>my-project-name</code>。</p>
<h3 id="1-1-2-目录名"><a href="#1-1-2-目录名" class="headerlink" title="1.1.2 目录名"></a><strong>1.1.2 目录名</strong></h3><p><strong>参照项目命名规则，有复数结构时，要采用复数命名法</strong>。例：docs、assets、components、directives、mixins、utils、views。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">my-project-name/</span><br><span class="line">|- <span class="title class_">BuildScript</span>    <span class="comment">// 流水线部署文件目录</span></span><br><span class="line">|- docs           <span class="comment">// 项目的细化文档目录（可选）</span></span><br><span class="line">|- nginx          <span class="comment">// 部署在容器上前端项目 nginx 代理文件目录</span></span><br><span class="line">|- node_modules   <span class="comment">// 下载的依赖包</span></span><br><span class="line">|- public         <span class="comment">// 静态页面目录</span></span><br><span class="line">    |- index.<span class="property">html</span> <span class="comment">// 项目入口</span></span><br><span class="line">|- src            <span class="comment">// 源码目录</span></span><br><span class="line">    |- api        <span class="comment">// http 请求目录</span></span><br><span class="line">    |- assets     <span class="comment">// 静态资源目录，这里的资源会被wabpack构建</span></span><br><span class="line">        |- icon   <span class="comment">// icon 存放目录</span></span><br><span class="line">        |- img    <span class="comment">// 图片存放目录</span></span><br><span class="line">        |- js     <span class="comment">// 公共 js 文件目录</span></span><br><span class="line">        |- scss   <span class="comment">// 公共样式 scss 存放目录</span></span><br><span class="line">            |- frame.<span class="property">scss</span>   <span class="comment">// 入口文件</span></span><br><span class="line">            |- <span class="variable language_">global</span>.<span class="property">scss</span>  <span class="comment">// 公共样式</span></span><br><span class="line">            |- reset.<span class="property">scss</span>   <span class="comment">// 重置样式</span></span><br><span class="line">    |- components     <span class="comment">// 组件</span></span><br><span class="line">    |- plugins        <span class="comment">// 插件</span></span><br><span class="line">    |- router         <span class="comment">// 路由</span></span><br><span class="line">    |- routes         <span class="comment">// 详细的路由拆分目录（可选）</span></span><br><span class="line">        |- index.<span class="property">js</span></span><br><span class="line">    |- store          <span class="comment">// 全局状态管理</span></span><br><span class="line">    |- utils          <span class="comment">// 工具存放目录</span></span><br><span class="line">        |- request.<span class="property">js</span> <span class="comment">// 公共请求工具</span></span><br><span class="line">    |- views          <span class="comment">// 页面存放目录</span></span><br><span class="line">    |- <span class="title class_">App</span>.<span class="property">vue</span>        <span class="comment">// 根组件</span></span><br><span class="line">    |- main.<span class="property">js</span>        <span class="comment">// 入口文件</span></span><br><span class="line">    |- tests          <span class="comment">// 测试用例</span></span><br><span class="line">    |- .<span class="property">browserslistrc</span><span class="comment">// 浏览器兼容配置文件</span></span><br><span class="line">    |- .<span class="property">editorconfig</span>  <span class="comment">// 编辑器配置文件</span></span><br><span class="line">    |- .<span class="property">eslintignore</span>  <span class="comment">// eslint 忽略规则</span></span><br><span class="line">    |- .<span class="property">eslintrc</span>.<span class="property">js</span>   <span class="comment">// eslint 规则</span></span><br><span class="line">    |- .<span class="property">gitignore</span>     <span class="comment">// git 忽略规则</span></span><br><span class="line">    |- babel.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// babel 规则</span></span><br><span class="line">    |- <span class="title class_">Dockerfile</span> <span class="comment">// Docker 部署文件</span></span><br><span class="line">    |- jest.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">    |- package-lock.<span class="property">json</span></span><br><span class="line">    |- package.<span class="property">json</span> <span class="comment">// 依赖</span></span><br><span class="line">    |- <span class="variable constant_">README</span>.<span class="property">md</span> <span class="comment">// 项目 README</span></span><br><span class="line">    |- vue.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// webpack 配置</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-3-图像文件名"><a href="#1-1-3-图像文件名" class="headerlink" title="1.1.3 图像文件名"></a><strong>1.1.3 图像文件名</strong></h3><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">banner_sina.<span class="property">gif</span></span><br><span class="line">menu_aboutus.<span class="property">gif</span></span><br><span class="line">menutitle_news.<span class="property">gif</span></span><br><span class="line">logo_police.<span class="property">gif</span></span><br><span class="line">logo_national.<span class="property">gif</span></span><br><span class="line">pic_people.<span class="property">jpg</span></span><br><span class="line">pic_TV.<span class="property">jpg</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-4-HTML-文件名"><a href="#1-1-4-HTML-文件名" class="headerlink" title="1.1.4 HTML 文件名"></a><strong>1.1.4 HTML 文件名</strong></h3><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">|- error_report.<span class="property">html</span></span><br><span class="line">|- success_report.<span class="property">html</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-5-CSS-文件名"><a href="#1-1-5-CSS-文件名" class="headerlink" title="1.1.5 CSS 文件名"></a><strong>1.1.5 CSS 文件名</strong></h3><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">|- normalize.<span class="property">less</span></span><br><span class="line">|- base.<span class="property">less</span></span><br><span class="line">|- date-picker.<span class="property">scss</span></span><br><span class="line">|- input-number.<span class="property">scss</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-1-6-JavaScript-文件名"><a href="#1-1-6-JavaScript-文件名" class="headerlink" title="1.1.6 JavaScript 文件名"></a><strong>1.1.6 JavaScript 文件名</strong></h3><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">|- index.<span class="property">js</span></span><br><span class="line">|- plugin.<span class="property">js</span></span><br><span class="line">|- util.<span class="property">js</span></span><br><span class="line">|- date-util.<span class="property">js</span></span><br><span class="line">|- account-model.<span class="property">js</span></span><br><span class="line">|- collapse-transition.<span class="property">js</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>上述规则可以快速记忆为“静态文件下划线，编译文件短横线”。</p>
</blockquote>
<h3 id="1-2-Vue-组件命名"><a href="#1-2-Vue-组件命名" class="headerlink" title="1.2 Vue 组件命名"></a><strong>1.2 Vue 组件命名</strong></h3><h3 id="1-2-1-单文件组件名"><a href="#1-2-1-单文件组件名" class="headerlink" title="1.2.1 单文件组件名"></a><strong>1.2.1 单文件组件名</strong></h3><p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code> (单文件组件)。单文件组件名应该始终是<strong>单词大写开头</strong> (PascalCase)。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">MyComponent</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-2-单例组件名"><a href="#1-2-2-单例组件名" class="headerlink" title="1.2.2 单例组件名"></a><strong>1.2.2 单例组件名</strong></h3><p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p>
<p>这不意味着组件只可用于一个单页面，而是_每个页面_只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，_只是目前_在每个页面里只使用一次。</p>
<p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">TheHeading</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">TheSidebar</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-3-基础组件名"><a href="#1-2-3-基础组件名" class="headerlink" title="1.2.3 基础组件名"></a><strong>1.2.3 基础组件名</strong></h3><blockquote>
<p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p>
</blockquote>
<p>应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。<strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">BaseButton</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">BaseTable</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">BaseIcon</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-4-业务组件"><a href="#1-2-4-业务组件" class="headerlink" title="1.2.4 业务组件"></a><strong>1.2.4 业务组件</strong></h3><blockquote>
<p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p>
</blockquote>
<p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>应该以 <code>Custom</code> 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">CustomCard</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-5-紧密耦合的组件名"><a href="#1-2-5-紧密耦合的组件名" class="headerlink" title="1.2.5 紧密耦合的组件名"></a><strong>1.2.5 紧密耦合的组件名</strong></h3><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong> 因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">TodoList</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">TodoListItem</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">TodoListItemButton</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-2-6-组件名中单词顺序"><a href="#1-2-6-组件名中单词顺序" class="headerlink" title="1.2.6 组件名中单词顺序"></a><strong>1.2.6 组件名中单词顺序</strong></h3><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong> 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">SearchButtonClear</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">SearchButtonRun</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">SearchInputQuery</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">SearchInputExcludeGlob</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">SettingsCheckboxTerms</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">SettingsCheckboxLaunchOnStartup</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<p>还有另一种多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</p>
<h3 id="1-2-7-完整单词的组件名"><a href="#1-2-7-完整单词的组件名" class="headerlink" title="1.2.7 完整单词的组件名"></a><strong>1.2.7 完整单词的组件名</strong></h3><p><strong>组件名应该倾向于而不是缩写。</strong> 编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">components/</span><br><span class="line">|- <span class="title class_">StudentDashboardSettings</span>.<span class="property">vue</span></span><br><span class="line">|- <span class="title class_">UserProfileOptions</span>.<span class="property">vue</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-代码参数命名"><a href="#1-3-代码参数命名" class="headerlink" title="1.3 代码参数命名"></a><strong>1.3 代码参数命名</strong></h3><h3 id="1-3-1-name"><a href="#1-3-1-name" class="headerlink" title="1.3.1 name"></a><strong>1.3.1 name</strong></h3><p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的。</strong> 根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ToDoList&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-2-prop"><a href="#1-3-2-prop" class="headerlink" title="1.3.2 prop"></a><strong>1.3.2 prop</strong></h3><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">WelcomeMessage</span> greeting-text=<span class="string">&quot;hi&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">greetingText</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;syncing&#x27;</span>, <span class="string">&#x27;synced&#x27;</span>,].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-3-router"><a href="#1-3-3-router" class="headerlink" title="1.3.3 router"></a><strong>1.3.3 router</strong></h3><p><strong>Vue Router Path 命名采用 kebab-case 格式。</strong> 用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user_info&#x27;</span>, <span class="comment">// user_info 当成一个单词</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user-info&#x27;</span>, <span class="comment">// 能解析成 user info</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-4-模板中组件"><a href="#1-3-4-模板中组件" class="headerlink" title="1.3.4 模板中组件"></a><strong>1.3.4 模板中组件</strong></h3><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</strong></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在单文件组件和字符串模板中 --&gt; </span><br><span class="line">&lt;MyComponent/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 DOM 模板中 --&gt; </span><br><span class="line">&lt;my-component&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-5-自闭合组件"><a href="#1-3-5-自闭合组件" class="headerlink" title="1.3.5 自闭合组件"></a><strong>1.3.5 自闭合组件</strong></h3><p><strong>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 在所有地方 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-6-变量"><a href="#1-3-6-变量" class="headerlink" title="1.3.6 变量"></a><strong>1.3.6 变量</strong></h3><ul>
<li>命名方法：camelCase</li>
<li>命名规范：类型 + 对象描述或属性的方式</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> getTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> tableTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySchool = <span class="string">&quot;我的学校&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-7-常量"><a href="#1-3-7-常量" class="headerlink" title="1.3.7 常量"></a><strong>1.3.7 常量</strong></h3><ul>
<li>命名方法：全部大写下划线分割</li>
<li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_COUNT</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;http://test.host.com&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-8-方法"><a href="#1-3-8-方法" class="headerlink" title="1.3.8 方法"></a><strong>1.3.8 方法</strong></h3><ul>
<li>命名方法：camelCase</li>
<li>命名规范：统一使用动词或者动词 + 名词形式</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、普通情况下，使用动词 + 名词形式</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">go、nextPage、show、open、login</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">jumpPage、openCarInfoDialog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、请求数据方法，以 data 结尾</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">takeData、confirmData、getList、postForm</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">getListData、postFormData</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、单个动词的情况</span></span><br><span class="line">init、refresh</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>动词</th>
<th>含义</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>can</td>
<td>判断是否可执行某个动作 (权 )</td>
<td>函数返回一个布尔值。true：可执行；false：不可执行；</td>
</tr>
<tr>
<td>has</td>
<td>判断是否含有某个值</td>
<td>函数返回一个布尔值。true：含有此值；false：不含有此值；</td>
</tr>
<tr>
<td>is</td>
<td>判断是否为某个值</td>
<td>函数返回一个布尔值。true：为某个值；false：不为某个值；</td>
</tr>
<tr>
<td>get</td>
<td>获取某个值</td>
<td>函数返回一个非布尔值</td>
</tr>
<tr>
<td>set</td>
<td>设置某个值</td>
<td>无返回值、返回是否设置成功或者返回链式对象</td>
</tr>
</tbody></table>
<h3 id="1-3-9-自定义事件"><a href="#1-3-9-自定义事件" class="headerlink" title="1.3.9 自定义事件"></a><strong>1.3.9 自定义事件</strong></h3><p><strong>自定义事件应始终使用 kebab-case 的事件名。</strong></p>
<p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">MyComponent</span> @my-event=<span class="string">&quot;handleDoSomething&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></div>

<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p>
<ul>
<li><strong>原生事件参考列表[1]</strong></li>
</ul>
<p>由原生事件可以发现其使用方式如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;toggleMenu&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.esc</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.up.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.down.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.tab</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.delete</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseenter</span>=<span class="string">&quot;hasMouseHoverHead = true&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseleave</span>=<span class="string">&quot;hasMouseHoverHead = false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>而为了区分_原生事件_和_自定义事件_在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，命名还需遵守为 <strong><code>on</code> + 动词</strong> 的形式，如下：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">on-search</span>=<span class="string">&quot;handleSearch&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">on-clear</span>=<span class="string">&quot;handleClear&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  @<span class="attr">on-clickoutside</span>=<span class="string">&quot;handleClickOutside&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleTriggerItem</span> () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;on-clear&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-10-事件方法"><a href="#1-3-10-事件方法" class="headerlink" title="1.3.10 事件方法"></a><strong>1.3.10 事件方法</strong></h3><ul>
<li>命名方法：camelCase</li>
<li>命名规范：handle + 名称（可选）+ 动词</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">click.native.stop</span>=<span class="string">&quot;handleItemClick()&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">mouseenter.native.stop</span>=<span class="string">&quot;handleItemHover()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleItemClick</span> () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">handleItemHover</span> () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="二、代码规范"><a href="#二、代码规范" class="headerlink" title="二、代码规范"></a><strong>二、代码规范</strong></h2><p><strong>2.1 Vue</strong></p>
<h3 id="2-1-1-代码结构"><a href="#2-1-1-代码结构" class="headerlink" title="2.1.1 代码结构"></a><strong>2.1.1 代码结构</strong></h3><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;my-component&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">DemoComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">DemoComponent</span> <span class="keyword">from</span> <span class="string">&#x27;../components/DemoComponent&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">DemoComponent</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [],</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span> () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">computed</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">watch</span>: &#123;&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">created</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">mounted</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">destroyed</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">#my-component &#123;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-2-data"><a href="#2-1-2-data" class="headerlink" title="2.1.2 data"></a><strong>2.1.2 data</strong></h3><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In a .vue file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-3-prop"><a href="#2-1-3-prop" class="headerlink" title="2.1.3 prop"></a><strong>2.1.3 prop</strong></h3><p><strong>Prop 定义应该尽量详细。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">status</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;syncing&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;synced&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;version-conflict&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-4-computed"><a href="#2-1-4-computed" class="headerlink" title="2.1.4 computed"></a><strong>2.1.4 computed</strong></h3><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong> 小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="attr">computed</span>: &#123; </span><br><span class="line">  <span class="attr">price</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> basePrice = <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>) </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      basePrice - </span><br><span class="line">      basePrice * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>) </span><br><span class="line">    ) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">basePrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">discount</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">finalPrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> - <span class="variable language_">this</span>.<span class="property">discount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-5-为-v-for-设置键值"><a href="#2-1-5-为-v-for-设置键值" class="headerlink" title="2.1.5 为 v-for 设置键值"></a><strong>2.1.5 为 <code>v-for</code> 设置键值</strong></h3><p>**在组件上必须用 <code>key</code> 搭配 <code>v-for</code><strong>，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的</strong>对象固化 (object constancy)[2]**。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; todo.text &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-6-v-if-和-v-for-互斥"><a href="#2-1-6-v-if-和-v-for-互斥" class="headerlink" title="2.1.6 v-if 和 v-for 互斥"></a><strong>2.1.6 <code>v-if</code> 和 <code>v-for</code> 互斥</strong></h3><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- bad：控制台报错 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>一般我们在两种常见的情况下会倾向于这样做：</p>
<ul>
<li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> user.<span class="property">isActive</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>, <code>ol</code>)。</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- bad --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- good --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-7-多个-attribute-的元素"><a href="#2-1-7-多个-attribute-的元素" class="headerlink" title="2.1.7 多个 attribute 的元素"></a><strong>2.1.7 多个 attribute 的元素</strong></h3><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- bad --&gt;</span><br><span class="line">&lt;img src=&quot;https://vuejs.org/images/logo.png&quot; alt=&quot;Vue Logo&quot;&gt;</span><br><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- good --&gt;</span><br><span class="line">&lt;img</span><br><span class="line">  src=&quot;https://vuejs.org/images/logo.png&quot;</span><br><span class="line">  alt=&quot;Vue Logo&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent</span><br><span class="line">  foo=&quot;a&quot;</span><br><span class="line">  bar=&quot;b&quot;</span><br><span class="line">  baz=&quot;c&quot;/&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-8-模板中简单的表达式"><a href="#2-1-8-模板中简单的表达式" class="headerlink" title="2.1.8 模板中简单的表达式"></a><strong>2.1.8 模板中简单的表达式</strong></h3><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p>
<p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;&#123;</span><br><span class="line">  fullName.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>更好的做法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在模板中 --&gt;</span><br><span class="line">&#123;&#123; normalizedFullName &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedFullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">fullName</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-9-带引号的-attribute-值"><a href="#2-1-9-带引号的-attribute-值" class="headerlink" title="2.1.9 带引号的 attribute 值"></a><strong>2.1.9 带引号的 attribute 值</strong></h3><p><strong>非空 HTML 特性值应该始终带双引号。</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&#123;width:sidebarWidth+</span>&#x27;<span class="attr">px</span>&#x27;&#125;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: sidebarWidth + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-1-10-指令缩写"><a href="#2-1-10-指令缩写" class="headerlink" title="2.1.10 指令缩写"></a><strong>2.1.10 指令缩写</strong></h3><ul>
<li><strong>用 <code>:</code> 表示 <code>v-bind:</code></strong></li>
<li><strong>用 <code>@</code> 表示 <code>v-on:</code></strong></li>
<li><strong>用 <code>#</code> 表示 <code>v-slot:</code></strong></li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:placeholder</span>=<span class="string">&quot;newTodoInstructions&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-HTML"><a href="#2-2-HTML" class="headerlink" title="2.2 HTML"></a><strong>2.2 HTML</strong></h3><h3 id="2-2-1-文件模板"><a href="#2-2-1-文件模板" class="headerlink" title="2.2.1 文件模板"></a><strong>2.2.1 文件模板</strong></h3><p>HTML5 文件模板：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5标准模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>移动端：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>移动端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>PC 端：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your keywords&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your description&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;author,email address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge,chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>PC端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-2-元素及标签闭合"><a href="#2-2-2-元素及标签闭合" class="headerlink" title="2.2.2 元素及标签闭合"></a><strong>2.2.2 元素及标签闭合</strong></h3><p>HTML 元素共有以下5种：</p>
<ul>
<li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li>
<li>原始文本元素：script、style</li>
<li>RCDATA 元素：textarea、title</li>
<li>外来元素：来自 MathML 命名空间和 SVG 命名空间的元素</li>
<li>常规元素：其他 HTML 允许的元素都称为常规元素</li>
</ul>
<p>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</p>
<ul>
<li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</li>
<li>空元素标签都不加 “&#x2F;” 字符。</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始有终，浏览器能正确解析<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">data-tomark-pass</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始无终，浏览器亦能正确解析</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-3-代码嵌套"><a href="#2-2-3-代码嵌套" class="headerlink" title="2.2.3 代码嵌套"></a><strong>2.2.3 代码嵌套</strong></h3><p>元素嵌套规范，每个块状元素独立一行，内联元素可选。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>段落元素与标题元素只能嵌套内联元素。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-CSS"><a href="#2-3-CSS" class="headerlink" title="2.3 CSS"></a><strong>2.3 CSS</strong></h3><h3 id="2-3-1-样式文件"><a href="#2-3-1-样式文件" class="headerlink" title="2.3.1 样式文件"></a><strong>2.3.1 样式文件</strong></h3><p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>“UTF-8”</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">@charset &quot;UTF-8&quot;;</span><br><span class="line">.jdc &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">/* @charset规则不在文件首行首个字符开始 */</span><br><span class="line">@charset &quot;UTF-8&quot;;</span><br><span class="line">.jdc &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* @charset规则没有用小写 */</span><br><span class="line">@CHARSET &quot;UTF-8&quot;;</span><br><span class="line">.jdc &#123;&#125;</span><br><span class="line"></span><br><span class="line">/* 无@charset规则 */</span><br><span class="line">.jdc &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-2-代码格式化"><a href="#2-3-2-代码格式化" class="headerlink" title="2.3.2 代码格式化"></a><strong>2.3.2 代码格式化</strong></h3><p>样式书写一般有两种：一种是紧凑格式 （Compact），一种是展开格式（Expanded）。</p>
<ul>
<li>推荐：展开格式（Expanded）</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：紧凑格式 （Compact）</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">width</span>: <span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-3-代码大小写"><a href="#2-3-3-代码大小写" class="headerlink" title="2.3.3 代码大小写"></a><strong>2.3.3 代码大小写</strong></h3><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.JDC</span> &#123;</span><br><span class="line">  <span class="attribute">DISPLAY</span>: BLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-4-代码易读性"><a href="#2-3-4-代码易读性" class="headerlink" title="2.3.4 代码易读性"></a><strong>2.3.4 代码易读性</strong></h3><ol>
<li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>逗号分隔的取值，逗号之后一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>, <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>,<span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>为单个 CSS 选择器或新声明开启新行。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;<span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>颜色值 <code>rgb()``rgba()``hsl()``hsla()``rect()</code> 中不需有空格，且取值不要带有不必要的 0。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>属性值十六进制数值能用简写的尽量用简写。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>不要为 <code>0</code> 指明单位。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-5-属性值引号"><a href="#2-3-5-属性值引号" class="headerlink" title="2.3.5 属性值引号"></a><strong>2.3.5 属性值引号</strong></h3><p>CSS 属性值需要用到引号时，统一使用单引号。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Hiragino Sans GB&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Hiragino Sans GB&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-6-属性书写建议"><a href="#2-3-6-属性书写建议" class="headerlink" title="2.3.6 属性书写建议"></a><strong>2.3.6 属性书写建议</strong></h3><p>建议遵循以下顺序：</p>
<ol>
<li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li>
<li>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li>
<li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li>
<li>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background: linear-gradient …</li>
</ol>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, <span class="string">&#x27;Helvetica Neue&#x27;</span>, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-7-CSS3-浏览器私有前缀"><a href="#3-3-7-CSS3-浏览器私有前缀" class="headerlink" title="3.3.7 CSS3 浏览器私有前缀"></a><strong>3.3.7 CSS3 浏览器私有前缀</strong></h3><p>CSS3 浏览器私有前缀在前，标准前缀在后。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-4-JavaScript"><a href="#2-4-JavaScript" class="headerlink" title="2.4 JavaScript"></a><strong>2.4 JavaScript</strong></h3><h3 id="2-4-1-单行代码块"><a href="#2-4-1-单行代码块" class="headerlink" title="2.4.1 单行代码块"></a><strong>2.4.1 单行代码块</strong></h3><p>在单行代码块中使用空格。</p>
<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;bar = <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123; bar = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-4-2-大括号风格"><a href="#2-4-2-大括号风格" class="headerlink" title="2.4.2 大括号风格"></a><strong>2.4.2 大括号风格</strong></h3><p>在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</p>
<ul>
<li><strong>【推荐】One True Brace Style</strong></li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Stroustrup</strong></li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Allman</strong></li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-4-3-代码中的空格"><a href="#2-4-3-代码中的空格" class="headerlink" title="2.4.3 代码中的空格"></a><strong>2.4.3 代码中的空格</strong></h3><ol>
<li>逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>, bar = <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>,bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> , bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> ,bar = <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span> : <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>代码块前要添加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> (<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)&#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> (<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>函数声明括号前要加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>在函数调用时，禁止使用空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span> ()</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span></span><br><span class="line">()</span><br></pre></td></tr></table></figure></div>

<ol>
<li>在操作符前后都需要添加空格。</li>
</ol>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<h2 id="三、注释规范"><a href="#三、注释规范" class="headerlink" title="三、注释规范"></a><strong>三、注释规范</strong></h2><p><strong>注释的目的：</strong></p>
<ul>
<li><strong>提高代码的可读性，从而提高代码的可维护性</strong></li>
</ul>
<p><strong>注释的原则：</strong></p>
<ul>
<li><strong>如无必要，勿增注释 ( As short as possible )</strong></li>
<li><strong>如有必要，尽量详尽 ( As long as necessary )</strong></li>
</ul>
<h3 id="3-1-HTML-文件注释"><a href="#3-1-HTML-文件注释" class="headerlink" title="3.1 HTML 文件注释"></a><strong>3.1 HTML 文件注释</strong></h3><h3 id="3-1-1-单行注释"><a href="#3-1-1-单行注释" class="headerlink" title="3.1.1 单行注释"></a><strong>3.1.1 单行注释</strong></h3><p><strong>一般用于简单的描述，如某些状态描述、属性描述等。</strong></p>
<p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-1-2-模块注释"><a href="#3-1-2-模块注释" class="headerlink" title="3.1.2 模块注释"></a><strong>3.1.2 模块注释</strong></h3><p><strong>一般用于描述模块的名称以及模块开始与结束的位置。</strong></p>
<p>注释内容前后各一个空格字符， <code>&lt;!-- S Comment Text \--&gt;</code>表示模块开始， <code>&lt;!-- E Comment Text \--&gt;</code>表示模块结束，模块与模块之间相隔一行。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐</li>
</ul>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-1-3-嵌套模块注释"><a href="#3-1-3-嵌套模块注释" class="headerlink" title="3.1.3 嵌套模块注释"></a><strong>3.1.3 嵌套模块注释</strong></h3><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text --&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>而改用</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&lt;!-- /Comment Text --&gt;</span><br></pre></td></tr></table></figure></div>

<p>注释写在模块结尾标签底部，单独一行。</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_b --&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_c&quot;</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_c --&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-CSS-文件注释"><a href="#3-2-CSS-文件注释" class="headerlink" title="3.2 CSS 文件注释"></a><strong>3.2 CSS 文件注释</strong></h3><h3 id="3-2-1-单行注释"><a href="#3-2-1-单行注释" class="headerlink" title="3.2.1 单行注释"></a><strong>3.2.1 单行注释</strong></h3><p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Comment Text*/</span></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;<span class="comment">/*Comment Text*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-2-模块注释"><a href="#3-2-2-模块注释" class="headerlink" title="3.2.2 模块注释"></a><strong>3.2.2 模块注释</strong></h3><p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与 模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Module A</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module B</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Module A ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* Module B ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-2-3-文件注释"><a href="#3-2-3-文件注释" class="headerlink" title="3.2.3 文件注释"></a><strong>3.2.3 文件注释</strong></h3><p>在样式文件编码声明 <code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc File Info</span></span><br><span class="line"><span class="comment"> * @author Author Name</span></span><br><span class="line"><span class="comment"> * @date 2015-10-10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-JavaScript-文件注释"><a href="#3-3-JavaScript-文件注释" class="headerlink" title="3.3 JavaScript 文件注释"></a><strong>3.3 JavaScript 文件注释</strong></h3><h3 id="3-3-1-单行注释"><a href="#3-3-1-单行注释" class="headerlink" title="3.3.1 单行注释"></a><strong>3.3.1 单行注释</strong></h3><p>单行注释使用 <code>//</code>，注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span> <span class="comment">// is current tab</span></span><br></pre></td></tr></table></figure></div>

<p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> (<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释行上面是一个块的顶部时不需要空行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> (<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span>   </span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> (<span class="params"></span>) &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-2-多行注释"><a href="#3-3-2-多行注释" class="headerlink" title="3.3.2 多行注释"></a><strong>3.3.2 多行注释</strong></h3><p>多行注释使用 <code>/** ... */</code>，而不是多行的 <code>//</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (<span class="params">tag</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (<span class="params">tag</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-3-注释空格"><a href="#3-3-3-注释空格" class="headerlink" title="3.3.3 注释空格"></a><strong>3.3.3 注释空格</strong></h3><p>注释内容和注释符之间需要有一个空格，以增加可读性。eslint: <code>spaced-comment</code>。</p>
<ul>
<li>推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>不推荐：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *make() returns a new element</span></span><br><span class="line"><span class="comment"> *based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-4-特殊标记"><a href="#3-3-4-特殊标记" class="headerlink" title="3.3.4 特殊标记"></a><strong>3.3.4 特殊标记</strong></h3><p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p>
<ul>
<li><p><code>// FIXME</code> : 说明问题是什么</p>
</li>
<li><ul>
<li><code>// TODO</code> : 说明还要做什么或者问题的解决方案</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Abacus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span> ()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> shouldn’t use a global here</span></span><br><span class="line">      total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> total should be configurable by an options param</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-5-文档类注释"><a href="#3-3-5-文档类注释" class="headerlink" title="3.3.5 文档类注释"></a><strong>3.3.5 文档类注释</strong></h3><p>文档类注释，如函数、类、文件、事件等；都使用 jsdoc 规范。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Book类，代表一个书本.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">title</span> - 书本的标题.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">author</span> - 书本的作者.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span> (<span class="params">title, author</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">author</span> = author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取书本的标题</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">string|*</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">getTitle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置书本的页数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pageNum &#123;number&#125; 页数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">setPageNum</span>: <span class="keyword">function</span> (<span class="params">pageNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pageNum</span>=pageNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-3-6-注释工具"><a href="#3-3-6-注释工具" class="headerlink" title="3.3.6 注释工具"></a><strong>3.3.6 注释工具</strong></h3><p><code>ESLint</code> 是当下最流行的 JS 代码检查工具，<code>ESLint</code> 中有一些注释相关的规则，用户可选择开启：</p>
<ul>
<li><code>valid-jsdoc</code></li>
<li><code>require-jsdoc</code></li>
<li><code>no-warning-comments</code></li>
<li><code>capitalized-comments</code></li>
<li><code>line-comment-position</code></li>
<li><code>lines-around-comment</code></li>
<li><code>multiline-comment-style</code></li>
<li><code>no-inline-comments</code></li>
<li><code>spaced-comment</code></li>
</ul>
<h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a><strong>四、其它</strong></h2><ul>
<li><p>缩进换行请使用两个空格。</p>
</li>
<li><p>大型团队多人协作项目推荐 JavaScript 代码末尾加分号。</p>
</li>
<li><p>小型个人创新练手项目可尝试使用 JavaScript 代码末尾不加分号的风格，更加清爽简练。</p>
</li>
</ul>
<p>参考文章：</p>
<blockquote>
<p>知乎：<a class="link"   href="https://zhuanlan.zhihu.com/p/437632696?utm_id=0" >https://zhuanlan.zhihu.com/p/437632696?utm_id=0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>setup中如何使用mapState</title>
    <url>/2020/02/28/Vue/vue-cli%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="开发环境、测试环境、生产环境"><a href="#开发环境、测试环境、生产环境" class="headerlink" title="开发环境、测试环境、生产环境"></a>开发环境、测试环境、生产环境</h2><p>1.开发环境，创建.env.development文件</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">VUE_APP_BASEURL=<span class="string">&quot;http://192.168.0.136:8088&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>2.测试环境，创建.env.test文件</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">VUE_APP_BASEURL=<span class="string">&quot;http://test.baidu.com&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>3.生产环境，创建.env.production文件</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">VUE_APP_BASEURL=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="package-json文件的配置"><a href="#package-json文件的配置" class="headerlink" title="package.json文件的配置"></a>package.json文件的配置</h2><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service serve&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-cli-service build --mode test&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></div>



<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>1.打生产包</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></div>

<p>2.打测试包</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>



<h2 id="打包后的dist目录如何启动？"><a href="#打包后的dist目录如何启动？" class="headerlink" title="打包后的dist目录如何启动？"></a>打包后的dist目录如何启动？</h2><p>安装web 服务</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g serve</span><br></pre></td></tr></table></figure></div>

<p>启动</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">serve dist</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3实现遮罩层外部禁止页面滚动，内部可滚动</title>
    <url>/2020/02/28/Vue/vue3%E5%AE%9E%E7%8E%B0%E9%81%AE%E7%BD%A9%E5%B1%82%E5%A4%96%E9%83%A8%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%EF%BC%8C%E5%86%85%E9%83%A8%E5%8F%AF%E6%BB%9A%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p>方法一：直接在遮罩层添加 <code>@touchmove.prevent</code> ，就可以实现禁止页面滚动，但是同时遮罩层内部也无法滚动了，适用于内部不需滚动的场景。</p>
</blockquote>
<blockquote>
<p>方法二：(此方法可以实现需求，但是关闭遮罩层后主页面会滑动到顶部，无法回到原来的浏览位置)</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> mo = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//禁止滚动-在显示遮罩层的时候调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopScroll</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;touchmove&quot;</span>, mo, <span class="literal">false</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 取消滑动限制-在关闭遮罩层的时候调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resetScroll</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">overflow</span> = <span class="string">&#x27;&#x27;</span>;<span class="comment">//出现滚动条</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;touchmove&quot;</span>, mo, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>方法三：（推荐：此方法不仅可以实现需求，还会记录打开遮罩层时的位置，使关闭后仍然停在原来的位置）</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录页面滚动位置</span></span><br><span class="line"><span class="keyword">const</span> pageLocation = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止滚动-在显示遮罩层的时候调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopScroll</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> scrollTop = <span class="variable language_">window</span>.<span class="property">scrollY</span>;<span class="comment">//滚动的高度；</span></span><br><span class="line">    pageLocation.<span class="property">value</span> = scrollTop;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&#x27;-&#x27;</span> + scrollTop + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消滑动限制-在关闭遮罩层的时候调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resetScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;static&#x27;</span>;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, pageLocation.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简单的vue</title>
    <url>/2022/10/28/Vue/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84vue/</url>
    <content><![CDATA[<p>首先我们创建一个<code>index.html</code>文件，引入自定义的<code>my-vue.js</code>，然后实例化对象，并传人对象参数</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; str &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./my-vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">str</span>: <span class="string">&#x27;你好🎉&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&#x27;jiangwen&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">handleClick</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">str</span> = <span class="string">&#x27;hello👋&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">str</span>, <span class="variable language_">this</span>.<span class="property">$data</span>.<span class="property">str</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p> 创建一个Vue类</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="模版解析"><a href="#模版解析" class="headerlink" title="模版解析"></a>模版解析</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">+     <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">+  	<span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">+      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">+            <span class="comment">// 节点类型</span></span><br><span class="line">+            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">+                <span class="keyword">if</span> (e.<span class="property">childNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">+                    <span class="variable language_">this</span>.<span class="title function_">compile</span>(e) <span class="comment">//递归调用</span></span><br><span class="line">+                &#125;</span><br><span class="line">+            &#125;</span><br><span class="line">+            <span class="comment">// 文本类型</span></span><br><span class="line">+            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">+                <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span></span><br><span class="line">+                <span class="keyword">const</span> text = e.<span class="property">textContent</span></span><br><span class="line">+                e.<span class="property">textContent</span> = text.<span class="title function_">replace</span>(reg, <span class="function">(<span class="params">match, vmKey</span>) =&gt;</span> &#123;</span><br><span class="line">+                    vmKey = vmKey.<span class="title function_">trim</span>()</span><br><span class="line">+                    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[vmKey]</span><br><span class="line">+                &#125;)</span><br><span class="line">+            &#125;</span><br><span class="line">+        &#125;)</span><br><span class="line">+    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 实例创建前钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">beforeCreate</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建数据 </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">proxyData</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">observe</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$watchEvent</span> = &#123;&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span><br><span class="line">        <span class="comment">// 2. 实例创建完成钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">created</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">created</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. dom挂载前钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">beforeMount</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">beforeMount</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂载dom</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">        <span class="comment">// 模版解析</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">        <span class="comment">// 4.dom挂载完成钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">mounted</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">mounted</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a>添加事件</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 节点类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.<span class="property">childNodes</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">compile</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line">+                <span class="comment">// 判断节点元素是否有@click</span></span><br><span class="line">+                <span class="keyword">if</span> (e.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">+                    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>));</span><br><span class="line">+                    <span class="comment">// 获取事件名称</span></span><br><span class="line">+                    <span class="keyword">const</span> vmKey = e.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">+                    e.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">+                        <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="property">$methods</span>[vmKey].<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">+                        <span class="title function_">fn</span>(event)</span><br><span class="line">+                    &#125;)</span><br><span class="line">+                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 文本类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="数据驱动视图更新"><a href="#数据驱动视图更新" class="headerlink" title="数据驱动视图更新"></a>数据驱动视图更新</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 实例创建前钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">beforeCreate</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建数据 </span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span></span><br><span class="line">+       <span class="variable language_">this</span>.<span class="title function_">proxyData</span>()</span><br><span class="line">+       <span class="variable language_">this</span>.<span class="title function_">observe</span>()</span><br><span class="line">+       <span class="variable language_">this</span>.<span class="property">$watchEvent</span> = &#123;&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$methods</span> = options.<span class="property">methods</span></span><br><span class="line">        <span class="comment">// 2. 实例创建完成钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">created</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">created</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. dom挂载前钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">beforeMount</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">beforeMount</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 挂载dom</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">        <span class="comment">// 模版解析</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">compile</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">        <span class="comment">// 4.dom挂载完成钩子🪝</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">mounted</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            options.<span class="property">mounted</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 节点类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 文本类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span></span><br><span class="line">                <span class="keyword">const</span> text = e.<span class="property">textContent</span></span><br><span class="line">                e.<span class="property">textContent</span> = text.<span class="title function_">replace</span>(reg, <span class="function">(<span class="params">match, vmKey</span>) =&gt;</span> &#123;</span><br><span class="line">                    vmKey = vmKey.<span class="title function_">trim</span>()</span><br><span class="line">+                   <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">hasOwnProperty</span>(vmKey)) &#123;</span><br><span class="line">+                       <span class="keyword">let</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, vmKey, e, <span class="string">&#x27;textContent&#x27;</span>)</span><br><span class="line">+                        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$watchEvent</span>[vmKey])&#123;</span><br><span class="line">+                          <span class="variable language_">this</span>.<span class="property">$watchEvent</span>[vmKey].<span class="title function_">push</span>(watcher)</span><br><span class="line">+                       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+                           <span class="variable language_">this</span>.<span class="property">$watchEvent</span>[vmKey] = []</span><br><span class="line">+                           <span class="variable language_">this</span>.<span class="property">$watchEvent</span>[vmKey].<span class="title function_">push</span>(watcher)</span><br><span class="line">+                       &#125;</span><br><span class="line">+                   &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[vmKey]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同步数据（保持vue实例对象属性和data中的属性同步，可以直接使用this.xxx获取数据）</span></span><br><span class="line">+    <span class="title function_">proxyData</span>(<span class="params"></span>) &#123;</span><br><span class="line">+        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">+            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">+                <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">+                    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">+                &#125;,</span><br><span class="line">+                <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">+                    <span class="variable language_">this</span>.<span class="property">$data</span>[key] = val</span><br><span class="line">+                &#125;</span><br><span class="line">+            &#125;)</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">    <span class="comment">// 观察者(监控this.$data的所有值)</span></span><br><span class="line">+    <span class="title function_">observe</span>(<span class="params"></span>)&#123;</span><br><span class="line">+        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">+           <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">+           <span class="keyword">const</span> _this = <span class="variable language_">this</span></span><br><span class="line">+          <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">+                <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">+                    <span class="keyword">return</span> value</span><br><span class="line">+                &#125;,</span><br><span class="line">+                <span class="title function_">set</span>(<span class="params">val</span>)&#123;</span><br><span class="line">+                    value = val</span><br><span class="line">+                    <span class="keyword">if</span>(_this.<span class="property">$watchEvent</span>[key])&#123;</span><br><span class="line">+                        <span class="comment">// 所有使用该属性值的元素都执行节点更新</span></span><br><span class="line">+                        _this.<span class="property">$watchEvent</span>[key].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">+                            item.<span class="title function_">update</span>()</span><br><span class="line">+                        &#125;)</span><br><span class="line">+                    &#125;</span><br><span class="line">+               &#125;</span><br><span class="line">+           &#125;)</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">+    <span class="title function_">constructor</span>(<span class="params">vm, key, node, attr</span>)&#123;</span><br><span class="line">+        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">+        <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">+        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">+        <span class="variable language_">this</span>.<span class="property">attr</span> = attr</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="comment">// 更新节点的内容</span></span><br><span class="line">+    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">+        <span class="variable language_">this</span>.<span class="property">node</span>[<span class="variable language_">this</span>.<span class="property">attr</span>] = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">+   &#125;</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 节点类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line"> 								...</span><br><span class="line">+               <span class="comment">// 判断节点元素是否有v-model</span></span><br><span class="line">+               <span class="keyword">if</span>(e.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>))&#123;</span><br><span class="line">+                   <span class="keyword">const</span> vmkey = e.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">+                   <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">hasOwnProperty</span>(vmkey))&#123;</span><br><span class="line">+                       e.<span class="property">value</span> = <span class="variable language_">this</span>[vmkey] <span class="comment">// 将数据赋值给有v-model的节点</span></span><br><span class="line">+                   &#125;</span><br><span class="line">+                   <span class="comment">// 监听元素input事件，赋值</span></span><br><span class="line">+                   e.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">+                       <span class="variable language_">this</span>[vmkey] = e.<span class="property">value</span></span><br><span class="line">+                   &#125;)</span><br><span class="line">+               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 文本类型</span></span><br><span class="line">            <span class="keyword">if</span> (e.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>数据更新但视图不刷新的解决方法</title>
    <url>/2020/02/28/Vue/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BD%86%E8%A7%86%E5%9B%BE%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>前言: 在开发中我们处理数据时会遇到数据更新了,但视图并没有更新的情况。</p>
</blockquote>
<h4 id="一般有以下几种情况会导致该问题："><a href="#一般有以下几种情况会导致该问题：" class="headerlink" title="一般有以下几种情况会导致该问题："></a>一般有以下几种情况会导致该问题：</h4><ol>
<li><strong>动态给对象新增属性或者删除属性</strong></li>
<li><strong>通过数组下标修改数组中的元素或者手动修改数组的长度</strong></li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3>   <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;p v-if=&#x27;show&#x27;&gt;&#123;&#123;obj.a&#125;&#125; | &#123;&#123;obj.b&#125;&#125;&lt;p&gt;</span><br><span class="line">  &lt;button @click=&quot;handleTest&quot;&gt;change&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    	show: true,</span><br><span class="line">      obj:&#123;a:123&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">   handleTest()&#123;</span><br><span class="line">     this.obj.b = 456</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p><strong>静默刷新(使用v-if的特性):</strong> 在修改值之后将元素销毁,然后在修改后的下一次DOM渲染完成时再显示出来,这样就会触发组件重新加载data的数据进行渲染,data中被修改的数据才是最新的。</p>
 <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handleTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">b</span> = <span class="number">456</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">show</span> = <span class="literal">false</span></span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">show</span> = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>Vue.$set(官方推荐):</strong>  使用这个api修改的数据会为其添加响应式getter和setter让其拥有数据响应的特性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vm.set(要操作的对象或数组, 要新增或者修改的数组或对象key, 对应的值)</span></span><br><span class="line"> <span class="title function_">handleTest</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.$set(<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">456</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>Vue.$forceUpdate(手动强制更新视图):</strong> 因为Vue修改数据是异步执行的,所以视图不会立即更新,会等到下一次dom更新循环结束后统一更新发生在这一次循环中修改的数据,然后同步视图更新,所以我们可以修改后自己手动强制更新视图。</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTest()&#123;</span><br><span class="line">  this.obj.b =456</span><br><span class="line">  this.$forceUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><strong>Object.assign(使用修改栈能触发视图更新的特性)</strong></p>
 <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">obj</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, &#123;...<span class="variable language_">this</span>.<span class="property">obj</span>, <span class="attr">b</span>: <span class="number">456</span>&#125;)</span><br></pre></td></tr></table></figure></div>



</li>
<li><p><strong>对于数组还可以使用splice方法:</strong>  Vue对于数组的操作能识别变化的api包括push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些都可被vue监测到</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>10万级数据渲染优化方案</title>
    <url>/2021/11/18/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/10%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>假设我们需要在页面上加载获取到的10万条数据📊，在不采取优化方案的情况下它的耗时为 482 ms</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">getList</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">resolve</span>()</span></span><br><span class="line"><span class="language-javascript">              &#125;, <span class="number">200</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">let</span> arr = []</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                  arr[i] = &#123; <span class="attr">id</span>: i, <span class="attr">text</span>: i &#125;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">return</span> arr</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 不优化情况：</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">renderList</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">getList</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;不优化&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">              res.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">                  div.<span class="property">innerHTML</span> = <span class="string">`&lt;span&gt;<span class="subst">$&#123;item.text&#125;</span>&lt;/span&gt;`</span></span></span><br><span class="line"><span class="language-javascript">                  container.<span class="title function_">appendChild</span>(div)</span></span><br><span class="line"><span class="language-javascript">              &#125;);</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;不优化&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>



<p>如果使用了<strong>分页优化</strong>后的耗时为212 ms</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 优化情况(分页 + requestAnimationFrame + createDocumentFragment)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderList2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;分页优化&#x27;</span>)</span><br><span class="line">  <span class="title function_">getList</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> total = res.<span class="property">length</span> <span class="comment">// 总条数</span></span><br><span class="line">    <span class="keyword">const</span> limit = <span class="number">10000</span> <span class="comment">// 每页数量</span></span><br><span class="line">    <span class="keyword">const</span> page = <span class="number">0</span> <span class="comment">// 起始页</span></span><br><span class="line">    <span class="keyword">const</span> totalPage = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(total / limit)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">page</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(totalPage&lt;= page)<span class="keyword">return</span></span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="function">()=&gt;</span>&#123; <span class="comment">// requestAnimationFrame减少重排</span></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>() <span class="comment">// 文档碎片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = page * limit; i &lt; page * limit + limit; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> item = res[i];</span><br><span class="line">          <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">          div.<span class="property">innerHTML</span> = <span class="string">`&lt;span&gt;<span class="subst">$&#123; item.text &#125;</span>&lt;/span&gt;`</span></span><br><span class="line">          fragment.<span class="title function_">appendChild</span>(div)</span><br><span class="line">        &#125;</span><br><span class="line">        container.<span class="title function_">appendChild</span>(fragment)</span><br><span class="line">        <span class="title function_">render</span>(page + <span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(page)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;分页优化&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果dom结构更复杂，差距将更大</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP报文结构分析</title>
    <url>/2021/01/01/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>HTTP请求报文由请求行、请求头、空行和请求内容4个部分构成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1556086946814.png"
                      alt="1556086946814"
                ></p>
<h3 id="请求行："><a href="#请求行：" class="headerlink" title="请求行："></a>请求行：</h3><p>请求行由请求方法字段、URL字段、协议版本字段三部分构成，字段之间由空格隔开</p>
<p>常用的请求方法有：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</p>
<h3 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h3><p>请求头由key&#x2F;value对组成，每行为一对，key和value之间通过冒号(:)分割。</p>
<p>请求头的作用主要是用于通知服务端有关于客户端的请求信息</p>
<p>常见的请求头(Request Headers)有:</p>
<ul>
<li><strong>User-Agent：</strong>生成请求的浏览器类型</li>
<li><strong>Accept：</strong>客户端可识别的响应内容类型列表；星号*用于按范围将类型分组</li>
<li><strong>Accept-Language:</strong>  客户端可接受的自然语言</li>
<li><strong>Accept-Encoding:</strong>  客户端可接受的编码压缩格式</li>
<li><strong>Accept-Charset：</strong> 可接受的字符集</li>
<li><strong>Host:</strong> 请求的主机名，允许多个域名绑定同一IP地址</li>
<li><strong>connection：</strong>连接方式（close或keeplive）</li>
<li><strong>Cookie:</strong>  存储在客户端的扩展字段</li>
</ul>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行:"></a>空行:</h3><p>最后一个请求头之后就是空行，用于告诉服务端以下内容不再是请求头的内容了。</p>
<h3 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容:"></a>请求内容:</h3><p>请求内容主要用于POST请求，与POST请求方法配套的请求头一般有Content-Type（标识请求内容的类型）和Content-Length（标识请求内容的长度）</p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>HTTP响应报文由状态行、响应头、空行和响应内容4个部分构成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1556087134966.png"
                      alt="1556087134966"
                ></p>
<h3 id="状态行："><a href="#状态行：" class="headerlink" title="状态行："></a>状态行：</h3><p>由HTTP协议版本、状态码、状态码描述三部分构成，它们之间由空格隔开</p>
<p>状态码由3位数字组成，第一位标识响应的类型，常用的5大类状态码如下：</p>
<ul>
<li>1xx：表示服务器已接收了客户端的请求，客户端可以继续发送请求	</li>
<li>2xx：表示服务器已成功接收到请求并进行处理</li>
<li>3xx：表示服务器要求客户端重定向</li>
<li>4xx：表示客户端的请求有非法内容</li>
<li>5xx：标识服务器未能正常处理客户端的请求而出现意外错误</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头:"></a>响应头:</h3><p>一般情况下，响应头会包含以下，甚至更多的信息。</p>
<p>Location：服务器返回给客户端，用于重定向到新的位置</p>
<p>Server： 包含服务器用来处理请求的软件信息及版本信息</p>
<p>Vary：标识不可缓存的请求头列表</p>
<p>Connection: 连接方式。</p>
<p>对于请求端来讲：close是告诉服务端，断开连接，不用等待后续的求请了。keep-live则是告诉服务端，在完成本次请求的响应后，保持连接，等待本次连接后的后续请求。</p>
<p>对于响应端来讲：close表示连接已经关闭。keeplive则表示连接保持中，可以继续处理后续请求。Keep-Alive表示如果请求端保持连接，则该请求头部信息表明期望服务端保持连接多长时间（秒），例如300秒，应该这样写Keep-Alive: 300</p>
<h3 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h3><p>最后一个响应头之后就是空行，用于告诉请求端以下内容不再是响应头的内容了。</p>
<h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>服务端返回给请求端的文本信息。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>URL的输入到浏览器解析</title>
    <url>/2021/01/01/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/URL%E7%9A%84%E8%BE%93%E5%85%A5%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>URL的输入到浏览器解析，一般分为以下几个步骤：</p>
<ul>
<li>DNS解析</li>
<li>发起TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<p>下面我们来看看具体的细节….</p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS解析实际上就是寻找你所需要的资源的过程。假设你输入<code>www.baidu.com</code>，而这个网址并不是百度的真实地址，互联网中每一台机器都有唯一标识的IP地址，这个才是关键，但是它不好记，乱七八糟一串数字谁记得住啊，所以就需要一个网址和IP地址的转换，也就是DNS解析。下面看看具体的解析过程</p>
<h3 id="具体解析"><a href="#具体解析" class="headerlink" title="具体解析"></a>具体解析</h3><p>DNS解析其实是一个递归的过程 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-gold-cdn.xitu.io/2019/4/28/16a634c9285cb545?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"
                      alt="DNS解析"
                ></p>
<p> 输入<code>www.google.com</code>网址后，首先在本地的域名服务器中查找，没找到去<code>.</code>根域名服务器查找，没有再去<code>com</code>顶级域名服务器查找，如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用。大致过程就是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">. =&gt; .com =&gt; google.com. =&gt; www.google.com.</span><br></pre></td></tr></table></figure></div>


<p>(这个<code>.</code>对应的就是根域名服务器，默认情况下网址的最后一位都是<code>.</code>，通常都会省略，浏览器在请求DNS的时候会自动加上)</p>
<h3 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h3><p>既然已经懂得了解析的具体过程，我们可以看到上述一共经过了N个过程，每个过程有一定的消耗和时间的等待，因此我们得想办法解决一下这个问题！</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<ul>
<li>在你的chrome浏览器中输入:chrome:&#x2F;&#x2F;net-internals&#x2F;#dns，你可以看到chrome浏览器的DNS缓存。</li>
<li>系统缓存主要存在&#x2F;etc&#x2F;hosts(Linux系统)中</li>
</ul>
<h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>不知道你们有没有注意这样一件事，你访问<code>baidu.com</code>的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡</p>
<h2 id="发起TCP连接"><a href="#发起TCP连接" class="headerlink" title="发起TCP连接"></a>发起TCP连接</h2><p>TCP提供一种可靠的传输，这个过程涉及到三次握手，四次挥手，下面我们详细看看 TCP提供一种面向连接的，可靠的字节流服务。 其首部的数据格式如下 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://user-gold-cdn.xitu.io/2019/4/28/16a634dbf162e53c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"
                      alt="TCP首部"
                ></p>
<h3 id="字段分析"><a href="#字段分析" class="headerlink" title="字段分析"></a>字段分析</h3><ul>
<li>源端口：源端口和IP地址的作用是标识报文的返回地址。</li>
<li>目的端口：端口指明接收方计算机上的应用程序接口。</li>
</ul>
<blockquote>
<p>TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>
</blockquote>
<ul>
<li>序号：是TCP可靠传输的关键部分。序号是该报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节都有一个序号。比如一个报文段的序号为300，报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。</li>
<li>确认号：即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</li>
<li>首部长度&#x2F;数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32&#x2F;8&#x3D;60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</li>
<li>保留：占6位，保留今后使用，但目前应都位0。</li>
<li>控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。<ul>
<li>紧急URG：当URG&#x3D;1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据</li>
<li>确认ACK：仅当ACK&#x3D;1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。</li>
<li>推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH&#x3D;1。</li>
<li>复位RST：当RST&#x3D;1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。</li>
<li>同步SYN：在连接建立时用来同步序号。当SYN&#x3D;1，ACK&#x3D;0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN&#x3D;1，ACK&#x3D;1。</li>
<li>终止FIN：用来释放连接。当FIN&#x3D;1，表明此报文的发送方的数据已经发送完毕，并且要求释放。</li>
</ul>
</li>
<li>窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</li>
<li>校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</li>
<li>紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</li>
<li>数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ul>
<blockquote>
<p>需要注意的是： </p>
<p>（A）<strong>不要将确认序号ack与标志位中的ACK搞混了。</strong> </p>
<p>（B）<strong>确认序号ack&#x3D;发起方Req+1，两端配对。</strong></p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><h5 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h5><p>客户端发送syn包(Seq&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<h5 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h5><p>服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（Seq&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<h5 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h5><p>客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"
                      alt="img"
                ></p>
<h5 id="为什么会采用三次握手，若采用二次握手可以吗？-四次呢？"><a href="#为什么会采用三次握手，若采用二次握手可以吗？-四次呢？" class="headerlink" title="为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？"></a>为什么会采用三次握手，若采用二次握手可以吗？ 四次呢？</h5><p>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。</p>
<p>采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p>
<p>采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client和server都有一个发syn和收ack的过程， 双方都是发后能收， 表明通信则准备工作OK.</p>
<p>为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，假设客户端主动关闭，服务器被动关闭。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"
                      alt="img"
                ></p>
<h5 id="第一次挥手："><a href="#第一次挥手：" class="headerlink" title="第一次挥手："></a>第一次挥手：</h5><p>客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可 以接受数据。 FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<h5 id="第二次挥手："><a href="#第二次挥手：" class="headerlink" title="第二次挥手："></a>第二次挥手：</h5><p>服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
<h5 id="第三次挥手："><a href="#第三次挥手：" class="headerlink" title="第三次挥手："></a>第三次挥手：</h5><p>服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<h5 id="第四次挥手："><a href="#第四次挥手：" class="headerlink" title="第四次挥手："></a>第四次挥手：</h5><p>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<p>至此，完成四次挥手。</p>
<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><ul>
<li><h4 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h4><p>  保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
</li>
<li><h4 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h4><p>  建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
</li>
<li><h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</li>
</ul>
<h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由<strong>请求行</strong>，<strong>请求报头</strong>，<strong>请求正文</strong>组成。</p>
<p><em>tips:HTTP的端口为80&#x2F;8080，而HTTPS的端口为443</em></p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行的格式为<code>Method Request-URL HTTP-Version CRLF</code> <code>eg: GET index.html HTTP/1.1</code> 常用的方法有: <code>GET</code>,<code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>HEAD</code>。</p>
<h4 id="常见的请求方法区别"><a href="#常见的请求方法区别" class="headerlink" title="常见的请求方法区别"></a>常见的请求方法区别</h4><p><code>POST</code>和<code>GET</code>的主要区别</p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST么有</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>★ GET<code>会产生一个</code>TCP<code>数据包，而</code>POST<code>会产生两个</code>TCP&#96;数据包（Firefox就发送一次）</li>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目优化经验总结</title>
    <url>/2022/04/16/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/vue%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>前言：首先可以通过安装 <code>npm i webpack-bundle-analyzer</code>插件，在webpack中引入并配置后，执行<code>npm run build</code>打包构建后，浏览器会自动打开分析结果	</p>
</blockquote>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">   <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;webpack-report&#x27;</span>).<span class="title function_">use</span>(<span class="title class_">BundleAnalyzerPlugin</span>, [&#123; </span><br><span class="line">       <span class="attr">analyzerMode</span>: <span class="string">&#x27;static&#x27;</span> &#125;])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Users/jiangwen/Downloads/_Users_jiangwen_GitHub_admin_dist_report.html%20(1).png"
                      alt="_Users_jiangwen_GitHub_admin_dist_report.html (1)"
                ></p>
<p>可以根据得到的分析结果，对项目进行有针对性的优化…</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ol>
<li><p>路由懒加载</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>: [</span><br><span class="line">		&#123;<span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)	&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>图片懒加载：可以使用 <code>vue-lazyload</code> 插件</p>
</li>
</ol>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><ol>
<li>使用<code>keep-alive</code>缓存组件</li>
</ol>
<h2 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h2><ol>
<li>按需引入UI组件库</li>
<li>开启<code>gzip</code>打包压缩</li>
<li>关闭源码映射，不生成<code>sourcemap</code>文件</li>
</ol>
<h2 id="首屏优化"><a href="#首屏优化" class="headerlink" title="首屏优化"></a>首屏优化</h2><ol>
<li><p>数据加载使用loding骨架屏</p>
</li>
<li><p>采用<strong>SSR</strong>服务端渲染</p>
</li>
</ol>
<h2 id="代码层面的优化"><a href="#代码层面的优化" class="headerlink" title="代码层面的优化"></a>代码层面的优化</h2><ol>
<li><p>避免<code>v-if</code> 和 <code>v-for</code> 同级使用，在vue2 中 v-for 的 优先级比 v-if 高，容易导致渲染错误</p>
</li>
<li><p>使用<code>v-for</code>时设置key的值，并且使用数据中的唯一标识，尽量不使用index作为标识，有利于dom定位和diff算法</p>
</li>
<li><p>根据场景合理选择使用<code>v-if</code> 或 <code>v-show</code></p>
</li>
<li><p>将无状态的<strong>组件标记为函数式组件</strong>（静态组件）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只接收父组件传过来的值，自己不做处理，无状态，不创建实例 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;page&quot;&gt;</span><br><span class="line">   	&lt;span v-if=&#x27;prop.show&#x27;&gt;1&lt;span&gt;</span><br><span class="line">    &lt;span v-else&gt;2&lt;span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default&#123;</span><br><span class="line">  	props: [&#x27;show&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>事件销毁</strong>：Vue组件在销毁时，会自动解绑它的全部指令事件及监听器，但仅限于组件本身。<br>比如定时器等最好在销毁阶段手动销毁，避免内存泄漏</p>
</li>
<li><p><strong>子组件分割</strong>：将子组件中耗时的任务交给组件自己管理，不影响整体页面的加载</p>
</li>
<li><p><strong>变量本地化</strong>：减少使用 <code>this.xxx</code> 的形式获取数据，可以用一个变量先获取数据，然后在这个变量上处理数据。</p>
</li>
<li><p><strong>模块化、组件化</strong></p>
</li>
<li><p>长列表优化（插件：vue-virtual-scroller ）</p>
<ol>
<li>纯粹做数据展示，不需要热更新的场景🎬：处于data中的数据会被监视，发生变化时数据就发生变化<br>所以采用object.freeze（数据）方法冻结数据。</li>
<li>采用虚拟滚动，只渲染视口部分的数据，也就是说渲染固定的DOM节点个数</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>优化， gzip</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Vercel 的无服务器函数</title>
    <url>/2020/02/28/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E4%BD%BF%E7%94%A8%20Vercel%20%E7%9A%84%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>前言：使用 Vercel，您可以部署无服务器函数，这是使用 NodeJS 等后端语言编写的代码片段，它们接受 HTTP 请求并提供响应。</p>
<p>您可以使用无服务器函数来处理用户身份验证、表单提交、数据库查询、自定义 Slack 命令等。</p>
<p>在本文中，我们将使用 NodeJS 创建一个简单的无服务器函数，然后将其部署在 Vercel 中。</p>
<h2 id="使用-API-端点创建项目"><a href="#使用-API-端点创建项目" class="headerlink" title="使用 API 端点创建项目"></a>使用 API 端点创建项目</h2><p>初始化项目<code>npm</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure></div>



<p>现在我们需要创建一个名为 API 端点文件所在的文件夹。<code>/api</code></p>
<p>在此示例中，我们将创建一个名为 的文件，其中包含以下内容：<code>hello.js</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        hola: &#x27;mundo&#x27;    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>您的项目现在如下所示</p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Uk9-PbbN--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vm5or9mb9q1qf5hcyw6w.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--Uk9-PbbN--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vm5or9mb9q1qf5hcyw6w.png"
                      alt="VSCode"
                ></a></p>
<p>在此示例中，我们的终端节点服务将使用具有以下结构的 JSON 进行响应：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    hola: &#x27;mundo&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="部署到韦塞尔"><a href="#部署到韦塞尔" class="headerlink" title="部署到韦塞尔"></a>部署到韦塞尔</h2><p>以前，您需要安装和配置 <a class="link"   href="https://vercel.com/download" >Vercel CLI<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm i -g vercel</span><br></pre></td></tr></table></figure></div>



<p>在终端中，在项目的根目录下写入：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vercel</span><br></pre></td></tr></table></figure></div>



<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--pTqvgmPE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/voibizmdx5e1vrwukrnm.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--pTqvgmPE--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/voibizmdx5e1vrwukrnm.png"
                      alt="韦塞尔 CLI"
                ></a></p>
<p>现在，在Vercel网络仪表板中，您将看到您的项目和项目URL</p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--BtRzLERJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wugczr28rjyd15cx6bv1.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--BtRzLERJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wugczr28rjyd15cx6bv1.png"
                      alt="Vercel Dashboard"
                ></a></p>
<p>现在，让我们在浏览器中测试我们的服务，转到项目 URL，并记得添加 API 路径，在本例中为<code>/api/hello</code></p>
<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--wQS2Ikyi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lu0u30x6iu2ojl5v8alq.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://res.cloudinary.com/practicaldev/image/fetch/s--wQS2Ikyi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lu0u30x6iu2ojl5v8alq.png"
                      alt="在浏览器中测试"
                ></a></p>
<p>就这样。。。现在轮到你了，在 API 中创建你需要的所有端点，只要记住每个端点都是一个文件。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习路线</title>
    <url>/2021/01/01/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>前端发展越来越快，每天都有数不胜数的技术发布。</p>
<p>想要入门前端却没有一条较为理想的路径？</p>
<p>在这个世界里兜兜转转了很久还是感觉在外围搬砖？</p>
<p>那么你可能需要这份技术学习路线图！</p>
<p>我们把学习前端分为三重境界：</p>
<p>单机写基础网页</p>
<p>联机高效写网页</p>
<p>让网页能够被更多人使用</p>
<p>接下来我们就通过介绍这三重境界来为你呈现详细的学习路线图。</p>
<p>单机写基础网页<br>何为单机呢？其实就是一个人 ??</p>
<p>你一个人使用 Web 基础技术开发网站，没有将代码分享给别人（你可能不知道程序世界的代码分享规则），同时只是在本地环境运行你的网站，你甚至对网站如何能把其他人访问到毫无头绪。</p>
<p>这个阶段也是成为一名前端工程师最最基础的一环，大部分初学者还停留在这个阶段，那么我们来看一下这个阶段需要什么样的技能。</p>
<p>HTML + CSS + JavaScript</p>
<p>没错，其实就是我们耳熟能详的前端三剑客，虽然看起来是最最入门的内容，但是需要了解的内容也不少，就类似我们需要先学 26 个字母，学各种汉字基础，才能写作或者创作诗歌一样。了解这三门技术大致需要了解那些内容以及有哪些学习资源推荐呢？</p>
<p>HTML<br>HTML 代表超文本标记语言。 它用于前端，为网页提供结构，您可以使用 CSS 设置样式并使用 JavaScript 进行交互。</p>
<p>HTML 的学习大致需要 6 个阶段：</p>
<p>学习基础知识：<a class="link"   href="https://www.w3schools.com/html/html_intro.asp" >https://www.w3schools.com/html/html_intro.asp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>编写语义化的 HTML：<a class="link"   href="https://www.w3schools.com/html/html5_semantic_elements.asp" >https://www.w3schools.com/html/html5_semantic_elements.asp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>了解表单与校验：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" >https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>遵守一些约定与最佳实践：<a class="link"   href="https://github.com/hail2u/html-best-practices" >https://github.com/hail2u/html-best-practices<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>了解可访问性：<a class="link"   href="https://www.w3schools.com/accessibility/index.php" >https://www.w3schools.com/accessibility/index.php<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>了解 SEO 基础：<a class="link"   href="https://developers.google.com/search/docs" >https://developers.google.com/search/docs<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>CSS<br>CSS 或级联样式表是用于设置任何网站前端样式的语言。 CSS 是万维网的基础技术，与 HTML 和 JavaScript 并列。</p>
<p>学习基础的 CSS 大致需要 3 个阶段：</p>
<p>学习基础知识：<a class="link"   href="https://www.w3schools.com/css/" >https://www.w3schools.com/css/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>学会如何布局，其中布局又包括以下知识：</p>
<p>Floats 浮动：<a class="link"   href="https://css-tricks.com/all-about-floats/" >https://css-tricks.com/all-about-floats/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Positioning 定位：<a class="link"   href="https://css-tricks.com/absolute-relative-fixed-positioining-how-do-they-differ/" >https://css-tricks.com/absolute-relative-fixed-positioining-how-do-they-differ/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Display 展示：<a class="link"   href="https://www.freecodecamp.org/news/the-css-display-property-display-none-display-table-inline-block-and-more/" >https://www.freecodecamp.org/news/the-css-display-property-display-none-display-table-inline-block-and-more/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>盒子模型：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model" >https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>CSS 网格：<a class="link"   href="https://cssgridgarden.com/" >https://cssgridgarden.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Flex 弹性盒布局：<a class="link"   href="https://flexboxfroggy.com/" >https://flexboxfroggy.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>学习媒体查询知识与 Web 响应式设计：<a class="link"   href="https://www.freecodecamp.org/learn/responsive-web-design/" >https://www.freecodecamp.org/learn/responsive-web-design/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>JavaScript<br>JavaScript 允许您向页面添加交互性。 您可能在网站上看到的常见示例是滑块、点击交互、弹出窗口等。</p>
<p>学习基础的 JavaScript 大致需要 5 个阶段：</p>
<p>基础的语法：<a class="link"   href="https://javascript.info/" >https://javascript.info/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>学习 DOM 操作：<a class="link"   href="https://www.freecodecamp.org/news/what-is-the-dom-document-object-model-meaning-in-javascript/" >https://www.freecodecamp.org/news/what-is-the-dom-document-object-model-meaning-in-javascript/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>学习 Fecth API 与 Ajax（XHR）：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" >https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>学习 ES6 与模块化 JavaScript：<a class="link"   href="https://www.javascripttutorial.net/es6/" >https://www.javascripttutorial.net/es6/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>理解进阶知识</p>
<p>Hositing：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" >https://developer.mozilla.org/en-US/docs/Glossary/Hoisting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>事件模型：<a class="link"   href="https://javascript.info/bubbling-and-capturing" >https://javascript.info/bubbling-and-capturing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>作用域：</p>
<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Glossary/Scope" >https://developer.mozilla.org/en-US/docs/Glossary/Scope<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://www.freecodecamp.org/news/var-let-and-const-whats-the-difference/" >https://www.freecodecamp.org/news/var-let-and-const-whats-the-difference/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>原型：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Shadow DOM：<a class="link"   href="https://www.youtube.com/watch?v=7Tok22qxPzQ" >https://www.youtube.com/watch?v=7Tok22qxPzQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>严格模式等：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" >https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>了解了上面的这些内容，你基本上算是一名基础的前端工程师了，你可以编写各种各样的基础界面，也应该在学习的过程中产出了很多个 DEMO 了。</p>
<p>联机高效写网页<br>请注意我们这一小节的关键词：联机、高效。</p>
<p>在这个阶段，你将学会如下知识：</p>
<p>如何以程序员的方式将代码与人分享并能够尝试参与别人代码的改进</p>
<p>高效的编写网站</p>
<p>理解网站是如何互通的，你是如何访问的网页的</p>
<p>基于上述的目标，这一阶段的关键技术如下：</p>
<p>Git、Github</p>
<p>Internet、Network 原理</p>
<p>开发框架：</p>
<p>JS&#x2F;HTML：Reatc&#x2F;Redux、Vue&#x2F;Vuex 等<br>CSS：Sass、Styled Components、TailwindCSS 等<br>构建：Webpack、Babel、Npm Scripts 等<br>包管理：Yarn、Npm 等<br>开发规范</p>
<p>CSS：BEM 等<br>JavaScript：Airbnb JavaScript Style Guide 等</p>
<p>Git<br>Git 是一种版本控制系统。</p>
<p>版本控制系统允许您跟踪代码库&#x2F;文件随时间的变化。 它们允许您毫无问题地返回到代码库的某个先前版本。 此外，它们还有助于与处理相同代码的人协作——如果您曾经与其他人合作过一个项目，您可能已经知道将其他人的更改复制和合并到您的代码库中的挫败感； 版本控制系统可以让你摆脱这个问题。</p>
<p>你可以通过下面的链接学习它：</p>
<p><a class="link"   href="https://www.youtube.com/watch?v=zbKdDsNNOhg" >https://www.youtube.com/watch?v=zbKdDsNNOhg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.youtube.com/watch?v=SWYqp7iY_Tc" >https://www.youtube.com/watch?v=SWYqp7iY_Tc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://youtu.be/Y9XZQO1n_7c?t=21" >https://youtu.be/Y9XZQO1n_7c?t=21<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Github<br>GitHub 是使用 Git 进行软件开发和版本控制的互联网托管提供商。 它提供了 Git 的分布式版本控制和源代码管理功能，以及它自己的特性。</p>
<p>你可以通过下面的链接学习它：</p>
<p><a class="link"   href="https://github.com/" >https://github.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://docs.github.com/en/get-started/quickstart/hello-world" >https://docs.github.com/en/get-started/quickstart/hello-world<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Internet<br>互联网是一个全球性的计算机网络，它们相互连接，通过一组标准化的协议进行通信。</p>
<p>了解互联网是如何工作的？</p>
<p><a class="link"   href="https://www.vox.com/2014/6/16/18076282/the-internet" >https://www.vox.com/2014/6/16/18076282/the-internet<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm" >http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper.htm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>什么是 HTTP？</p>
<p><a class="link"   href="https://www.cloudflare.com/en-gb/learning/ddos/glossary/hypertext-transfer-protocol-http/" >https://www.cloudflare.com/en-gb/learning/ddos/glossary/hypertext-transfer-protocol-http/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" >https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://kamranahmed.info/blog/2016/08/13/http-in-depth/" >https://kamranahmed.info/blog/2016/08/13/http-in-depth/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>HTTP 是基于 TCP&#x2F;IP 的应用层通信协议，它标准化了客户端和服务器之间的通信方式。 它定义了如何通过 Internet 请求和传输内容。</p>
<p>什么是浏览器？它们是如何工作的？</p>
<p><a class="link"   href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" >https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://www.browserstack.com/guide/browser-rendering-engine" >https://www.browserstack.com/guide/browser-rendering-engine<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work" >https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Web 浏览器是一种软件应用程序，它使用户能够通过其图形用户界面访问和显示网页或其他在线内容。</p>
<p>什么是 DNS？它们是如何工作的？</p>
<p><a class="link"   href="https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/" >https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>域名系统 (DNS) 是 Internet 的电话簿。 人类通过域名（如 nytimes.com 或 espn.com）在线访问信息。 Web 浏览器通过 Internet 协议 (IP) 地址进行交互。 DNS 将域名转换为 IP 地址，因此浏览器可以加载 Internet 资源</p>
<p>什么是域名？</p>
<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name" >https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>名是用于访问网站的唯一且易于记忆的地址，例如“google.com”和“facebook.com”。 借助 DNS 系统，用户可以使用域名连接到网站。</p>
<p>什么是主机？</p>
<p><a class="link"   href="https://www.youtube.com/watch?v=htbY9-yggB0" >https://www.youtube.com/watch?v=htbY9-yggB0<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>虚拟主机是一种在线服务，可让您将网站文件发布到互联网上。 因此，任何可以访问互联网的人都可以访问您的网站。</p>
<p>JavaScript 框架<br>React</p>
<p><a class="link"   href="https://reactjs.org/" >https://reactjs.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://reactjs.org/tutorial/tutorial.html" >https://reactjs.org/tutorial/tutorial.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>React 是最流行的用于构建用户界面的前端 JavaScript 库。 React 还可以使用 Node 在服务器上渲染，并使用 React Native 为移动应用程序提供动力。</p>
<p>Redux</p>
<p><a class="link"   href="https://redux.js.org/" >https://redux.js.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://redux.js.org/introduction/getting-started" >https://redux.js.org/introduction/getting-started<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Redux 是 JavaScript 应用程序的可预测状态容器。 它可以帮助您编写行为一致、在不同环境（客户端、服务器和本机）中运行并且易于测试的应用程序。 最重要的是，它提供了出色的开发人员体验，例如实时代码编辑与时间旅行调试器相结合。</p>
<p>当然状态管理方面目前也有 Mobx 与 Recoil 等有力的竞争者。</p>
<p>上述的是 React 生态，此外 JavaScript 社区还有 Vue 与 Angular 等其他非常有竞争力的框架。</p>
<p>CSS 框架<br>Styled Components</p>
<p><a class="link"   href="https://github.com/styled-components/styled-components" >https://github.com/styled-components/styled-components<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>利用标记的模板文字（最近添加到 JavaScript）和 CSS 的强大功能，styled-components 允许您编写实际的 CSS 代码来设置组件的样式。 它还删除了组件和样式之间的映射——将组件用作低级样式构造！</p>
<p>CSS Modules</p>
<p><a class="link"   href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" >http://www.ruanyifeng.com/blog/2016/06/css_modules.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>给 CSS 加入了局部作用域与模块依赖</p>
<p>Sass</p>
<p><a class="link"   href="http://www.ruanyifeng.com/blog/2012/06/sass.html" >http://www.ruanyifeng.com/blog/2012/06/sass.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>为 CSS 加入编程元素，被称为 CSS 预处理器</p>
<p>TailwindCSS</p>
<p><a class="link"   href="https://tailwindcss.com/" >https://tailwindcss.com/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>供一系列辅助类，直接为 HTML 标记添加这些预设的辅助类就可以快速完成一组专业的网站。</p>
<p>构建相关<br>Webpack</p>
<p><a class="link"   href="https://webpack.js.org/" >https://webpack.js.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Webpack 是一个模块打包器。 它的主要目的是捆绑 JavaScript 文件以在浏览器中使用，但它也能够转换、捆绑或打包几乎任何资源或资产。</p>
<p>除了 Webpack，目前前端圈比较火的还有：</p>
<p>为库打包的更佳选择：Rollup</p>
<p>基于浏览器 ESM 的 Bundless 解决方案：Vite</p>
<p>Npm scripts</p>
<p><a class="link"   href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" >http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>组合 Yarn、Npm、Pnpm 等包管理一起使用，来便捷的执行一系列脚本</p>
<p>Babel</p>
<p><a class="link"   href="http://www.ruanyifeng.com/blog/2016/01/babel.html" >http://www.ruanyifeng.com/blog/2016/01/babel.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行</p>
<p>开发规范<br>BEM</p>
<p><a class="link"   href="https://en.bem.info/" >https://en.bem.info/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://juejin.cn/post/6844903672162304013" >https://juejin.cn/post/6844903672162304013<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>块、元素、修饰符方法（通常称为 BEM）是 HTML 和 CSS 中类的流行命名约定。 由 Yandex 团队开发，其目标是帮助开发人员更好地理解给定项目中 HTML 和 CSS 之间的关系。</p>
<p>JavaScript Style Guide</p>
<p><a class="link"   href="https://github.com/airbnb/javascript" >https://github.com/airbnb/javascript<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>编写 JavaScript 最合理的方法之一</p>
<p>经历上面的一阵狂风乱炸的洗礼之后，你现在已经能够理解如下知识了：</p>
<p>网页是如何运行的</p>
<p>如何使用框架（JS、CSS 框架）、现代的前端工程化集合工具辅助你高效的编写界面</p>
<p>在编写代码的时候，遵守相关的规范，写出更容易让其他人读懂的代码</p>
<p>将你的代码使用版本控制系统 Git 来追踪，并通过 Github 将你的代码分析给其他程序员学习</p>
<p>让网页被更多人使用<br>如果你想让你的网站被更多人使用，甚至是你要开发一款产品，完成你的创业目标，那么你可能还需要一些额外的知识辅助你。</p>
<p>在这个阶段你需要了解的知识点如下：</p>
<p>确保你的网站安全：HTTPS、Cors、内容安全策略等</p>
<p>确保的应用尽可能少 BUG：TypeScript、Jest、Cypress、Enzyme、React Testing Library</p>
<p>让用户在没有网的情况下也能使用：PWA、Storage、Web Socket、Service Workers 等</p>
<p>让你的网站被更快的访问：Lighthouse、Devtools、Performance Metrics、RAIL Model、PRPL Pattern</p>
<p>让你的网站能更好的被索引：SSR</p>
<p>让你的应用分散在各个平台：React Native、Flutter、Electron</p>
<p>让你的网站也能够处理更复杂的动效：WebAssembly 等</p>
<p>Web 安全<br>HTTPS</p>
<p><a class="link"   href="https://www.cloudflare.com/en-gb/learning/ssl/what-is-https/" >https://www.cloudflare.com/en-gb/learning/ssl/what-is-https/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https" >https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://developers.google.com/web/fundamentals/security/encrypt-in-transit/enable-https" >https://developers.google.com/web/fundamentals/security/encrypt-in-transit/enable-https<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>HTTPS 是一种在 Web 服务器和浏览器之间发送数据的安全方式。</p>
<p>CORS</p>
<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" >https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>跨域资源共享 (CORS) 是一种基于 HTTP 标头的机制，它允许服务器指示除其自身之外的任何来源（域、方案或端口），浏览器应允许从中加载资源。</p>
<p>CSP（内容安全策略）</p>
<p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" >https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://developers.google.com/web/fundamentals/security/csp" >https://developers.google.com/web/fundamentals/security/csp<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>内容安全策略是一种计算机安全标准，用于防止在受信任的网页上下文中执行恶意内容而导致的跨站点脚本、点击劫持和其他代码注入攻击。</p>
<p>测试工具<br>Jest</p>
<p><a class="link"   href="https://jestjs.io/" >https://jestjs.io/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Jest 是一个令人愉快的 JavaScript 测试框架，专注于简单性。 它适用于使用以下项目的项目：Babel、TypeScript、Node、React、Angular、Vue 等等！</p>
<p>React Testing Library</p>
<p><a class="link"   href="https://github.com/testing-library/react-testing-library" >https://github.com/testing-library/react-testing-library<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>完备的 React DOM 的测试辅助库</p>
<p>Cypress</p>
<p><a class="link"   href="https://www.cypress.io/" >https://www.cypress.io/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>对应用进行端到端测试</p>
<p>Enzyme</p>
<p><a class="link"   href="https://github.com/enzymejs/enzyme" >https://github.com/enzymejs/enzyme<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>测试 React 的辅助库</p>
<p>类型检查工具<br>TypeScript</p>
<p><a class="link"   href="https://www.typescriptlang.org/" >https://www.typescriptlang.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.typescriptlang.org/docs/" >https://www.typescriptlang.org/docs/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.typescriptlang.org/docs/handbook/intro.html" >https://www.typescriptlang.org/docs/handbook/intro.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>TypeScript 是一种基于 JavaScript 的强类型编程语言，可为您提供任何规模的更好的工具。</p>
<p>离线使用<br>Web 最新的 Progressive Web Apps （PWA）技术，使得 Web 网站可以像 App 一样，拥有离线使用、推送通知等功能。</p>
<p>PWA 主要包含下面几个部分：</p>
<p>Storage</p>
<p>WebSockets</p>
<p>Service Workers</p>
<p>Location</p>
<p>Notifications</p>
<p>Device Orientation</p>
<p>Payments</p>
<p>Credentials</p>
<p>主要的参考学习资源如下：</p>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps" >https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/GoogleChrome/workbox" >https://github.com/GoogleChrome/workbox<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>性能相关<br>Web 性能是加载时间和运行时的客观测量和感知用户体验。 Web 性能是指网站加载、变得交互和响应所需的时间，以及在用户交互期间内容的流畅程度。</p>
<p>性能涉及到计算、衡量与改进性能，主要涉及下面这些知识点：</p>
<p>PRPL Pattern</p>
<p>RAIL Model</p>
<p>Performance Metrics</p>
<p>Lighthouse</p>
<p>Devtools</p>
<p>主要的参考学习资源如下：</p>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Performance" >https://developer.mozilla.org/zh-CN/docs/Web/Performance<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://web.dev/" >https://web.dev/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>SEO 相关<br>SEO（Search Engine Optimization）—— 搜索引擎优化，目的是帮助我们的网站在Google或者Baidu搜索的时候排名会提升靠前。</p>
<p>Next.js</p>
<p><a class="link"   href="https://nextjs.org/" >https://nextjs.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://nextjs.org/docs/getting-started" >https://nextjs.org/docs/getting-started<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.freecodecamp.org/news/the-next-js-handbook/" >https://www.freecodecamp.org/news/the-next-js-handbook/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Next.js 是一个构建在 Node.js 之上的开源开发框架，支持基于 React 的 Web 应用程序功能，例如服务器端渲染和生成静态网站。</p>
<p>多平台<br>React Native</p>
<p><a class="link"   href="https://reactnative.cn/" >https://reactnative.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/facebook/react-native" >https://github.com/facebook/react-native<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>使用 React 来开发移动端应用，如 Android 或 iOS。</p>
<p>Flutter</p>
<p><a class="link"   href="https://flutter.cn/" >https://flutter.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://flutter-io.cn/" >https://flutter-io.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Flutter 为应用开发带来了革新： 只要一套代码库（Dart），即可构建、测试和发布适用于移动、Web、桌面和嵌入式平台的精美应用</p>
<p>Electron</p>
<p><a class="link"   href="https://www.electronjs.org/" >https://www.electronjs.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://wizardforcel.gitbooks.io/electron-doc/content/tutorial/tutorial.html" >https://wizardforcel.gitbooks.io/electron-doc/content/tutorial/tutorial.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Electron（原名为Atom Shell）是GitHub开发的一个开源框架。它通过使用Node.js（作为后端）和Chromium的渲染引擎（作为前端）完成跨平台的桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端与后端的开发，著名项目包括GitHub的Atom和微软的Visual Studio Code。</p>
<p>高性能应用<br>WebAssembly</p>
<p><a class="link"   href="https://developer.mozilla.org/zh-CN/docs/WebAssembly" >https://developer.mozilla.org/zh-CN/docs/WebAssembly<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://juejin.cn/post/7035991254257106958" >https://juejin.cn/post/7035991254257106958<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>WebAssembly是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如C &#x2F; C ++等语言提供一个编译目标，以便它们可以在Web上运行。它也被设计为可以与JavaScript共存，允许两者一起工作。</p>
<p>当你学完了这个部分的内容，基本上已经是算是一位高阶的前端工程师了，能够在任何大厂胜任各种研发工作，当然能够坚持到这里不容易，需要持续的努力，加油??<br>————————————————</p>
<p>原文链接：<a class="link"   href="https://blog.csdn.net/qq_46416934/article/details/126096998" >https://blog.csdn.net/qq_46416934/article/details/126096998<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的自我修养</title>
    <url>/2023/03/06/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%89%8D%E7%AB%AF%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h6 id="问：css盒模型是什么？"><a href="#问：css盒模型是什么？" class="headerlink" title="问：css盒模型是什么？"></a>问：css盒模型是什么？</h6><p>答： 在html中所有的元素都可以看成一个盒子，盒子由外边距<code>margin</code>、内边距<code>padding</code>、边框<code>border</code>、内容<code>content</code>四部分构成；盒子的类型分为两种：</p>
<ul>
<li><p>标准盒模型：<code>margin border + padding + content</code></p>
</li>
<li><p>IE盒模型：<code>margin + content(border + padding)</code></p>
<p>通过控制css属性<code>box-sizing</code>:  <code>默认值（标准盒模型）</code>| <code>border-box(IE盒模型)</code></p>
<p>总结： 标准盒模型的宽高设置的是内容<code>content</code>, IE盒模型的宽高设置的是<code>border + padding + content</code>三者相加的总和</p>
</li>
</ul>
<h6 id="问：css选择器的优先级？"><a href="#问：css选择器的优先级？" class="headerlink" title="问：css选择器的优先级？"></a>问：css选择器的优先级？</h6><p>答：css的特性包括：继承性、层叠性、优先级；当一个元素有多个样式的时候，显示权重高的样式，权限的优先级分为</p>
<p><code>important</code> &gt; <code>行内样式</code> &gt; <code>id</code> &gt; <code>类/伪类/属性</code>&gt; <code>标签</code> &gt; <code>全局选择器*</code></p>
<h6 id="问：隐藏元素的方式有哪些？"><a href="#问：隐藏元素的方式有哪些？" class="headerlink" title="问：隐藏元素的方式有哪些？"></a>问：隐藏元素的方式有哪些？</h6><p>答：<code>display: none</code> | <code>opacity: 0</code> | <code> visibility: hidden</code>，其中只有第一种隐藏方式的元素不占据空间</p>
<h6 id="问：px-和-rem-的区别是什么？"><a href="#问：px-和-rem-的区别是什么？" class="headerlink" title="问：px 和 rem 的区别是什么？"></a>问：px 和 rem 的区别是什么？</h6><p>答： <code>px</code>属于绝对单位长度，代表显示器上的一个像素单位；<code>rem</code>属于相对单位长度，代表相当于<code>html</code>根节点的值，例如：</p>
<p>设置根节点的<code>font-size: 62.5%</code>,得到的1rem实际单位长度为16px * 62.5% &#x3D; 10px, 即<code>1rem = 10px</code></p>
<h6 id="问：-重排和重绘有什么区别？"><a href="#问：-重排和重绘有什么区别？" class="headerlink" title="问： 重排和重绘有什么区别？"></a>问： 重排和重绘有什么区别？</h6><p>答： </p>
<p>​		重排也称回流：浏览器渲染引擎会根据所有元素的样式计算出盒模型在页面中的位置和大小；当对Dom的大小、位置进行修改后，引擎需要进行重新计算，就会触发重排机制，重排必然引起重绘。</p>
<p>​		重绘：浏览器渲染引擎计算好盒模型的位置、大小等基本属性后，对每个盒模型的其他特性进行绘制；对Dom的样式进行修改，比如<code>background-color</code>,渲染引擎不需要重新计算几何属性，只需对元素的样式进行绘制，就只会触发重绘机制</p>
<h6 id="问-元素水平垂直居中的方式？"><a href="#问-元素水平垂直居中的方式？" class="headerlink" title="问: 元素水平垂直居中的方式？"></a>问: 元素水平垂直居中的方式？</h6><p>答： 一般常见的有以下几种方式：</p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方式1: 定位+margin */</span></span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式2: 定位+transform */</span></span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 方式3: flex布局 */</span></span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* 方式4: grid布局 */</span></span><br><span class="line"><span class="comment">/* 方式5: table布局 */</span></span><br></pre></td></tr></table></figure></div>



<h6 id="问-css中哪些属性可以继承？"><a href="#问-css中哪些属性可以继承？" class="headerlink" title="问: css中哪些属性可以继承？"></a>问: css中哪些属性可以继承？</h6><p>答：以下元素属性没有设置值时，则默认继承父级属性值:</p>
<ol>
<li>字体系列属性: <code>font</code>、<code>font-family</code>、<code>font-weight</code>、<code>font-size</code>、<code>fontstyle</code></li>
<li>文本属性: <code>color</code>、<code>line-height</code>、<code>word-spacing</code>、<code>letter-spacing</code>、<code> text-transform</code>、<code>text-indent</code>、<code>text-align</code></li>
<li>元素可见性: <code>visibility</code></li>
<li>表格布局属性: <code>caption-side</code>、<code>border-collapse</code>、<code>border-spacing</code>、<code>empty-cells</code>、<code>table-layout</code></li>
<li>列表布局属性：<code>list-style</code></li>
<li>光标属性：<code>cursor</code></li>
</ol>
<h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h2 id="javascript部分"><a href="#javascript部分" class="headerlink" title="javascript部分"></a>javascript部分</h2><h6 id="问-js由哪三部分构成？"><a href="#问-js由哪三部分构成？" class="headerlink" title="问:  js由哪三部分构成？"></a>问:  js由哪三部分构成？</h6><p>答：<code>ECMAScript</code>（核心）、<code>DOM</code>（文档对象模型）、<code>BOM</code>（浏览器对象模型）</p>
<p>问:  js对数据类的检测方式有哪些？</p>
<h6 id="问：js有哪些内置对象？"><a href="#问：js有哪些内置对象？" class="headerlink" title="问：js有哪些内置对象？"></a>问：js有哪些内置对象？</h6><p>答：常见的有<code>String</code> 、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Function</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code> 等…</p>
<p>答：一般通过以下方式</p>
<ol>
<li><code>typeof</code>:  只能检测基本数据类型</li>
<li><code>instanceof</code>: 只能检测引用数据类型</li>
<li><code>constructor</code>: 可以判断基本和引用数据类型，但是对于构造函数而言，如果改变它的原型指向，会导致检测结果不正确</li>
<li><code>Object.prototype.toString.call</code>: 最佳检测方式</li>
</ol>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res_1 = <span class="keyword">typeof</span> <span class="string">&#x27;123&#x27;</span> <span class="comment">// =&gt; string</span></span><br><span class="line"><span class="keyword">const</span> res_2 = [] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&#x27;jiangwen&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> res_3 = a.<span class="property">constructor</span> === A <span class="comment">// =&gt; true</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Array</span></span><br><span class="line"><span class="keyword">const</span> res_4 = a.<span class="property">constructor</span> === A <span class="comment">// =&gt; false , 指向的constructor变为Array</span></span><br><span class="line"><span class="keyword">const</span> res_5 = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// =&gt; [object String]</span></span><br></pre></td></tr></table></figure></div>



<h6 id="问：什么是闭包，闭包有什么特点？"><a href="#问：什么是闭包，闭包有什么特点？" class="headerlink" title="问：什么是闭包，闭包有什么特点？"></a>问：什么是闭包，闭包有什么特点？</h6><p>答： 闭包在<a class="link"   href="https://so.csdn.net/so/search?q=JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&spm=1001.2101.3001.7020" >JavaScript高级程序设计<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>（第3版）中是这样描述：<strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong></p>
<p>闭包的特点是：</p>
<ul>
<li>可以在函数的外部访问到函数内部的局部变量。</li>
<li>让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。</li>
</ul>
<p>使用场景:</p>
<ul>
<li>防抖</li>
<li>节流</li>
<li>函数嵌套避免全局污染</li>
</ul>
<h6 id="问：前端中的内存泄露是什么？"><a href="#问：前端中的内存泄露是什么？" class="headerlink" title="问：前端中的内存泄露是什么？"></a>问：前端中的内存泄露是什么？</h6><p>答： js的垃圾回收机制没有释放已经分配了内存地址的对象，造成长期的内存占用、内存资源浪费，导致运行速度慢，甚至崩溃的情况。会导致内存泄露的因素：</p>
<ol>
<li>一些未声明直接赋值的变量</li>
<li>未清空的定时器</li>
<li>过渡闭包</li>
<li>引用的元素没有被清除</li>
</ol>
<h6 id="问：什么是原型链？"><a href="#问：什么是原型链？" class="headerlink" title="问：什么是原型链？"></a>问：什么是原型链？</h6><p>答：原型就是一个普通的对象，为构造函数的实例共享属性和方法；所有实例对象中引用的原型都是同一个对象，使用<code>prototype</code>可以把属性、方法挂载到原型对象中进行共享，而内存仅需保存一份；实例对象中的属性<code>__proto__</code>，指向了构造函数的原型对象<code>prototype</code>，一个实例对象在调用属性、方法的时候，会依次从<code>实例本身 =&gt; 构造函数的原型对象 =&gt; 原型对象的原型对象</code>，进行查找，这些原型关系就构成了原型链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/5cdd315c45bc895052.png"
                      alt="img"
                ></p>
<p>小结</p>
<ul>
<li>所有构造函数的<code>__proto__</code>都指向<code>Function.prototype</code>，包括Function本身</li>
<li>所有原型对象的<code>__proto__</code>都指向<code>Object.prototype</code>, 而<code>Object.prototype</code>本身的<code>__proto__</code>指向<code>null</code></li>
</ul>
<h6 id="问：new-操作符具体做了什么？"><a href="#问：new-操作符具体做了什么？" class="headerlink" title="问：new 操作符具体做了什么？"></a>问：new 操作符具体做了什么？</h6><p>答：具体分为以下步骤：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newFn</span>(<span class="params">Fn, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 2. 把空对象和构造函数通过原型链进行关联</span></span><br><span class="line">  newObj.<span class="property">__proto__</span> = <span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 3. 将构造函数的`this`绑定到空对象上</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="title class_">Fn</span>.<span class="title function_">apply</span>(newObj, args)</span><br><span class="line">  <span class="comment">// 4. 根据构造函数返回的类型判断；如果是值类型，则返回对象，如果是引用类型，则返回这个引用类型</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? res : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h6 id="问：js是如何实现继承的？"><a href="#问：js是如何实现继承的？" class="headerlink" title="问：js是如何实现继承的？"></a>问：js是如何实现继承的？</h6><p>答： 常见的有以下几种方式</p>
<ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合式继承</li>
<li>ES6的class类继承</li>
</ol>
<h6 id="问：js中关于this指向的问题？"><a href="#问：js中关于this指向的问题？" class="headerlink" title="问：js中关于this指向的问题？"></a>问：js中关于this指向的问题？</h6><p>答： 分为以下情况</p>
<ol>
<li><p>全局对象中的this指向的是<code>window</code></p>
</li>
<li><p>全局作用域、普通函数中的this指向全局<code>window</code></p>
</li>
<li><p>匿名函数的执行环境具有全局性，因此匿名函数中的this永远指向<code>window</code></p>
</li>
<li><p>this永远指向最后调用它的那个对象</p>
</li>
<li><p><code>new</code>关键字改变了this的指向</p>
</li>
<li><p>不是箭头函数的时候，<code>call</code>、<code>apply</code>、<code>bind</code>可以改变this的指向</p>
</li>
<li><p>箭头函数中的this指向，在它定义的时候就已经确定了，箭头函数本身没有this，看外层的函数是否有this，有就是外层函数的this，没有就是指向<code>window</code></p>
</li>
</ol>
<h6 id="问：-async-和-defer-有什么区别？"><a href="#问：-async-和-defer-有什么区别？" class="headerlink" title="问： async 和 defer 有什么区别？"></a>问： async 和 defer 有什么区别？</h6><p>答：它们两个属性都是指定浏览器进行脚本的异步加载，但是加载后的执行时机不同，<code>defer</code>需要所有元素加载完成之后才执行，<code>async</code>是<code>HTML5</code>新增的属性，只要脚本加载完成之后就马上执行，因此<code>async</code>不能确保脚本的执行顺序，而<code>defer</code>则可以。</p>
<h6 id="问：-ES6的新特性有哪些？"><a href="#问：-ES6的新特性有哪些？" class="headerlink" title="问： ES6的新特性有哪些？"></a>问： ES6的新特性有哪些？</h6><p>答：有以下新特性：</p>
<ol>
<li><p>新增了块级作用域（let，const）</p>
</li>
<li><p>新增了定义类语法糖（class）</p>
</li>
<li><p>新增了基本数据类型（symbol）</p>
</li>
<li><p>新增了解构赋值</p>
</li>
<li><p>新增了函数参数的默认值</p>
</li>
<li><p>新增了数组的API</p>
</li>
<li><p>对象和数组新增了扩展运算符（…）</p>
</li>
<li><p>新增了<code>promise</code></p>
<ul>
<li>把异步操作队列化，解决了回调地狱的问题</li>
<li>有<code>all</code>,<code>reject</code>,<code>resolve</code>,<code>race</code>方法</li>
<li>原型有<code>then</code>、<code>catch</code></li>
<li>三种状态<code>pending</code>|<code>rejected</code>|<code>fulfilled</code>, 状态一旦从<code>pending</code> &#x3D;&gt; <code>rejected</code>或者<code>pending</code> &#x3D;&gt; <code>fulfilled</code>改变,状态就确定了，不可逆</li>
<li><code>async</code>和<code>await</code>: 同步代码做异步操作，两者必须搭配使用</li>
</ul>
</li>
<li><p>新增了模块化（import、export）</p>
</li>
<li><p>新增了set 和map数据结构</p>
<ul>
<li>set 数据结构不存在重复</li>
<li>map  数据结构的key类型不受限制</li>
</ul>
</li>
<li><p>新增了generator构造器</p>
</li>
<li><p>新增了箭头函数</p>
</li>
</ol>
<h6 id="问：-箭头函数和普通函数有什么区别？"><a href="#问：-箭头函数和普通函数有什么区别？" class="headerlink" title="问： 箭头函数和普通函数有什么区别？"></a>问： 箭头函数和普通函数有什么区别？</h6><p>答：有以下区别</p>
<ol>
<li>箭头函数不能使用<code>new</code>操作符, 来作为构造函数使用</li>
<li>箭头函数没有原型</li>
<li>箭头函数没有<code>arguments</code></li>
<li>箭头函数不能用<code>call</code>、<code>call</code>、<code>call</code>去改变this的执行</li>
<li>箭头函数的this执行外层函数的第一个this</li>
</ol>
<h6 id="问：-如何实现一个深拷贝？"><a href="#问：-如何实现一个深拷贝？" class="headerlink" title="问： 如何实现一个深拷贝？"></a>问： 如何实现一个深拷贝？</h6><p>答：一般可以通过以下方式：</p>
<ol>
<li><p>扩展运算符实现</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oo_1 = &#123; ...o&#125;  <span class="comment">// 缺点： 对于对象中的引用数据类型还是浅拷贝</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p><code> JSON.parse(JSON.stringify())</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oo_1 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o))  <span class="comment">// 缺点： 对象中的函数不会拷贝</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>递归复制</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* origin: 拷贝源对象</span></span><br><span class="line"><span class="comment">* deep: 是否使用深拷贝</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">origin, deep</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> (origin <span class="keyword">instanceof</span> <span class="title class_">Array</span>) obj = [];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">     <span class="keyword">let</span> value = origin[key]</span><br><span class="line">     obj[key] = (!!deep &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> &amp;&amp; value !== <span class="literal">null</span>) ? <span class="title function_">deepClone</span>(value, deep) : value</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oo_1 = <span class="title function_">deepClone</span>(o, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h6 id="问：-说一下事件循环？"><a href="#问：-说一下事件循环？" class="headerlink" title="问： 说一下事件循环？"></a>问： 说一下事件循环？</h6><p>答： js是一个单线程脚本语言，</p>
<h2 id="经典试题"><a href="#经典试题" class="headerlink" title="经典试题"></a>经典试题</h2><ol>
<li><p>三次握手和四次挥手详细介绍</p>
</li>
<li><p>TCP有哪些手段保证可靠交付</p>
</li>
<li><p>URL从输入到页面渲染全流程</p>
</li>
<li><p>如何预防中间人攻击</p>
</li>
<li><p>DNS解析会出错吗，为什么</p>
</li>
<li><p>ES6的Set内部实现</p>
</li>
<li><p>如何应对流量劫持</p>
</li>
<li><p>算法：top-K问题，分成top-1,top-2,top-K三小问</p>
</li>
<li><p>跨域</p>
</li>
<li><p>webpack的plugins和loaders的实现原理</p>
</li>
<li><p>vue和react谈谈区别和选型考虑</p>
</li>
<li><p>webpack如何优化编译速度</p>
</li>
<li><p>事件循环机制，node和浏览器的事件循环机制区别</p>
</li>
<li><p>单元测试编写有哪些原则</p>
</li>
<li><p>一个大型项目如何分配前端开发的工作</p>
</li>
<li><p>怼项目</p>
</li>
<li><p>typescript有什么好处</p>
</li>
<li><p>vue项目中如何约束rxjs数据的类型</p>
</li>
<li><p>rxjs高阶数据流定义，常用高阶数据流操作符</p>
</li>
<li><p>JWT优缺点</p>
</li>
<li><p>选择器优先级</p>
</li>
<li><p>基本数据类型</p>
</li>
<li><p>RxJS冷热流区别</p>
</li>
<li><p>RxJS调试方法</p>
</li>
<li><p>nginx负载均衡配置</p>
</li>
<li><p>前端性能优化手段</p>
</li>
<li><p>针对React的性能优化手段</p>
</li>
<li><p>301 302 307 308 401 403</p>
</li>
<li><p>vue的nextTick实现原理以及应用场景</p>
</li>
<li><p>vue组件间通信</p>
</li>
<li><p>谈谈XSS防御，以及Content-Security-Policy细节</p>
</li>
<li><p>场景题：一个气球从右上角移动到中间，然后抖动，如何实现</p>
</li>
<li><p>场景题：一个关于外边距合并的高度计算</p>
</li>
<li><p>mobx-react如何驱动react组件重渲染</p>
</li>
<li><p>forceUpdate经历了哪些生命周期，子组件呢?</p>
</li>
<li><p>React key场景题：列表使用index做key，删除其中一个后，如何表现？</p>
</li>
<li><p>算法：实现setter(obj, ‘a.b.c’ ,val)</p>
</li>
<li><p>RxJS相对于其他状态管理方案的优势？</p>
</li>
<li><p>手写冒泡排序</p>
</li>
<li><p>JWT细节，适用场景</p>
</li>
<li><p>跨域</p>
</li>
<li><p>方案题：不同前端技术栈的项目，如何实现一套通用组件方案？</p>
</li>
<li><p>ES6特性</p>
<p>闭包和this一起谈谈</p>
<p>postcss配置</p>
<p>Promise内部实现原理</p>
<p>vuex, mobx, redux各自的特点和区别</p>
<p>react生命周期</p>
<p>各方面谈谈性能优化</p>
<p>serviceworker如何保证离线缓存资源更新</p>
<p>virtual dom有哪些好处</p>
</li>
<li><ol>
<li><p>Vue3 proxy解决了哪些问题？</p>
</li>
<li><p>Vue响应式原理</p>
</li>
<li><p>发布订阅模式和观察者模式的异同</p>
</li>
<li><p>图片懒加载实现</p>
</li>
<li><p>css垂直居中</p>
</li>
<li><p>CI&#x2F;CD流程</p>
</li>
<li><p>谈谈性能优化</p>
</li>
<li><p> react生命周期</p>
</li>
</ol>
</li>
</ol>
<p>   key的作用</p>
<p>   hooks</p>
<p>   vue和react区别，选型考虑</p>
<pre><code>   canvas优化绘制性能

   webpack性能优化手段

   事件循环

   如何解决同步调用代码耗时太高的问题

   手写Promise实现

   1. Promise实现原理
</code></pre>
<ol start="2">
<li>vue组件间通信<ol start="3">
<li>性能优化</li>
</ol>
</li>
<li>vuex数据流动过程<ol start="5">
<li>谈谈css预处理器机制</li>
</ol>
</li>
<li>算法：Promise串行</li>
</ol>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>1、原型&#x2F;原型链&#x2F;构造函数&#x2F;实例&#x2F;继承</p>
<p>2、有几种方式可以实现继承</p>
<p>3、用原型实现继承有什么缺点，怎么解决</p>
<p>4、arguments</p>
<p>5、数据类型判断</p>
<p>6、作用域链、闭包、作用域</p>
<p>7、Ajax的原生写法</p>
<p>8、对象深拷贝、浅拷贝</p>
<p>9、图片懒加载、预加载</p>
<p>10、实现页面加载进度条</p>
<p>11、this关键字</p>
<p>12、函数式编程</p>
<p>13、手动实现parseInt</p>
<p>14、为什么会有同源策略</p>
<p>15、怎么判断两个对象是否相等</p>
<p>16、事件模型 </p>
<ul>
<li>事件委托、代理</li>
<li>如何让事件先冒泡后捕获</li>
</ul>
<p>17、window的onload事件和domcontentloaded</p>
<p>18、for…in迭代和for…of有什么区别</p>
<p>19、函数柯里化</p>
<p>20、call apply区别，原生实现bind </p>
<ul>
<li>call，apply，bind 三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。</li>
</ul>
<p>21、async&#x2F;await</p>
<p>22、立即执行函数和使用场景</p>
<p>23、设计模式(要求说出如何实现,应用,优缺点)&#x2F;单例模式实现</p>
<p>24、iframe的缺点有哪些</p>
<p>25、数组问题 </p>
<ul>
<li>数组去重</li>
<li>数组常用方法</li>
<li>查找数组重复项</li>
<li>扁平化数组</li>
<li>按数组中各项和特定值差值排序</li>
</ul>
<p>26、BOM属性对象方法</p>
<p>27、服务端渲染</p>
<p>28、垃圾回收机制</p>
<p>29、eventloop </p>
<ul>
<li>进程和线程</li>
<li>任务队列</li>
</ul>
<p>30、如何快速让字符串变成已千为精度的数字</p>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>1、声明 let、const</p>
<p>2、解构赋值</p>
<p>3、声明类与继承：class、extend</p>
<p>4、Promise的使用与实现</p>
<p>5、generator（异步编程、yield、next()、await 、async）</p>
<p>6、箭头函数this指向问题、拓展运算符</p>
<p>7、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？</p>
<p>8、ES6怎么编译成ES5,css-loader原理,过程</p>
<p>9、ES6转成ES5的常见例子 </p>
<ul>
<li>使用es5实现es6的class</li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>1、输入url到展示页面过程发生了什么？</p>
<p>2、重绘与回流 </p>
<ul>
<li>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</li>
<li>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:<br>* 页面初次渲染<br>* 浏览器窗口大小改变<br>* 元素尺寸、位置、内容发生改变<br>* 元素字体大小变化<br>* 添加或者删除可见的 dom 元素<br>* 激活 CSS 伪类（例如：:hover）<br>* 查询某些属性或调用某些方法<br>* clientWidth、clientHeight、clientTop、clientLeft<br>* offsetWidth、offsetHeight、offsetTop、offsetLeft<br>* scrollWidth、scrollHeight、scrollTop、scrollLeft<br>* getComputedStyle()<br>* getBoundingClientRect()<br>* scrollTo()<br><strong>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</strong></li>
</ul>
<p>3、防抖与节流</p>
<p>4、cookies、session、sessionStorage、localStorage</p>
<p>5、浏览器内核</p>
<h2 id="服务端与网络"><a href="#服务端与网络" class="headerlink" title="服务端与网络"></a>服务端与网络</h2><p>1、常见状态码</p>
<p>2、缓存 </p>
<ul>
<li>200 From cache和200 ok</li>
<li>400,401,403状态码分别代表什么</li>
<li>浏览器缓存</li>
</ul>
<p>3、cookie, session, token</p>
<p>4、前端持久化的方式、区别</p>
<p>5、DNS是怎么解析的</p>
<p>6、cdn</p>
<p>7、计算机网络的相关协议</p>
<p>8、http&#x2F;https&#x2F;http2.0</p>
<p>9、get post区别</p>
<p>10、ajax、 axios库</p>
<p>11、tcp三次握手，四次挥手流程</p>
<p>12、跨域</p>
<p>13、前端安全XSS、CSRF</p>
<p>14、websocket</p>
<p>15、Http请求中的keep-alive有了解吗</p>
<p>16、网络分层</p>
<p>17、即时通信，除了Ajax和websocket</p>
<p>18、模块化，commonJS，es6，cmd，amd</p>
<h2 id="框架（Vue）"><a href="#框架（Vue）" class="headerlink" title="框架（Vue）"></a>框架（Vue）</h2><p>1、vue解决了什么问题</p>
<p>2、MVVM的理解</p>
<p>3、如何实现一个自定义组件，不同组件之间如何通信的？</p>
<p>4、nextTick</p>
<p>5、生命周期</p>
<p>6、虚拟dom的原理</p>
<p>7、双向绑定的原理？数据劫持？</p>
<p>8、组件通信 </p>
<ul>
<li>父-&gt;子</li>
<li>子-&gt;父</li>
<li>非父子组件</li>
</ul>
<p>9、Proxy 相比于 defineProperty 的优势</p>
<p>10、watch computed区别</p>
<p>11、virtual dom 原理实现</p>
<p>12、vue-router(hash， HTML5 新增的 pushState </p>
<ul>
<li>单页应用，如何实现其路由功能—路由原理</li>
<li>vue-router如何做用户登录权限等</li>
<li>你在项目中怎么实现路由的嵌套</li>
</ul>
<p>13、vuex的理解</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>页面DOM节点太多，会出现什么问题？如何优化？</li>
<li>如何做性能监测</li>
</ul>
<h2 id="SEO和语义化"><a href="#SEO和语义化" class="headerlink" title="SEO和语义化"></a>SEO和语义化</h2><p>微信小程序和h5差异，如果有开发weex的经验，可能会加上weex</p>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>微信小程序和h5差异，如果有开发weex的经验，可能会加上weex</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>一些基本命令</p>
<h2 id="打包工具webpack"><a href="#打包工具webpack" class="headerlink" title="打包工具webpack"></a>打包工具webpack</h2><p>1、打包原理</p>
<p>2、打包插件</p>
<p>3、webpack热更新原理</p>
<p>4、优化构建速度</p>
<h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><p>1、排序算法</p>
<p>2、动态规划，参见背包问题</p>
<p>3、二叉树</p>
<p>4、加油站问题(贪心算法)</p>
<p>5、二分法</p>
<p>6、二叉树遍历</p>
<p>7、单链表反转</p>
<p>8、取1000个数字里面的质数</p>
<p>9、找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。</p>
<p>10、线性顺序存储结构和链式存储结构有什么区别？以及优缺点</p>
<h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>1、自适应</p>
<p>2、pwa</p>
<p>3、移动端手势</p>
<h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><p>1、无限滚动方案</p>
<p>2、如何处理兼容性问题</p>
<p>3、你遇到过最难的问题是什么</p>
<p>4、ES6 class与ES5 function区别及联系</p>
<p>5、vue怎么监听数组</p>
<p>6、写过webpack loader吗</p>
<p>7、微信网页版登录机制思考</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title>动态切换elementui主题</title>
    <url>/2021/03/06/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2elementui%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h4 id="准备自定义的主题"><a href="#准备自定义的主题" class="headerlink" title="准备自定义的主题"></a>准备自定义的主题</h4><blockquote>
<p>在<a class="link"   href="https://element.eleme.cn/#/zh-CN/theme" >element ui<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>官网主题页下载自定义后的主题，多套主题存放本地，两者有不同的命名空间，如写两套主题，一套叫 <code>theme-dark</code>，一套叫 <code>theme-light</code> ，主题都在它的 <code>.theme-dark</code>或<code>.theme-light</code> 的命名空间下</p>
</blockquote>
<h4 id="批量为css文件扩展命名空间"><a href="#批量为css文件扩展命名空间" class="headerlink" title="批量为css文件扩展命名空间"></a>批量为css文件扩展命名空间</h4><blockquote>
<p>使用gulp-css-wrap将这个主题的每个元素外面包裹一个class 来做命名空间。</p>
</blockquote>
<ol>
<li><p>创建一个新的项目<code>css-wrap</code>，并初始化搭建gulp环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1.安装gulp：</span><br><span class="line">npm install gulp</span><br><span class="line">// 2.安装gulp-clean-css</span><br><span class="line">npm install gulp-clean-css</span><br><span class="line">// 3.安装gulp-css-wrap</span><br><span class="line">npm install gulp-css-wrap</span><br></pre></td></tr></table></figure></div>

</li>
<li><p>在项目根目录下创建一个名为 gulpfile.js 的文件</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cleanCSS = <span class="built_in">require</span>(<span class="string">&#x27;gulp-clean-css&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> cssWrap = <span class="built_in">require</span>(<span class="string">&#x27;gulp-css-wrap&#x27;</span>)</span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;css-wrap&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.<span class="title function_">src</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;./theme/index.css&#x27;</span>))</span><br><span class="line">  <span class="comment">/* 找需要添加命名空间的css文件，支持正则表达式 */</span></span><br><span class="line">  .<span class="title function_">pipe</span>(<span class="title function_">cssWrap</span>(&#123;</span><br><span class="line">      <span class="attr">selector</span>: <span class="string">&#x27;.custom-dark&#x27;</span> <span class="comment">/* 添加的命名空间 */</span></span><br><span class="line">  &#125;))</span><br><span class="line">  .<span class="title function_">pipe</span>(<span class="title function_">cleanCSS</span>())</span><br><span class="line">  .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;src/theme&#x27;</span>)) <span class="comment">/* 存放的目录 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将生成在<code>scr/theme</code>下的css和字体文件复制到所需项目中</p>
</li>
</ol>
<h4 id="项目中动态切换主题"><a href="#项目中动态切换主题" class="headerlink" title="项目中动态切换主题"></a>项目中动态切换主题</h4><ol>
<li>在<code>main.js</code>中引入全部所需的css主题样式</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>; <span class="comment">// 基础css不能少，否则一些组件会丢失样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../src/styles/theme/dark.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../src/styles/theme/light.css&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>设置<code>App.vue</code>入口页面中<code>#app</code>的元素的类名为默认主题的名称</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot; class=&quot;custom-dark&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>修改<code>#app</code>元素的类目切换主题</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&#x27;custom-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">theme</span>);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>elementui</tag>
      </tags>
  </entry>
  <entry>
    <title>大前端学习资源</title>
    <url>/2020/01/18/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>vue.js高仿饿了么（1-13章全）<br>链接：<a class="link"   href="https://pan.baidu.com/s/1qYSiYXluA1AlEV0EskxWZw" >https://pan.baidu.com/s/1qYSiYXluA1AlEV0EskxWZw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：25z9</p>
<p>Vue.js 2.5 + cube-ui 重构饿了么 App<br>链接：<a class="link"   href="https://pan.baidu.com/s/1UZyLkzYMvhUhhX3GH5ITvA" >https://pan.baidu.com/s/1UZyLkzYMvhUhhX3GH5ITvA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：bx53</p>
<p>Vue2.0 + Node.js + MongoDB全栈打造商城系统<br>链接：<a class="link"   href="https://pan.baidu.com/s/1EmAvM3kryVQa3mQkwSY_Aw" >https://pan.baidu.com/s/1EmAvM3kryVQa3mQkwSY_Aw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：3fqt</p>
<p>Vue 2.0 高级实战-开发移动端音乐 WebApp<br>链接：<a class="link"   href="https://pan.baidu.com/s/1RvF1KziTgq4HEaIVnCvz1w" >https://pan.baidu.com/s/1RvF1KziTgq4HEaIVnCvz1w<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：v0vb</p>
<p>vue去哪儿无密APP<br>链接：<a class="link"   href="https://pan.baidu.com/s/1vQMWuSNJJ8OrxoGVcZTgtw" >https://pan.baidu.com/s/1vQMWuSNJJ8OrxoGVcZTgtw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：u3yz</p>
<p>Vue全家桶+SSR+Koa2全栈开发美团网<br>链接：<a class="link"   href="https://pan.baidu.com/s/1S3bkusvC14OiyoufCAgGnw" >https://pan.baidu.com/s/1S3bkusvC14OiyoufCAgGnw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：mr70</p>
<p>7天搞定Node.js微信公众号开发<br>链接：<a class="link"   href="https://pan.baidu.com/s/1Aw6be7tp8ysDs0N1H7Kf_Q" >https://pan.baidu.com/s/1Aw6be7tp8ysDs0N1H7Kf_Q<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：gf6q</p>
<p>Vue + Node + MongoDB高级全栈<br>链接：<a class="link"   href="https://pan.baidu.com/s/1dK5XH_Uxi21dZTYwGR-KkQ" >https://pan.baidu.com/s/1dK5XH_Uxi21dZTYwGR-KkQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：ta3s</p>
<p>MUI 仿豆瓣电影 APP跨平台混编框架<br>链接：<a class="link"   href="https://pan.baidu.com/s/1CErOI6eWLEhf3qJeSALAng" >https://pan.baidu.com/s/1CErOI6eWLEhf3qJeSALAng<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：59qs</p>
<p>Vue2.x实战项目(axios路由vuex)<br>链接：<a class="link"   href="https://pan.baidu.com/s/1YPYORI7SnHgGo5Gq7zzGsA" >https://pan.baidu.com/s/1YPYORI7SnHgGo5Gq7zzGsA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：so0h</p>
<p>webApp书城整站开发<br>链接：<a class="link"   href="https://pan.baidu.com/s/1nA7CXe_1IYnmQibK3-ETig" >https://pan.baidu.com/s/1nA7CXe_1IYnmQibK3-ETig<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：orul</p>
<p>Koa2框架从0开始构建预告片网站<br>链接：<a class="link"   href="https://pan.baidu.com/s/1UiwmhLnX1XOCLCAg_rLJwA" >https://pan.baidu.com/s/1UiwmhLnX1XOCLCAg_rLJwA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：l0kj</p>
<p>响应式网页制作实战项目<br>链接：<a class="link"   href="https://pan.baidu.com/s/1pHEe8p0b3f-JbQ7A0D1Xhw" >https://pan.baidu.com/s/1pHEe8p0b3f-JbQ7A0D1Xhw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：7lon</p>
<p>尚硅谷VUE核心技术视频<br>链接：<a class="link"   href="https://pan.baidu.com/s/1hYxRi5nw82Au9AKdvo4RhQ" >https://pan.baidu.com/s/1hYxRi5nw82Au9AKdvo4RhQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：aooh</p>
<p>Vue核心技术 vue实战精讲<br>链接：<a class="link"   href="https://pan.baidu.com/s/1yPHkknNC1IVZIoL0TJoeJA" >https://pan.baidu.com/s/1yPHkknNC1IVZIoL0TJoeJA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：e1kf</p>
<p>Ionic2飞速上手的跨平台App开发<br>链接：<a class="link"   href="https://pan.baidu.com/s/1y3psOTyHez06Xfe9Jb-tWw" >https://pan.baidu.com/s/1y3psOTyHez06Xfe9Jb-tWw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：0eje</p>
<p>快速上手Ionic3 多平台开发企业级问答社区<br>链接：<a class="link"   href="https://pan.baidu.com/s/1OJhxoef5v6BL9W6MnjNZ3Q" >https://pan.baidu.com/s/1OJhxoef5v6BL9W6MnjNZ3Q<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：souy</p>
<p>Webpack + React全栈工程架构项目实战精讲<br>链接：<a class="link"   href="https://pan.baidu.com/s/1-H5r17wvTPcnbV2inKFiag" >https://pan.baidu.com/s/1-H5r17wvTPcnbV2inKFiag<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：13w6</p>
<p>Redux + react + Router + Node.js全栈开发<br>链接：<a class="link"   href="https://pan.baidu.com/s/1YHkdAMBjjIYJr0PKU-IzKQ" >https://pan.baidu.com/s/1YHkdAMBjjIYJr0PKU-IzKQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：vo4x</p>
<p>React16 + React-Router4 从零打造企业级电商后台管理系统<br>链接：<a class="link"   href="https://pan.baidu.com/s/1Yf6N2mujJSn-jtqRFCICQw" >https://pan.baidu.com/s/1Yf6N2mujJSn-jtqRFCICQw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：vvy4</p>
<p>React.js入门与实战[开发适配PC端及移动端新闻头条平台]<br>链接：<a class="link"   href="https://pan.baidu.com/s/1Sz15gI2jYnD2U9jr2XJLkg" >https://pan.baidu.com/s/1Sz15gI2jYnD2U9jr2XJLkg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：tpe2</p>
<p>React 高级实战 打造大众点评 WebApp<br>链接：<a class="link"   href="https://pan.baidu.com/s/1AKe554VkBSdoWmeYnLGsEg" >https://pan.baidu.com/s/1AKe554VkBSdoWmeYnLGsEg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：6f36</p>
<p>React Native开发App狗狗说<br>链接：<a class="link"   href="https://pan.baidu.com/s/17Jdq1PwbgTvx7q54xMHMaw" >https://pan.baidu.com/s/17Jdq1PwbgTvx7q54xMHMaw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：zlay</p>
<p>掌握React Native技术转型随意切换<br>链接：<a class="link"   href="https://pan.baidu.com/s/1sj654WJ6QFM8Muc6ZCdG7g" >https://pan.baidu.com/s/1sj654WJ6QFM8Muc6ZCdG7g<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：icuo</p>
<p>Angular JS 仿拉勾网 WebApp<br>链接：<a class="link"   href="https://pan.baidu.com/s/1EaEdEkFZMLvI3NNPYodc5A" >https://pan.baidu.com/s/1EaEdEkFZMLvI3NNPYodc5A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：5tkc</p>
<p>Angular 打造企业级协作平台<br>链接：<a class="link"   href="https://pan.baidu.com/s/1vEsBm8drlsyYI3vYVT1m7A" >https://pan.baidu.com/s/1vEsBm8drlsyYI3vYVT1m7A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：vysn</p>
<p>Angular 4.0从入门到实战 打造股票管理网站<br>链接：<a class="link"   href="https://pan.baidu.com/s/1CKOtDYw25maVbkYDh84qig" >https://pan.baidu.com/s/1CKOtDYw25maVbkYDh84qig<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：kodf</p>
<p>AngularJS全栈开发知乎<br>链接：<a class="link"   href="https://pan.baidu.com/s/1wUHp0kF1wcDBNpH4qUOJrg" >https://pan.baidu.com/s/1wUHp0kF1wcDBNpH4qUOJrg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：bbi6</p>
<p>手把手从0打造电商平台<br>链接：<a class="link"   href="https://pan.baidu.com/s/1o81d8TozMI72MX_IIRCD9w" >https://pan.baidu.com/s/1o81d8TozMI72MX_IIRCD9w<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：bq1y</p>
<p>ES6+ 开发电商网站的账号体系 JS SDK<br>链接：<a class="link"   href="https://pan.baidu.com/s/19Tqk4ERUM7m3PdhGDAss7A" >https://pan.baidu.com/s/19Tqk4ERUM7m3PdhGDAss7A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：12dk</p>
<p>ES6零基础教学 解析彩票项目<br>链接：<a class="link"   href="https://pan.baidu.com/s/1A7gSrfadxw88lVwiP98Skg" >https://pan.baidu.com/s/1A7gSrfadxw88lVwiP98Skg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：cdd7</p>
<p>Node.js入门到企业Web开发中的应用<br>链接：<a class="link"   href="https://pan.baidu.com/s/1Qt252KSqSAIJi-EmKib4PQ" >https://pan.baidu.com/s/1Qt252KSqSAIJi-EmKib4PQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：qnrd</p>
<p>Node.js项目线上服务器部署与发布<br>链接：<a class="link"   href="https://pan.baidu.com/s/1WmKWjLzuuGXbkK9qFnrLeQ" >https://pan.baidu.com/s/1WmKWjLzuuGXbkK9qFnrLeQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：c6md</p>
<p>四大维度解锁 Webpack 3.0 前端工程化<br>链接：<a class="link"   href="https://pan.baidu.com/s/1hXgm27tTZoRBN8HCE7W0Hw" >https://pan.baidu.com/s/1hXgm27tTZoRBN8HCE7W0Hw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：85yw</p>
<p>6小时 jQuery开发一个前端应用<br>链接：<a class="link"   href="https://pan.baidu.com/s/1hwO36zQKZp1gKx6mHxKQ_w" >https://pan.baidu.com/s/1hwO36zQKZp1gKx6mHxKQ_w<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：hnao</p>
<p>HTTP协议原理+实践 Web开发工程师必学<br>链接：<a class="link"   href="https://pan.baidu.com/s/1isAvkjKOMLsWGGNckOXsPw" >https://pan.baidu.com/s/1isAvkjKOMLsWGGNckOXsPw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：mk98</p>
<p>微信小程序入门与实战<br>链接：<a class="link"   href="https://pan.baidu.com/s/10SJrD-S10CQOA4Z_KGZRTw" >https://pan.baidu.com/s/10SJrD-S10CQOA4Z_KGZRTw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：njaz</p>
<p>全新升级 Kotlin系统入门与进阶<br>链接：<a class="link"   href="https://pan.baidu.com/s/1WF6ORDNrg4Mel4HllX0zTg" >https://pan.baidu.com/s/1WF6ORDNrg4Mel4HllX0zTg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：h4mn</p>
<p>Kotlin打造完整电商APP 模块化 + MVP + 主流框架<br>链接：<a class="link"   href="https://pan.baidu.com/s/1CW-EV7HU70btAOs_v0uMVQ" >https://pan.baidu.com/s/1CW-EV7HU70btAOs_v0uMVQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：nrht</p>
<p>开课吧第六期全栈架构师<br>链接：<a class="link"   href="https://pan.baidu.com/s/1Z2zHnDBA1VzzznnGoVvscQ" >https://pan.baidu.com/s/1Z2zHnDBA1VzzznnGoVvscQ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：ncqj</p>
<p>爱前端-邵山欢大前端全套完整教程<br>链接：<a class="link"   href="https://pan.baidu.com/s/1cp9XG8eVFc-IBFUt7sjCUA" >https://pan.baidu.com/s/1cp9XG8eVFc-IBFUt7sjCUA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：bbys</p>
<p>2018新黑马39期web前端开发全套视频教程（没有源码）<br>链接：<a class="link"   href="https://pan.baidu.com/s/1LjVsI1dsyjJXHcLM9MAjFg" >https://pan.baidu.com/s/1LjVsI1dsyjJXHcLM9MAjFg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>提取码：14k3</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>后台管理系统的权限控制与管理</title>
    <url>/2021/11/18/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>前言: 前端权限的控制本质上来说， 就是控制端的<strong>视图层的展示</strong>和前端所发送的<strong>请求</strong>。但是只有前端权限控制没有后端权限控制是万万不可的。 前端权限控制只可以说是达到锦上添花的效果。</p>
</blockquote>
<h2 id="前端权限的意义"><a href="#前端权限的意义" class="headerlink" title="前端权限的意义"></a>前端权限的意义</h2><p>进行前端权限的控制， 主要有这几方面的好处</p>
<ul>
<li>降低非法操作的可能性</li>
<li>尽可能排除不必要清求， 减轻服务器压力</li>
<li>提高用户体验</li>
</ul>
<h2 id="前端权限控制思路"><a href="#前端权限控制思路" class="headerlink" title="前端权限控制思路"></a>前端权限控制思路</h2><h3 id="菜单的控制"><a href="#菜单的控制" class="headerlink" title="菜单的控制"></a>菜单的控制</h3><p>在登录请求中， 会得到权限数据， 当然， 这个需要后端返回数据的支持． 前端根据权限数据， 展示对应的菜单． 点击菜单， 才能查看相关的界面</p>
<h3 id="界面的控制"><a href="#界面的控制" class="headerlink" title="界面的控制"></a>界面的控制</h3><p>如果用户没有登录， 手动在地址栏敲入管理界面的地址， 则需要跳转到登录界面<br>如果用户已经登录， 如果手动敲入非权限内的地址， 则需要跳转404 界面</p>
<h3 id="按钮的控制"><a href="#按钮的控制" class="headerlink" title="按钮的控制"></a>按钮的控制</h3><p>在某个菜单的界面中， 还得根据权限数据， 展示出可进行操作的按钮，比如删除， 修改， 增加</p>
<h3 id="请求和响应的控制"><a href="#请求和响应的控制" class="headerlink" title="请求和响应的控制"></a>请求和响应的控制</h3><p>如果用户通过非常规操作， 比如通过浏览器调试工具将某些禁用的按钮变成启用状态， 此时发的请求， 也应该被前端所拦截</p>
<h2 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h2><h3 id="3-1-权限菜单栏控制"><a href="#3-1-权限菜单栏控制" class="headerlink" title="3.1 权限菜单栏控制"></a>3.1 权限菜单栏控制</h3><p>用户登录之后服务端返回一个数据，这个数据有菜单列表和<code>token</code>，我们把这个数据放入到<code>vuex</code>中，然后主页根据<code>vuex</code>中的数据进行菜单列表的渲染</p>
<p><strong>问题：</strong> 刷新界面<code>vuex</code>数据消失，菜单栏消失</p>
<p><strong>解决：</strong> 将数据存储在<code>sessionStorage</code>中，并让其和<code>vuex</code>中的数据保持同步</p>
<h3 id="3-2-界面的控制"><a href="#3-2-界面的控制" class="headerlink" title="3.2 界面的控制"></a>3.2 界面的控制</h3><p>登录成功后，将<code>token</code>数据存储在<code>sessionStorage</code>中，判断是否登录</p>
<h3 id="1-路由导航守卫"><a href="#1-路由导航守卫" class="headerlink" title="1. 路由导航守卫"></a>1. 路由导航守卫</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">	if(to.path !== &#x27;/login&#x27;) &#123;</span><br><span class="line">		const token = sessionStorage.getItem(&#x27;tokem&#x27;)</span><br><span class="line">		if(!toke)&#123;</span><br><span class="line">			next(&#x27;/login&#x27;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>问题：</strong> 这样用户在登录之后就可以访问其他界面了，但如果用户<code>A</code>登录之后他只能访问<code>a</code>页面，他不能访问<code>b</code>页面，但是这时候他还是可以通过地址栏输入进入到<code>b</code>页面</p>
<p><strong>解决：</strong> 当然我们也可以设置路由导航守卫，但是如果有多个页面，设置会非常不方便，并且对于用户<code>A</code>来说，它是不用访问<code>b</code>页面的，这时候我们何不对<code>A</code>不显示<code>b</code>页面，这个时候我们就用到了<code>动态路由</code></p>
<h3 id="2-动态路由"><a href="#2-动态路由" class="headerlink" title="2. 动态路由"></a>2. 动态路由</h3><p>根据当前用户所拥有的的权限数据来动态添加所需要的路由</p>
<ol>
<li><p>先定义好所有的路由规则</p>
</li>
<li><p>登录成功之后动态添加路由，注意这个<code>initDynamicRoutes</code>的方法需要暴露出去在登录页面调用</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initDynamicRoutes</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 根据二级权限， 对路由规则进行动态添加</span></span><br><span class="line">	<span class="keyword">const</span> currentRoutes = router.<span class="property">options</span>.<span class="property">routes</span> <span class="comment">// 获取当前路由</span></span><br><span class="line">	<span class="keyword">const</span> rightList = store.<span class="property">state</span>.<span class="property">rightList</span> <span class="comment">// 拥有权限的列表</span></span><br><span class="line">	rightList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">		item.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">			cinst temp = ruleMapping[item.<span class="property">path</span>]</span><br><span class="line">			temp.<span class="property">meta</span> = item.<span class="property">rights</span> <span class="comment">// 设置路由元信息</span></span><br><span class="line">			currentRouters[<span class="number">2</span>].<span class="property">children</span>.<span class="title function_">push</span>(temp) <span class="comment">// 添加动态路由</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>这样当用户A在地址栏输入自己不能访问的路由时，则不会跳转到该页面，跳转到404页面</p>
<p><strong>问题：</strong> 如果我们重新刷新的话动态路由就会消失，动态路由是在登录成功之后才会调用的，刷新的时候并没有调用，所以动态路由没有添加上</p>
<p><strong>解决：</strong> 可以在<code>app.vue</code>中的<code>created中</code>调用添加动态路由的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">	name: &#x27;app&#x27;,</span><br><span class="line">	created() &#123;</span><br><span class="line">		initDynamicRoutes()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-按钮的控制"><a href="#3-3-按钮的控制" class="headerlink" title="3.3 按钮的控制"></a>3.3 按钮的控制</h2><p>虽然用户可以看到某些界面了， 但是这个界面的一些按钮该用户可能是没有权限的。 因此， 我们需要对组件中的一些按钮进行控制， 用户不具备权限的按钮就隐藏或者禁用， 而在这块的实现中， 可以把该逻辑放到自定义指令中，比如我们可以根据后端返回的数据<code>right</code>来判断用户有什么权限</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// =&gt; rights: [&#x27;view&#x27;]</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	id<span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">  name<span class="punctuation">:</span> &#x27;商品管理&#x27;，</span><br><span class="line">  children<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  	<span class="punctuation">&#123;</span></span><br><span class="line">  		id<span class="punctuation">:</span> <span class="number">101</span></span><br><span class="line">  		name<span class="punctuation">:</span> &#x27;商品列表&#x27;</span><br><span class="line">  		path： &#x27;goods&#x27;</span><br><span class="line">  		rights<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;view&#x27;<span class="punctuation">,</span> &#x27;add&#x27;<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>创建自定义指令：permission.js</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;permission&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">inserted</span>: <span class="keyword">function</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> action = binding.<span class="property">value</span>.<span class="property">action</span> <span class="comment">// 对应自定义指令中的add</span></span><br><span class="line">		<span class="keyword">const</span> currentRight = router.<span class="property">currentRoute</span>.<span class="property">meta</span> <span class="comment">//获取当前路由元信息</span></span><br><span class="line">		<span class="keyword">if</span>(currentRight &amp;&amp; currentRight.<span class="title function_">indexOf</span>(action) == -<span class="number">1</span>) &#123; <span class="comment">// 判断当前路由对应的组件中，用户是否具备action的权限</span></span><br><span class="line">			<span class="comment">// 没有权限</span></span><br><span class="line">			<span class="keyword">const</span> type = binding.<span class="property">value</span>.<span class="property">effect</span></span><br><span class="line">			<span class="comment">// 根据类型参数 type 对元素进行禁用或移除操作</span></span><br><span class="line">			<span class="keyword">if</span>(type === <span class="string">&#x27;disabled&#x27;</span>) &#123; </span><br><span class="line">				el.<span class="property">disabled</span> = <span class="literal">true</span></span><br><span class="line">				el.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;is-disabled&#x27;</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(ed)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>


<p>添加自定义指令 控制按钮</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-button</span><br><span class="line">  type=&#x27;primary&#x27;</span><br><span class="line">  v-permission = &#x27;&#123;action: &quot;add&quot;, effect: &quot;disabled&quot;&#125;&#x27;</span><br><span class="line">&gt; 添加用户</span><br><span class="line">&lt;/el-button&gt;</span><br></pre></td></tr></table></figure></div>




<h2 id="3-4-请求和响应的控制"><a href="#3-4-请求和响应的控制" class="headerlink" title="3.4 请求和响应的控制"></a>3.4 请求和响应的控制</h2><h3 id="请求控制"><a href="#请求控制" class="headerlink" title="请求控制"></a>请求控制</h3><p>如果发出了非权限内的请求， 应该直接在前端范围内阻止：比如a用户是不能够操作该页面的按钮的，但是他通过f12调试把按钮改为可点击，如果我们不对这个请求进行处理，那么这个请求就会发送出去</p>
  <div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;../router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actionMapping = &#123;</span><br><span class="line">	<span class="attr">get</span>: <span class="string">&#x27;view&#x27;</span>,</span><br><span class="line">	<span class="attr">post</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">	<span class="attr">put</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">	<span class="attr">delete</span>: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">req</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> currentUrl = req.<span class="property">url</span></span><br><span class="line">	 <span class="keyword">if</span>(currentUrl !== <span class="string">&#x27;login&#x27;</span>) &#123; <span class="comment">// 不是登录的请求，在请求头中加入token</span></span><br><span class="line">    req.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">		<span class="keyword">const</span> method = req.<span class="property">method</span>  <span class="comment">// 获取请求方法</span></span><br><span class="line">		<span class="keyword">const</span> action = actionMapping[method] <span class="comment">// 获取请求方法约定的action</span></span><br><span class="line">		<span class="comment">// 判断 action 是否存在当前路由的权限中</span></span><br><span class="line">		<span class="keyword">const</span> rights = router.<span class="property">currentRouter</span>.<span class="property">meta</span></span><br><span class="line">		<span class="keyword">if</span>(rights &amp;&amp; rights.<span class="title function_">indexOf</span>(action) == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 没有权限</span></span><br><span class="line">			<span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;没有权限&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> req</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="响应控制"><a href="#响应控制" class="headerlink" title="响应控制"></a>响应控制</h3><p>得到了服务器返回的状态码401, 代表token 超时或者被篡改了，此时应该强制跳转到登录界面</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">meta</span>.<span class="property">status</span> === <span class="number">401</span>)&#123;</span><br><span class="line">    router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>前端权限的实现必须要后端提供数据支持， 返回的权限数据的结构， 前后端需要沟通协商怎样的数据便用起来才最方便</p>
<h3 id="菜单控制"><a href="#菜单控制" class="headerlink" title="菜单控制"></a>菜单控制</h3><ul>
<li>权限的数据需要在多组件之间共享， 因此采用<code>vuex</code></li>
<li>防止刷新界面， 权限数据丢失， 所以需要存在<code>sessionStorage</code>， 并目要保证两者的同步</li>
</ul>
<h3 id="界面控制"><a href="#界面控制" class="headerlink" title="界面控制"></a>界面控制</h3><ul>
<li>路由的导航守卫可以防止跳过登录界面</li>
<li>动态路由可以让不具备权限的界面的路由规则压根就不存在</li>
</ul>
<h3 id="按钮控制"><a href="#按钮控制" class="headerlink" title="按钮控制"></a>按钮控制</h3><ul>
<li>路由规则中可以增加路由元数据meta</li>
<li>通过路由对象可以得到当前的路由规则以及存在此规则中的meta 数据</li>
<li>自定义指令可以很方便的实现按钮控制</li>
</ul>
<h3 id="请求和响应控制"><a href="#请求和响应控制" class="headerlink" title="请求和响应控制"></a>请求和响应控制</h3><ul>
<li><p>请求拦截器和响应拦截器的使用</p>
</li>
<li><p>请求方式和风格的约定<code>restful</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// restful风格请求</span></span><br><span class="line"><span class="comment">// get: view</span></span><br><span class="line"><span class="comment">// post: add</span></span><br><span class="line"><span class="comment">// put: edit</span></span><br><span class="line"><span class="comment">// delete: delete</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>权限控制</tag>
      </tags>
  </entry>
  <entry>
    <title>移动常见兼容问题</title>
    <url>/2021/11/18/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E7%A7%BB%E5%8A%A8%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>移动端</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>开启gzip压缩</title>
    <url>/2022/03/06/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E5%BC%80%E5%90%AFgzip%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<ol>
<li><p>首先安装插件 <code>npm i compression-webpack-plugin@10.0.0 </code></p>
</li>
<li><p>添加 vue.config.js 项目配置</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;compression-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 开发环境不配置</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 生产环境才去配置</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;</span><br><span class="line">          <span class="comment">// filename: &quot;[path][base].gz&quot;, // 这种方式是默认的，多个文件压缩就有多个.gz文件，建议使用下方的写法</span></span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&#x27;[path][base].gz[query]&#x27;</span>, <span class="comment">//  使得多个.gz文件合并成一个文件，这种方式压缩后的文件少，建议使用</span></span><br><span class="line">          <span class="attr">algorithm</span>: <span class="string">&#x27;gzip&#x27;</span>, <span class="comment">// 官方默认压缩算法也是gzip</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/\.js$|\.css$|\.html$|\.ttf$|\.eot$|\.woff$/</span>, <span class="comment">// 使用正则给匹配到的文件做压缩</span></span><br><span class="line">          <span class="attr">threshold</span>: <span class="number">10240</span>, <span class="comment">//以字节为单位压缩超过此大小的文件，使用默认值10240吧</span></span><br><span class="line">          <span class="attr">minRatio</span>: <span class="number">0.8</span>, <span class="comment">// 最小压缩比率，官方默认0.8</span></span><br><span class="line">          <span class="comment">//是否删除原有静态资源文件，即只保留压缩后的.gz文件，建议这个置为false，还保留源文件。以防：</span></span><br><span class="line">          <span class="comment">// 假如出现访问.gz文件访问不到的时候，还可以访问源文件双重保障</span></span><br><span class="line">          <span class="attr">deleteOriginalAssets</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>项目执行 <code>npm run build</code> 打包构建,目录dist&#x2F;js 文件就会生成 xxx.js.gz 文件。说明压缩成功</p>
</li>
<li><p>配置 nginx 服务开启 gzip</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name xxx.com;</span><br><span class="line">    </span><br><span class="line">    location ~* \.(css|js)$ &#123;</span><br><span class="line">       gzip_static on;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"> </span><br><span class="line">    #....其他配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在浏览器中查看配置成功后的状态，项目体积减少，页面加载速度得到明显提升</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/Users/jiangwen/Library/Application%20Support/typora-user-images/image-20230504211812296.png"
                      alt="image-20230504211812296"
                ></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>优化， gzip</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域问题</title>
    <url>/2021/01/01/%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1. 什么是跨域"></a>1. 什么是跨域</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，由浏览器<strong>同源策略</strong>限制导致的一类请求场景</p>
<h3 id="1-1-什么是浏览器同源策略"><a href="#1-1-什么是浏览器同源策略" class="headerlink" title="1.1 什么是浏览器同源策略"></a>1.1 什么是浏览器同源策略</h3><p>同源策略&#x2F;SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指**”协议+域名+端口”**三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<h3 id="1-2-常见跨域场景"><a href="#1-2-常见跨域场景" class="headerlink" title="1.2  常见跨域场景"></a><strong>1.2  常见跨域场景</strong></h3><table>
<thead>
<tr>
<th>URL</th>
<th>说明</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em><a class="link"   href="http://www.domain.com:8000/a.js" >http://www.domain.com:8000/a.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em><br/><em><a class="link"   href="http://www.domain.com/b.js" >http://www.domain.com/b.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></td>
<td>同一域名，不同端口</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><a class="link"   href="http://www.domain.com/a.js" >http://www.domain.com/a.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em><br/><em><a class="link"   href="https://www.domain.com/b.js" >https://www.domain.com/b.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></td>
<td>同一域名，不同协议</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><a class="link"   href="http://www.domain.com/a.js" >http://www.domain.com/a.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em><br/><em><a class="link"   href="http://192.168.4.12/b.js" >http://192.168.4.12/b.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></td>
<td>域名和域名对应相同ip</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*<a class="link"   href="http://www.domain.com/a.js" >http://www.domain.com/a.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br/><a class="link"   href="http://x.domain.com/b.js" >http://x.domain.com/b.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a class="link"   href="http://domain.com/c.js" >http://domain.com/c.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>*</td>
<td>主域相同，子域不同</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em><a class="link"   href="http://www.domain1.com/a.js" >http://www.domain1.com/a.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br/><a class="link"   href="http://www.domain2.com/b.js" >http://www.domain2.com/b.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></em></td>
<td>不同域名</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2.跨域解决方案"></a>2.跨域解决方案</h2><ul>
<li>通过jsonp跨域</li>
<li>document.domain + iframe跨域</li>
<li>location.hash + iframe</li>
<li>window.name + iframe跨域</li>
<li>postMessage跨域</li>
<li>跨域资源共享（CORS）</li>
<li>nginx代理跨域</li>
<li>nodejs中间件代理跨域</li>
<li>WebSocket协议跨域</li>
</ul>
<h4 id="一、-通过jsonp跨域"><a href="#一、-通过jsonp跨域" class="headerlink" title="一、 通过jsonp跨域"></a><strong>一、 通过jsonp跨域</strong></h4><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>1.）原生实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">   script.type = &#x27;text/javascript&#x27;;</span><br><span class="line"></span><br><span class="line">   // 传参并指定回调执行函数为onBack</span><br><span class="line">   script.src = &#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&#x27;;</span><br><span class="line">   document.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   // 回调执行函数</span><br><span class="line">   function onBack(res) &#123;</span><br><span class="line">       alert(JSON.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>服务端返回如下（返回时即执行全局函数）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">onBack(&#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br></pre></td></tr></table></figure></div>

<p>2.）jquery ajax：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;http://www.domain2.com:8080/login&#x27;,</span><br><span class="line">    type: &#x27;get&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,  // 请求方式为jsonp</span><br><span class="line">    jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>3.）vue.js：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$http.jsonp(&#x27;http://www.domain2.com:8080/login&#x27;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &#x27;onBack&#x27;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>后端node.js代码示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var querystring = require(&#x27;querystring&#x27;);</span><br><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.split(&#x27;?&#x27;)[1]);</span><br><span class="line">    var fn = params.callback;</span><br><span class="line"></span><br><span class="line">    // jsonp返回设置</span><br><span class="line">    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/javascript&#x27; &#125;);</span><br><span class="line">    res.write(fn + &#x27;(&#x27; + JSON.stringify(params) + &#x27;)&#x27;);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>jsonp缺点：只能实现get一种请求。</p>
<h4 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a><strong>二、 document.domain + iframe跨域</strong></h4><p>此方案仅限主域相同，子域不同的跨域应用场景。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1.）父窗口：(<a class="link"   href="http://www.domain.com/a.html)" >http://www.domain.com/a.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    var user = &#x27;admin&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.）子窗口：(<a class="link"   href="http://child.domain.com/b.html)" >http://child.domain.com/b.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &#x27;domain.com&#x27;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    alert(&#x27;get js data from parent ---&gt; &#x27; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a><strong>三、 location.hash + iframe跨域</strong></h4><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1.）a.html：(<a class="link"   href="http://www.domain1.com/a.html)" >http://www.domain1.com/a.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line"></span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &#x27;#user=admin&#x27;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&#x27;data from c.html ---&gt; &#x27; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.）b.html：(<a class="link"   href="http://www.domain2.com/b.html)" >http://www.domain2.com/b.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>3.）c.html：(<a class="link"   href="http://www.domain1.com/c.html)" >http://www.domain1.com/c.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&#x27;hello: &#x27; + location.hash.replace(&#x27;#user=&#x27;, &#x27;&#x27;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a><strong>四、 window.name + iframe跨域</strong></h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1.）a.html：(<a class="link"   href="http://www.domain1.com/a.html)" >http://www.domain1.com/a.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line"></span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &#x27;http://www.domain1.com/proxy.html&#x27;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&#x27;&#x27;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&#x27;http://www.domain2.com/b.html&#x27;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>2.）proxy.html：(<a class="link"   href="http://www.domain1.com/proxy.html" >http://www.domain1.com/proxy....<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>)<br>中间代理页，与a.html同域，内容为空即可。</p>
<p>3.）b.html：(<a class="link"   href="http://www.domain2.com/b.html)" >http://www.domain2.com/b.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &#x27;This is domain2 data!&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a><strong>五、 postMessage跨域</strong></h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p>
<p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</p>
<p>1.）a.html：(<a class="link"   href="http://www.domain1.com/a.html)" >http://www.domain1.com/a.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&#x27;iframe&#x27;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &#x27;aym&#x27;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &#x27;http://www.domain2.com&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain2 ---&gt; &#x27; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.）b.html：(<a class="link"   href="http://www.domain2.com/b.html)" >http://www.domain2.com/b.html)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&#x27;message&#x27;, function(e) &#123;</span><br><span class="line">        alert(&#x27;data from domain1 ---&gt; &#x27; + e.data);</span><br><span class="line"></span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a><strong>六、 跨域资源共享（CORS）</strong></h4><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p>
<p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p>
<p>目前，所有浏览器都支持该功能(IE8+：IE8&#x2F;9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p>
<h5 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a><strong>1、 前端设置：</strong></h5><p>1.）原生ajax</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure></div>

<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&#x27;post&#x27;, &#x27;http://www.domain2.com:8080/login&#x27;, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;Content-Type&#x27;, &#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">xhr.send(&#x27;user=admin&#x27;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>2.）jQuery ajax</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: true    // 前端设置是否带cookie</span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>3.）vue框架</p>
<p>a.) axios设置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.defaults.withCredentials = true</span><br></pre></td></tr></table></figure></div>

<p>b.) vue-resource设置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.http.options.credentials = true</span><br></pre></td></tr></table></figure></div>

<h5 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a><strong>2、 服务端设置：</strong></h5><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p>
<p>1.）Java后台：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 导入包：import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> * 接口参数中定义：HttpServletResponse response</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#x27;/&#x27;</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); </span><br><span class="line"></span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为&#x27;*&#x27;，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line"></span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;);</span><br></pre></td></tr></table></figure></div>

<p>2.）Nodejs后台示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&#x27;querystring&#x27;);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var postData = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">    // 数据块接收中</span><br><span class="line">    req.addListener(&#x27;data&#x27;, function(chunk) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 数据接收完毕</span><br><span class="line">    req.addListener(&#x27;end&#x27;, function() &#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        // 跨域后台设置</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#x27;Access-Control-Allow-Credentials&#x27;: &#x27;true&#x27;,     // 后端允许发送Cookie</span><br><span class="line">            &#x27;Access-Control-Allow-Origin&#x27;: &#x27;http://www.domain1.com&#x27;,    // 允许访问的域（协议+域名+端口）</span><br><span class="line">            /* </span><br><span class="line">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span><br><span class="line">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span><br><span class="line">             */</span><br><span class="line">            &#x27;Set-Cookie&#x27;: &#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;  // HttpOnly的作用是让js无法读取cookie</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(JSON.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br></pre></td></tr></table></figure></div>

<h4 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a><strong>七、 nginx代理跨域</strong></h4><h5 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a><strong>1、 nginx配置解决iconfont跨域</strong></h5><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a><strong>2、 nginx反向代理接口跨域</strong></h5><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>1.) 前端代码示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:81/?user=admin&#x27;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></div>

<p>2.) Nodejs后台示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&#x27;querystring&#x27;);</span><br><span class="line"></span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line"></span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;Set-Cookie&#x27;: &#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br></pre></td></tr></table></figure></div>

<h4 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a><strong>八、 Nodejs中间件代理跨域</strong></h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<h5 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a><strong>1、 非vue框架的跨域（2次跨域）</strong></h5><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>1.）前端代码示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&#x27;get&#x27;, &#x27;http://www.domain1.com:3000/login?user=admin&#x27;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></div>

<p>2.）中间件服务器：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var proxy = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(&#x27;/&#x27;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &#x27;http://www.domain2.com:8080&#x27;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line"></span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://www.domain1.com&#x27;);</span><br><span class="line">        res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&#x27;Proxy server is listen at port 3000...&#x27;);</span><br></pre></td></tr></table></figure></div>

<p>3.）Nodejs后台同（六：nginx）</p>
<h5 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a><strong>2、 vue框架的跨域（1次跨域）</strong></h5><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<p>webpack.config.js部分配置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &#x27;/login&#x27;,</span><br><span class="line">            target: &#x27;http://www.domain2.com:8080&#x27;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &#x27;www.domain1.com&#x27;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1.）前端代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&#x27;http://www.domain2.com:8080&#x27;);</span><br><span class="line"></span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&#x27;connect&#x27;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        console.log(&#x27;data from server: ---&gt; &#x27; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&#x27;disconnect&#x27;, function() &#123; </span><br><span class="line">        console.log(&#x27;Server socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(&#x27;input&#x27;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.）Nodejs socket后台：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var http = require(&#x27;http&#x27;);</span><br><span class="line">var socket = require(&#x27;socket.io&#x27;);</span><br><span class="line"></span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;Content-type&#x27;: &#x27;text/html&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&#x27;8080&#x27;);</span><br><span class="line">console.log(&#x27;Server is running at port 8080...&#x27;);</span><br><span class="line"></span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&#x27;connection&#x27;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&#x27;message&#x27;, function(msg) &#123;</span><br><span class="line">        client.send(&#x27;hello：&#x27; + msg);</span><br><span class="line">        console.log(&#x27;data from client: ---&gt; &#x27; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&#x27;disconnect&#x27;, function() &#123;</span><br><span class="line">        console.log(&#x27;Client socket has closed.&#x27;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h5 id="二叉查找树（BST）具备什么特性呢？"><a href="#二叉查找树（BST）具备什么特性呢？" class="headerlink" title="二叉查找树（BST）具备什么特性呢？"></a>二叉查找树（BST）具备什么特性呢？</h5><p>1.左子树上所有结点的值均小于或等于它的根结点的值。</p>
<p>2.右子树上所有结点的值均大于或等于它的根结点的值。</p>
<p>3.左、右子树也分别为二叉排序树。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://5b0988e595225.cdn.sohucs.com/images/20171102/202128cf82084e64a251b458f0ddcd9b.jpeg"
                      alt="img"
                ></p>
<h6 id="红黑树-一种平衡二叉树-的特性"><a href="#红黑树-一种平衡二叉树-的特性" class="headerlink" title="红黑树(一种平衡二叉树)的特性:"></a>红黑树(一种平衡二叉树)的特性:</h6><p>1.节点是红色或黑色。(废话)</p>
<p>2.根节点是黑色。</p>
<p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p>
<p>4 每个红色节点的两个子节点都是黑色。(不能有两个连续的红色节点)</p>
<p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点(相同黑高度)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://5b0988e595225.cdn.sohucs.com/images/20171102/eefb5a3397ef4089b356e7c9f0938a8d.jpeg"
                      alt="img"
                ></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>经典排序算法</title>
    <url>/2020/02/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><hr>
<ul>
<li><p><strong>时间复杂度：</strong>一个算法执行所耗费的时间</p>
</li>
<li><p><strong>空间复杂度：</strong>运行完一个程序所需内存的大小</p>
</li>
<li><p><strong>稳定：</strong>元素间相对位置固定，即：如果a原本在b前面，而a&#x3D;b，排序之后a仍然在b的前面</p>
</li>
<li><p><strong>不稳定：</strong>元素间相对位置不固定，即：如果a原本在b的前面，而a&#x3D;b，排序之后a可能会出现在b的后面；</p>
</li>
<li><p><strong>内排序：</strong>所有排序操作都在内存中完成</p>
</li>
<li><p><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</p>
</li>
</ul>
<h2 id="排序方法归纳"><a href="#排序方法归纳" class="headerlink" title="排序方法归纳"></a>排序方法归纳</h2><hr>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒² n)</td>
<td>O(n ㏒² n)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒ n)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒ n)</td>
<td>O(n²)</td>
<td>O(㏒ n)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒ n)</td>
<td>O(n ㏒ n)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="排序方法介绍"><a href="#排序方法介绍" class="headerlink" title="排序方法介绍"></a>排序方法介绍</h2><hr>
<h3 id="1-冒泡排序√"><a href="#1-冒泡排序√" class="headerlink" title="1.冒泡排序√"></a>1.冒泡排序√</h3><blockquote>
<p>从字面上能理解， “冒泡”即小值的浮上来，大值沉下去。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.woshipm.com/wp-files/2018/07/tBe5DiPERN9khb4wBLiR.gif!v.jpg"
                      alt="img"
                ></p>
<p><strong>基本思路</strong></p>
<ul>
<li>第一步比较相邻的元素大小。如果第一个比第二个大，就交换两个元素位置</li>
<li>之后对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数</li>
<li>针对除了最后一位的所有元素重复以上的步骤</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</li>
</ul>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bubbleSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = len; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">                    arr[i] =  arr[j]</span><br><span class="line">                    arr[j] =  temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<hr>
<h3 id="2-选择排序法√"><a href="#2-选择排序法√" class="headerlink" title="2.选择排序法√"></a>2.选择排序法√</h3><blockquote>
<p>选择排序是从冒泡排序演化而来，每一轮比较得出最小值，然后依次和每轮“无序区”中参与比较的第一个值进行交换。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.woshipm.com/wp-files/2018/07/Gv8YsuJtLdTahrWU047a.gif!v.jpg"
                      alt="img"
                ></p>
<p><strong>基本思路</strong></p>
<ul>
<li>初始时在序列中找到最小元素</li>
<li>放到序列的起始位置作为已排序序列</li>
<li>然后再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ul>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectSort = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> min = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != min) &#123;</span><br><span class="line">      <span class="title function_">swap</span>(arr, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i + <span class="number">1</span>, <span class="string">&quot;: &quot;</span> + arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素交换函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swap</span>(<span class="params">arr, index1, index2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp = arr[index1];</span><br><span class="line">  arr[index1] = arr[index2];</span><br><span class="line">  arr[index2] = temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<hr>
<h3 id="3-插入排序√"><a href="#3-插入排序√" class="headerlink" title="3.插入排序√"></a>3.插入排序√</h3><blockquote>
<p>插入排序是基于互相比较的排序。所谓的“比较”，就是通过比较数组中的元素，看谁大谁小，根据结果对应调整元素的位置。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://image.woshipm.com/wp-files/2018/07/HjtcaFfR8pg62X5xihiN.gif!v.jpg"
                      alt="img"
                ></p>
<p><strong>基本思路</strong></p>
<ul>
<li>初始时先默认将第一个元素标记为已排序</li>
<li>然后提取第一个没有排序过的元素，找出插入提取元素的地方并和已经排序过的元素进行比较。</li>
<li>比较大小若条件成立，则将已排序过的元素往右移1个单位，如果条件不成立，则在现有位置直接插入。</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ul>
<p><strong>代码</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">13</span>]</span><br><span class="line"><span class="keyword">var</span> insertSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.<span class="property">length</span>,</span><br><span class="line">        key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = i;</span><br><span class="line">        key = arr[j];  <span class="comment">// 1:key = 3  2:key = 1</span></span><br><span class="line">        <span class="keyword">while</span> (--j &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; key) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];	<span class="comment">// arr[0] = 4 arr[1]=4 key =3</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;	<span class="comment">// arr[0] = 3  arr[1]=4   key=3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>



<hr>
<h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><blockquote>
<p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://forum.mianbaoban.cn/data/attachment/forum/201803/20/140159bsq685wqc58h7zha.gif"
                      alt="img"
                ></p>
<hr>
<h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h3><blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
</blockquote>
<hr>
<h3 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h3><blockquote>
<p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
</blockquote>
<hr>
<h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h3><blockquote>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<hr>
<h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a>8.计数排序</h3><blockquote>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<hr>
<h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9.桶排序"></a>9.桶排序</h3><blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序</p>
</blockquote>
<hr>
<h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10.基数排序"></a>10.基数排序</h3><blockquote>
<p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<h2 id="引用参考："><a href="#引用参考：" class="headerlink" title="引用参考："></a>引用参考：</h2><ol>
<li><a class="link"   href="https://blog.csdn.net/hellozhxy/article/details/79911867" >十大经典排序算法最强总结<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript学习笔记</title>
    <url>/2020/01/01/Javascript/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%9D%E8%AF%86TS%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>TypeScript是一种由微软开发的开源编程语言,它是JavaScript的一个超集,具有以下特性：</p>
</blockquote>
<h5 id="TypeScript-是静态类型"><a href="#TypeScript-是静态类型" class="headerlink" title="TypeScript 是静态类型"></a>TypeScript 是静态类型</h5><blockquote>
<p>类型系统按照「类型检查的时机」来分类，可以分为<code>动态类型和静态类型</code>。</p>
</blockquote>
<p><code>动态类型</code>是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言[<a class="link"   href="http://ts.xcatliu.com/introduction/what-is-typescript.html#link-4" >4]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，没有编译阶段，所以它是<code>动态类型</code>，以下这段代码在运行时才会报错：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line">foo.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: foo.split is not a function</span></span><br><span class="line"><span class="comment">// 运行时会报错（foo.split 不是一个函数），造成线上 bug</span></span><br></pre></td></tr></table></figure></div>

<p><code>静态类型</code>是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 <strong>TypeScript 是静态类型</strong>，这段 TypeScript 代码在编译阶段就会报错了：</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line">foo.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="comment">// Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;.</span></span><br><span class="line"><span class="comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span></span><br></pre></td></tr></table></figure></div>

<p>你可能会奇怪，这段 TypeScript 代码看上去和 JavaScript 没有什么区别呀。</p>
<p>没错！大部分 JavaScript 代码都只需要经过少量的修改（或者完全不用修改）就变成 TypeScript 代码，这得益于 TypeScript 强大的[类型推论][]，即使不去手动声明变量 <code>foo</code> 的类型，也能在变量初始化时自动推论出它是一个 <code>number</code> 类型。</p>
<p>完整的 TypeScript 代码是这样的：</p>
<div class="highlight-container" data-rel="Ts"><figure class="iseeu highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">foo</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">foo.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="comment">// Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;.</span></span><br><span class="line"><span class="comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span></span><br></pre></td></tr></table></figure></div>

<h5 id="TypeScript-是弱类型"><a href="#TypeScript-是弱类型" class="headerlink" title="TypeScript 是弱类型"></a>TypeScript 是弱类型</h5><blockquote>
<p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。</p>
</blockquote>
<p>以下这段代码不管是在 JavaScript 中还是在 TypeScript 中都是可以正常运行的，运行时数字 <code>1</code> 会被隐式类型转换为字符串 <code>&#39;1&#39;</code>，加号 <code>+</code> 被识别为字符串拼接，所以打印出结果是字符串 <code>&#39;11&#39;</code>。</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="comment">// 打印出字符串 &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以<strong>它们都是弱类型</strong>。</p>
<p>作为对比，Python 是强类型，以下代码会在运行时报错：</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span> + <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment"># TypeError: unsupported operand type(s) for +: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>若要修复该错误，需要进行强制类型转换：</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">1</span>) + <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment"># 打印出字符串 &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>强&#x2F;弱是相对的，Python 在处理整型和浮点型相加时，会将整型隐式转换为浮点型，但是这并不影响 Python 是强类型的结论，因为大部分情况下 Python 并不会进行隐式类型转换。相比而言，JavaScript 和 TypeScript 中不管加号两侧是什么类型，都可以通过隐式类型转换计算出一个结果——而不是报错——所以 JavaScript 和 TypeScript 都是弱类型。</p>
</blockquote>
<blockquote>
<p>虽然 TypeScript 不限制加号两侧的类型，但是我们可以借助 TypeScript 提供的类型系统，以及 ESLint 提供的代码检查功能，来限制加号两侧必须同为数字或同为字符串[<a class="link"   href="http://ts.xcatliu.com/introduction/what-is-typescript.html#link-5" >5]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。这在一定程度上使得 TypeScript 向「强类型」更近一步了——当然，这种限制是可选的。</p>
</blockquote>
<p>这样的类型系统体现了 TypeScript 的核心设计理念[<a class="link"   href="http://ts.xcatliu.com/introduction/what-is-typescript.html#link-6" >6]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>：在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型系统来提高代码的可维护性，减少可能出现的 bug。</p>
<h2 id="安装-x2F-使用Typescript"><a href="#安装-x2F-使用Typescript" class="headerlink" title="安装&#x2F;使用Typescript"></a>安装&#x2F;使用Typescript</h2><p>安装</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure></div>
<p>编写一个<code>hello.ts</code>文件</p>
<div class="highlight-container" data-rel="Tsx"><figure class="iseeu highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params"><span class="attr">person</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure></div>

<p>执行手动编译</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure></div>

<p>这时候会生成一个编译好的文件 <code>hello.js</code>：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sayHello</span>(user));</span><br></pre></td></tr></table></figure></div>

<p>在 TypeScript 中，我们使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以。</p>
<p>上述例子中，我们用 <code>:</code> 指定 <code>person</code> 参数类型为 <code>string</code>。但是编译为 js 之后，并没有什么检查的代码被插入进来。</p>
<p>这是因为 <strong>TypeScript 只会在编译时对类型进行静态检查，如果发现有错误，编译的时候就会报错</strong>。而在运行时，与普通的 JavaScript 文件一样，不会对类型进行检查。</p>
<h4 id="VSCode自动编译"><a href="#VSCode自动编译" class="headerlink" title="VSCode自动编译"></a>VSCode自动编译</h4><ol>
<li>在项目中执行<code>tsc --init</code>生成配置文件</li>
<li>修改配置文件<code>tsconfig.json</code>中的一些配置</li>
</ol>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	...</span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es2016&quot;</span><span class="punctuation">,</span>                        <span class="comment">/* 指定编译的JS版本 */</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./js&quot;</span><span class="punctuation">,</span>                          <span class="comment">/* 编译后的js输出目录 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span>                           <span class="comment">/* 是否启用严格模式 */</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>从 vscode 中的 <code>终端 &gt; 运行任务 </code> 选择 <code> tsc:监视 -tsconfig.json</code>执行自动编译</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/image-20230320123710535.png"
                      alt="image-20230320123710535"
                > </p>
<h4 id="运行编译结果"><a href="#运行编译结果" class="headerlink" title="运行编译结果"></a>运行编译结果</h4><p>vscode中安装插件<code>Code Runner</code>，在编译后的js文件中右键选择 Run Code ,可以在控制台查看运行结果；如果想直接在ts文件中运行，查看结果的话，可以需要通过安装<code>npm install -g ts-node</code>，否则结果输出会乱码</p>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>满纸荒唐言</title>
    <url>/2023/03/06/%E7%94%9F%E6%B4%BB%E9%9A%8F%E8%AE%B0/%E6%BB%A1%E7%BA%B8%E8%8D%92%E5%94%90%E8%A8%80/</url>
    <content><![CDATA[<h2 id="阅读书单"><a href="#阅读书单" class="headerlink" title="阅读书单"></a>阅读书单</h2><div class="tabs" id="tab-recommend"><ul class="nav-tabs"><li class="tab active"><a class="#recommend-1">人文社科类</a></li><li class="tab"><a class="#recommend-2">技术类</a></li></ul><div class="tab-content"><div class="tab-pane active" id="recommend-1"><ul>
<li><input checked="" disabled="" type="checkbox"> 《1984》</li>
<li><input checked="" disabled="" type="checkbox"> 《乌合之众》</li>
<li><input checked="" disabled="" type="checkbox"> 《浪潮之巅》</li>
<li><input checked="" disabled="" type="checkbox"> 《中央帝国财经密码》</li>
<li><input checked="" disabled="" type="checkbox"> 《三体》</li>
<li><input checked="" disabled="" type="checkbox"> 《万历十五年》</li>
<li><input checked="" disabled="" type="checkbox"> 《围城》</li>
<li><input checked="" disabled="" type="checkbox"> 《明朝那些事》</li>
<li><input checked="" disabled="" type="checkbox"> 《活着》</li>
<li><input checked="" disabled="" type="checkbox"> 《兄弟》</li>
<li><input disabled="" type="checkbox"> 《中国古代文化常识》</li>
<li><input disabled="" type="checkbox"> 《枪炮、病菌与钢铁》</li>
<li><input disabled="" type="checkbox"> 《月亮与六便士》</li>
<li><input disabled="" type="checkbox"> 《从黎明到衰落》</li>
<li><input disabled="" type="checkbox"> 《国富论》</li>
<li><input disabled="" type="checkbox"> 《人类简史》</li>
<li><input disabled="" type="checkbox"> 《自私的基因》</li>
<li><input disabled="" type="checkbox"> 《学会提问》</li>
<li><input disabled="" type="checkbox"> 《通往奴役之路》</li>
<li><input disabled="" type="checkbox"> 《动物庄园》</li>
</ul></div><div class="tab-pane" id="recommend-2"><ul>
<li><input disabled="" type="checkbox"> 《鸟哥的Linux私房菜》</li>
<li><input disabled="" type="checkbox"> 《JavaScript高级程序设计》</li>
<li><input disabled="" type="checkbox"> 《你不知道的JavaScript》</li>
<li><input disabled="" type="checkbox"> 《JavaScript高级程序设计》</li>
</ul></div></div></div>







<h2 id="阅读摘录"><a href="#阅读摘录" class="headerlink" title="阅读摘录"></a>阅读摘录</h2>
  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《1984》[英]乔治·奥威尔</p>

    </div>
    <div class="notel-content">
      <ul>
<li>战争即和平 自由即奴役 无知即力量。</li>
<li>谁控制了过去，谁就控制了未来；谁控制了现在，谁就控制了过去。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《善与恶的超越》[德]尼采</p>

    </div>
    <div class="notel-content">
      <ul>
<li>与恶龙缠斗过久,自身亦成为恶龙；当你凝视深渊,深渊将回以凝视。</li>
<li>每一个不曾起舞的日子，都是对生命的辜负。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《回答》[中]北岛</p>

    </div>
    <div class="notel-content">
      <ul>
<li>卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《颂歌》[加]莱昂纳德·科恩</p>

    </div>
    <div class="notel-content">
      <ul>
<li>万物皆有裂痕，那是光照进来的地方</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《如果我不曾见过太阳》[美]艾米莉·狄金森</p>

    </div>
    <div class="notel-content">
      <ul>
<li>如果我不曾见到太阳，我本可以忍受黑暗。可如今，太阳把我的寂寞照的更荒凉。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《亲爱的安德烈》[中]龙应台</p>

    </div>
    <div class="notel-content">
      <ul>
<li>我要求你读书用功，不是因为我要你跟别人比成就，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《庄子.秋水》[古]庄子</p>

    </div>
    <div class="notel-content">
      <ul>
<li>井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《月亮与六便士》[英]毛姆</p>

    </div>
    <div class="notel-content">
      <ul>
<li>在爱情的事上如果你考虑起自尊心来，那只能有一个原因：实际上你还是最爱自己。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《月亮与六便士》[英]毛姆</p>

    </div>
    <div class="notel-content">
      <ul>
<li>在爱情的事上如果你考虑起自尊心来，那只能有一个原因：实际上你还是最爱自己。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>[美]海明威</p>

    </div>
    <div class="notel-content">
      <ul>
<li>我们用两年时间学会说话，却要用一辈子学会闭嘴。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>《而已集·小杂感》[中]鲁迅</p>

    </div>
    <div class="notel-content">
      <ul>
<li>楼下一个男人病得要死，那间壁的一家唱着留声机；对面是弄孩子。楼上有两人狂笑；还有打牌声。河中的船上有女人哭着她死去的母亲。人类的悲欢并不相通，我只觉得他们吵闹。</li>
</ul>

    </div>
  </div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-book"></i><p>[中]王小波</p>

    </div>
    <div class="notel-content">
      <ul>
<li>人的一切痛苦，本质上都是对自己的无能的愤怒。</li>
</ul>

    </div>
  </div>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
</search>
