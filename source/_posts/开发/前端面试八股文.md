---
title: 前端面试八股文
tags: [面试]
categories: 前端
date: 2021-03-06 18:50:24
---

## CSS部分

###### 问：css盒模型是什么？

答： 在html中所有的元素都可以看成一个盒子，盒子由外边距`margin`、内边距`padding`、边框`border`、内容`content`四部分构成；盒子的类型分为两种：

- 标准盒模型：`margin border + padding + content`

- IE盒模型：`margin + content(border + padding)`

  通过控制css属性`box-sizing`:  `默认值（标准盒模型）`| `border-box(IE盒模型)`

  总结： 标准盒模型的宽高设置的是内容`content`, IE盒模型的宽高设置的是`border + padding + content`三者相加的总和



###### 问：css选择器的优先级？

答：css的特性包括：继承性、层叠性、优先级；当一个元素有多个样式的时候，显示权重高的样式，权限的优先级分为

`important` > `行内样式` > `id` > `类/伪类/属性`> `标签` > `全局选择器*`



###### 问：隐藏元素的方式有哪些？

答：`display: none` | `opacity: 0` | ` visibility: hidden`，其中只有第一种隐藏方式的元素不占据空间



###### 问：px 和 rem 的区别是什么？

答： `px`属于绝对单位长度，代表显示器上的一个像素单位；`rem`属于相对单位长度，代表相当于`html`根节点的值，例如：

设置根节点的`font-size: 62.5%`,得到的1rem实际单位长度为16px * 62.5% = 10px, 即`1rem = 10px`



###### 问： 重排和重绘有什么区别？

答： 

​		重排也称回流：浏览器渲染引擎会根据所有元素的样式计算出盒模型在页面中的位置和大小；当对Dom的大小、位置进行修改后，引擎需要进行重新计算，就会触发重排机制，重排必然引起重绘。

​		重绘：浏览器渲染引擎计算好盒模型的位置、大小等基本属性后，对每个盒模型的其他特性进行绘制；对Dom的样式进行修改，比如`background-color`,渲染引擎不需要重新计算几何属性，只需对元素的样式进行绘制，就只会触发重绘机制



###### 问: 元素水平垂直居中的方式？

答： 一般常见的有以下几种方式：

```css
/* 方式1: 定位+margin */
  .container {
    ...
    position: relative;
  }
  .box {
    ...
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }

/* 方式2: 定位+transform */
  .container {
    ...
    position: relative;
  }
  .box {
    ...
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
  }

/* 方式3: flex布局 */
  .container {
    ...
    display: flex;
    justify-content: center;
    align-items: center;
  }
/* 方式4: grid布局 */
/* 方式5: table布局 */
```



###### 问: css中哪些属性可以继承？

答：以下元素属性没有设置值时，则默认继承父级属性值:
1. 字体系列属性: `font`、`font-family`、`font-weight`、`font-size`、`fontstyle`
2. 文本属性: `color`、`line-height`、`word-spacing`、`letter-spacing`、` text-transform`、`text-indent`、`text-align`
3. 元素可见性: `visibility`
4. 表格布局属性: `caption-side`、`border-collapse`、`border-spacing`、`empty-cells`、`table-layout`
5. 列表布局属性：`list-style`
6. 光标属性：`cursor`





## HTML部分



## javascript部分

###### 问:  js由哪三部分构成？

答：`ECMAScript`（核心）、`DOM`（文档对象模型）、`BOM`（浏览器对象模型）

问:  js对数据类的检测方式有哪些？



###### 问：js有哪些内置对象？

答：常见的有`String` 、`Number`、`Boolean`、`Array`、`Object`、`Function`、`Math`、`Date`、`RegExp` 等...



答：一般通过以下方式

1. `typeof`:  只能检测基本数据类型
2. `instanceof`: 只能检测引用数据类型
3. `constructor`: 可以判断基本和引用数据类型，但是对于构造函数而言，如果改变它的原型指向，会导致检测结果不正确
4. `Object.prototype.toString.call`: 最佳检测方式

```javascript
const res_1 = typeof '123' // => string
const res_2 = [] instanceof Array // => true

function A(name) {
  this.name = name
}
let a = new A('jiangwen')
const res_3 = a.constructor === A // => true
A.prototype = Array
const res_4 = a.constructor === A // => false , 指向的constructor变为Array
const res_5 = Object.prototype.toString.call('abc') // => [object String]
```



###### 问：什么是闭包，闭包有什么特点？

答： 闭包在[JavaScript高级程序设计](https://so.csdn.net/so/search?q=JavaScript高级程序设计&spm=1001.2101.3001.7020)（第3版）中是这样描述：**闭包是指有权访问另一个函数作用域中的变量的函数。**

闭包的特点是：

- 可以在函数的外部访问到函数内部的局部变量。
- 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。

使用场景:

- 防抖
- 节流
- 函数嵌套避免全局污染



###### 问：前端中的内存泄露是什么？

答： js的垃圾回收机制没有释放已经分配了内存地址的对象，造成长期的内存占用、内存资源浪费，导致运行速度慢，甚至崩溃的情况。会导致内存泄露的因素：

1.  一些未声明直接赋值的变量
2. 未清空的定时器
3. 过渡闭包
4. 引用的元素没有被清除



###### 问：什么是原型链？

答：原型就是一个普通的对象，为构造函数的实例共享属性和方法；所有实例对象中引用的原型都是同一个对象，使用`prototype`可以把属性、方法挂载到原型对象中进行共享，而内存仅需保存一份；实例对象中的属性`__proto__`，指向了构造函数的原型对象`prototype`，一个实例对象在调用属性、方法的时候，会依次从`实例本身 => 构造函数的原型对象 => 原型对象的原型对象`，进行查找，这些原型关系就构成了原型链。

![img](https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/5cdd315c45bc895052.png)

小结

- 所有构造函数的`__proto__`都指向`Function.prototype`，包括Function本身
- 所有原型对象的`__proto__`都指向`Object.prototype`, 而`Object.prototype`本身的`__proto__`指向`null`



###### 问：new 操作符具体做了什么？

答：具体分为以下步骤：

```javascript
  function newFn(Fn, ...args) {
    // 1. 创建一个空对象
    let newObj = {};
    // 2. 把空对象和构造函数通过原型链进行关联
    newObj.__proto__ = Fn.prototype
    // 3. 将构造函数的`this`绑定到空对象上
    let res = Fn.apply(newObj, args)
    // 4. 根据构造函数返回的类型判断；如果是值类型，则返回对象，如果是引用类型，则返回这个引用类型
    return res instanceof Object ? res : newObj
  }
```



###### 问：js是如何实现继承的？

答： 常见的有以下几种方式

1. 原型链继承
2. 借用构造函数继承
3. 组合式继承
4. ES6的class类继承

[详细参考：]: 详细参考：



###### 问：js中关于this指向的问题？

答： 分为以下情况

1. 全局对象中的this指向的是`window`

2. 全局作用域、普通函数中的this指向全局`window`

3. 匿名函数的执行环境具有全局性，因此匿名函数中的this永远指向`window`

4. this永远指向最后调用它的那个对象

5. `new`关键字改变了this的指向

6. 不是箭头函数的时候，`call`、`apply`、`bind`可以改变this的指向

7. 箭头函数中的this指向，在它定义的时候就已经确定了，箭头函数本身没有this，看外层的函数是否有this，有就是外层函数的this，没有就是指向`window`

   

###### 问： async 和 defer 有什么区别？

答：它们两个属性都是指定浏览器进行脚本的异步加载，但是加载后的执行时机不同，`defer`需要所有元素加载完成之后才执行，`async`是`HTML5`新增的属性，只要脚本加载完成之后就马上执行，因此`async`不能确保脚本的执行顺序，而`defer`则可以。



###### 问： ES6的新特性有哪些？

答：有以下新特性：

1. 新增了块级作用域（let，const）

2. 新增了定义类语法糖（class）

3. 新增了基本数据类型（symbol）

4. 新增了解构赋值

5. 新增了函数参数的默认值

6. 新增了数组的API

7. 对象和数组新增了扩展运算符（...）

8. 新增了`promise`

   - 把异步操作队列化，解决了回调地狱的问题
   - 有`all`,`reject`,`resolve`,`race`方法
   - 原型有`then`、`catch`
   - 三种状态`pending`|`rejected`|`fulfilled`, 状态一旦从`pending` => `rejected`或者`pending` => `fulfilled`改变,状态就确定了，不可逆
   - `async`和`await`: 同步代码做异步操作，两者必须搭配使用

9. 新增了模块化（import、export）

10. 新增了set 和map数据结构

    - set 数据结构不存在重复
    - map  数据结构的key类型不受限制

11. 新增了generator构造器

12. 新增了箭头函数

    

###### 问： 箭头函数和普通函数有什么区别？

答：有以下区别

1. 箭头函数不能使用`new`操作符, 来作为构造函数使用
2. 箭头函数没有原型
3. 箭头函数没有`arguments`
4. 箭头函数不能用`call`、`call`、`call`去改变this的执行
5. 箭头函数的this执行外层函数的第一个this



###### 问： 如何实现一个深拷贝？

答：一般可以通过以下方式：

1. 扩展运算符实现

   ```javascript
   let oo_1 = { ...o}  // 缺点： 对于对象中的引用数据类型还是浅拷贝
   ```

   

2. ` JSON.parse(JSON.stringify())`

   ```javascript
     let oo_1 = JSON.parse(JSON.stringify(o))  // 缺点： 对象中的函数不会拷贝
   ```

3. 递归复制

   ```javascript
   /**
   * origin: 拷贝源对象
   * deep: 是否使用深拷贝
   */ 
   function deepClone(origin, deep) {
      let obj = {}
      if (origin instanceof Array) obj = [];
      for (let key in origin) {
        let value = origin[key]
        obj[key] = (!!deep && typeof value === "object" && value !== null) ? deepClone(value, deep) : value
      }
      return obj
   }
   
   let oo_1 = deepClone(o, true)
   ```

   

###### 问： 说一下事件循环？

答： js是一个单线程脚本语言，



## Vue

