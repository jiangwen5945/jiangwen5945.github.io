---
title: 前端的自我修养
tags: [面试]
categories: 前端
date: 2021-03-06 18:50:24
thumbnail: https://jiangwen-blog.oss-cn-fuzhou.aliyuncs.com/images/20ab6cb5cef84475ad912705b3d5da51.webp
---

## CSS & HTML部分

###### 问：css盒模型是什么？

答： 在html中所有的元素都可以看成一个盒子，盒子由外边距`margin`、内边距`padding`、边框`border`、内容`content`四部分构成；盒子的类型分为两种：

- 标准盒模型：`margin border + padding + content`

- IE盒模型：`margin + content(border + padding)`

  通过控制css属性`box-sizing`:  `默认值（标准盒模型）`| `border-box(IE盒模型)`

  总结： 标准盒模型的宽高设置的是内容`content`, IE盒模型的宽高设置的是`border + padding + content`三者相加的总和



###### 问：css选择器的优先级？

答：css的特性包括：继承性、层叠性、优先级；当一个元素有多个样式的时候，显示权重高的样式，权限的优先级分为

`important` > `行内样式` > `id` > `类/伪类/属性`> `标签` > `全局选择器*`



###### 问：隐藏元素的方式有哪些？

答：`display: none` | `opacity: 0` | ` visibility: hidden`，其中只有第一种隐藏方式的元素不占据空间



###### 问：px 和 rem 的区别是什么？

答： `px`属于绝对单位长度，代表显示器上的一个像素单位；`rem`属于相对单位长度，代表相当于`html`根节点的值，例如：

设置根节点的`font-size: 62.5%`,得到的1rem实际单位长度为16px * 62.5% = 10px, 即`1rem = 10px`



###### 问： 重排和重绘有什么区别？

答： 

​		重排也称回流：浏览器渲染引擎会根据所有元素的样式计算出盒模型在页面中的位置和大小；当对Dom的大小、位置进行修改后，引擎需要进行重新计算，就会触发重排机制，重排必然引起重绘。

​		重绘：浏览器渲染引擎计算好盒模型的位置、大小等基本属性后，对每个盒模型的其他特性进行绘制；对Dom的样式进行修改，比如`background-color`,渲染引擎不需要重新计算几何属性，只需对元素的样式进行绘制，就只会触发重绘机制



###### 问: 元素水平垂直居中的方式？

答： 一般常见的有以下几种方式：

```css
/* 方式1: 定位+margin */
  .container {
    ...
    position: relative;
  }
  .box {
    ...
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
  }

/* 方式2: 定位+transform */
  .container {
    ...
    position: relative;
  }
  .box {
    ...
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
  }

/* 方式3: flex布局 */
  .container {
    ...
    display: flex;
    justify-content: center;
    align-items: center;
  }
/* 方式4: grid布局 */
/* 方式5: table布局 */
```



###### 问: css中哪些属性可以继承？

答：以下元素属性没有设置值时，则默认继承父级属性值:
1. 字体系列属性: `font`、`font-family`、`font-weight`、`font-size`、`fontstyle`
2. 文本属性: `color`、`line-height`、`word-spacing`、`letter-spacing`、` text-transform`、`text-indent`、`text-align`
3. 元素可见性: `visibility`
4. 表格布局属性: `caption-side`、`border-collapse`、`border-spacing`、`empty-cells`、`table-layout`
5. 列表布局属性：`list-style`
6. 光标属性：`cursor`



###### 问：怎么画一条0.5px的线？

答：有以下三种方案：
1. 采用meta viewport的方式
2. 采用 border-image的方式
3. 采用transform + 伪类的方式（推荐）
4. 使用box-shadow模拟边框
5. 多背景渐变实现


###### 问：link标签和import标签的区别

答：有以下区别

- link属于html标签，而@import是css提供的
- 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。
- link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。
- link方式样式的权重高于@import的。

###### 问：transition和animation的区别

答：Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是`transition需要触发`一个事件才能改变属性，而`animation不需要触发`任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。



###### 问：BFC是什么？

答：块级格式化上下文，是一个独立的渲染区域，并且有其布局规则。

1. BFC区域不会与float box重叠
2. BFC是页面上的一个独立容器，子元素不会影响到外面
3. 计算BFC的高度时，浮动元素也会参与计算

以下元素会生成BFC：

- 根元素
- float不为none的元素
- position为fixed和absolute的元素
- display为inline-block、table-cell、table-caption，flex，inline-flex的元素
- overflow不为visible的元素

> 可以用于清楚浮动，防止margin重叠等



###### 问：href 和 src 的区别？

答：**href （超文本引用）**会建立当前元素或文档和引用资源进行链接，需要引用资源的时候就会通过通道进行引用，例如：`a` 和 `link`；**src （资源）**会把资源下载下来，替换当前元素，然后嵌入到文档当中，例如：`img` 、`style`、`script`、`input`、 `iframe`



###### 问：css怎么去统一各个浏览器之间的差异？

答：使用`Normalize.css`  实现不同的浏览器之间样式的统一

## javascript部分

###### 问:  js由哪三部分构成？

答：`ECMAScript`（核心）、`DOM`（文档对象模型）、`BOM`（浏览器对象模型）





###### 问：js有哪些内置对象？

答：常见的有`String` 、`Number`、`Boolean`、`Array`、`Object`、`Function`、`Math`、`Date`、`RegExp` 等...



问:  js对数据类的检测方式有哪些？

答：一般通过以下方式

1. `typeof`:  只能检测基本数据类型
2. `instanceof`: 只能检测引用数据类型
3. `constructor`: 可以判断基本和引用数据类型，但是对于构造函数而言，如果改变它的原型指向，会导致检测结果不正确
4. `Object.prototype.toString.call`: 最佳检测方式

```javascript
const res_1 = typeof '123' // => string
const res_2 = [] instanceof Array // => true

function A(name) {
  this.name = name
}
let a = new A('jiangwen')
const res_3 = a.constructor === A // => true
A.prototype = Array
const res_4 = a.constructor === A // => false , 指向的constructor变为Array
const res_5 = Object.prototype.toString.call('abc') // => [object String]
```



###### 问：什么是闭包，闭包有什么特点？

答： 闭包在[JavaScript高级程序设计](https://so.csdn.net/so/search?q=JavaScript高级程序设计&spm=1001.2101.3001.7020)（第3版）中是这样描述：**闭包是指有权访问另一个函数作用域中的变量的函数。**

闭包的特点是：

- 可以在函数的外部访问到函数内部的局部变量。
- 让这些变量始终保存在内存中，不会随着函数的结束而自动销毁。

使用场景:

- 防抖
- 节流
- 函数嵌套避免全局污染



###### 问：前端中的内存泄露是什么？

答： js的垃圾回收机制没有释放已经分配了内存地址的对象，造成长期的内存占用、内存资源浪费，导致运行速度慢，甚至崩溃的情况。会导致内存泄露的因素：

1.  一些未声明直接赋值的变量
2. 未清空的定时器
3. 过渡闭包
4. 引用的元素没有被清除



###### 问：什么是原型链？

答：原型就是一个普通的对象，为构造函数的实例共享属性和方法；所有实例对象中引用的原型都是同一个对象，使用`prototype`可以把属性、方法挂载到原型对象中进行共享，而内存仅需保存一份；实例对象中的属性`__proto__`，指向了构造函数的原型对象`prototype`，一个实例对象在调用属性、方法的时候，会依次从`实例本身 => 构造函数的原型对象 => 原型对象的原型对象`，进行查找，这些原型关系就构成了原型链。

![img](https://jiangwen-markdown-img.oss-cn-fuzhou.aliyuncs.com/5cdd315c45bc895052.png)

小结

- 所有构造函数的`__proto__`都指向`Function.prototype`，包括Function本身
- 所有原型对象的`__proto__`都指向`Object.prototype`, 而`Object.prototype`本身的`__proto__`指向`null`



###### 问：new 操作符具体做了什么？

答：具体分为以下步骤：

```javascript
  function newFn(Fn, ...args) {
    // 1. 创建一个空对象
    let newObj = {};
    // 2. 把空对象和构造函数通过原型链进行关联
    newObj.__proto__ = Fn.prototype
    // 3. 将构造函数的`this`绑定到空对象上
    let res = Fn.apply(newObj, args)
    // 4. 根据构造函数返回的类型判断；如果是值类型，则返回当前创建的对象，如果是引用类型，则返回这个引用类型
    return res instanceof Object ? res : newObj
  }
```



###### 问：js是如何实现继承的？

答： 常见的有以下几种方式

1. 原型链继承
2. 借用构造函数继承
3. 组合式继承
4. ES6的class类继承

[详细参考：]: 详细参考：



###### 问：js中关于this指向的问题？

答： 分为以下情况

1. 全局对象中的this指向的是`window`

2. 全局作用域、普通函数中的this指向全局`window`

3. 匿名函数的执行环境具有全局性，因此匿名函数中的this永远指向`window`

4. this永远指向最后调用它的那个对象

5. `new`关键字改变了this的指向

6. 不是箭头函数的时候，`call`、`apply`、`bind`可以改变this的指向

7. 箭头函数中的this指向，在它定义的时候就已经确定了，箭头函数本身没有this，看外层的函数是否有this，有就是外层函数的this，没有就是指向`window`

   

###### 问： async 和 defer 有什么区别？

答：它们两个属性都是指定浏览器进行脚本的异步加载，但是加载后的执行时机不同，`defer`需要所有元素加载完成之后才执行，`async`是`HTML5`新增的属性，只要脚本加载完成之后就马上执行，因此`async`不能确保脚本的执行顺序，而`defer`则可以。



###### 问： ES6的新特性有哪些？

答：有以下新特性：

1. 新增了块级作用域（let，const）

2. 新增了定义类语法糖（class）

3. 新增了基本数据类型（symbol）

4. 新增了解构赋值

5. 新增了函数参数的默认值

6. 新增了数组的API

7. 对象和数组新增了扩展运算符（...）

8. 新增了`promise`

   - 把异步操作队列化，解决了回调地狱的问题
   - 有`all`,`reject`,`resolve`,`race`方法
   - 原型有`then`、`catch`
   - 三种状态`pending`|`rejected`|`fulfilled`, 状态一旦从`pending` => `rejected`或者`pending` => `fulfilled`改变,状态就确定了，不可逆
   - `async`和`await`: 同步代码做异步操作，两者必须搭配使用

9. 新增了模块化（import、export）

10. 新增了set 和map数据结构

    - set 数据结构不存在重复
    - map  数据结构的key类型不受限制

11. 新增了generator构造器

12. 新增了箭头函数

    

###### 问： 箭头函数和普通函数有什么区别？

答：有以下区别

1. 箭头函数不能使用`new`操作符, 来作为构造函数使用
2. 箭头函数没有原型
3. 箭头函数没有`arguments`
4. 箭头函数不能用`call`、`call`、`call`去改变this的执行
5. 箭头函数的this执行外层函数的第一个this

###### 问：数组降纬

答：简单的二维数组可以使用`[1,2,[3,4],5].flatMap(v=>v)实现，如果多维数组彻底降维可以创建自定义的函数实现

```javascript
const deepFlatMap = (arr) => Array.isArray(arr) ? arr.reduce((a,b)=>[...a,...deepFlatMap(b)],[]) : [arr]
deepFlatMap([1, [[2], [3, [4]], 5]]) // => [1,2,3,4,5]
```



###### 问： 如何实现一个深拷贝？

答：一般可以通过以下方式：

1. 扩展运算符实现

   ```javascript
   let oo_1 = { ...o}  // 缺点： 对于对象中的引用数据类型还是浅拷贝
   ```

   

2. ` JSON.parse(JSON.stringify())`

   ```javascript
   // 缺点： 1.会或略undefined、symbol 2.不能序列号函数 3.不能处理循环引用的对象
   // 优点： 是内置函数中处理深拷贝性能最快的  
   let oo_1 = JSON.parse(JSON.stringify(o))
   ```

3. 递归复制

   ```javascript
   /**
   * origin: 拷贝源对象
   * deep: 是否使用深拷贝
   */ 
   function deepClone(origin, deep) {
      let obj = {}
      if (origin instanceof Array) obj = [];
      for (let key in origin) {
        let value = origin[key]
        obj[key] = (!!deep && typeof value === "object" && value !== null) ? deepClone(value, deep) : value
      }
      return obj
   }
   
   let oo_1 = deepClone(o, true)
   ```

   

###### 问： 说一下事件循环？

答： js是一个单线程脚本语言，



######  问： clientHeight, scrollHeight, offsetHeight, 以及scrollTop, offsetTop,clientTop的区别？

答：分别表示一下含义

- clientHeight：表示的是可视区域的高度，不包含border和滚动条
- offsetHeight：表示可视区域的高度，包含了border和滚动条
- scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。
- clientTop：表示边框border的厚度，在未指定的情况下一般为0
- scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。

## Vue

###### 问： 说一下vue2和vue3的区别？

答：可以从以下方面进行分析

|          | vue2                  | vue3                       |
| -------- | --------------------- | -------------------------- |
| 脚手架   | 命令式                | 可视化创建脚⼿架           |
| 组件通信 | 见下文                | 见下文                     |
| 数据监听 | watch,computed        | watch,watchEffect,computed |
| 双向绑定 | Object.defineProperty | ProxyAPI                   |
| ⽣命周期 | 见下文                | 见下文                     |
| api      | 选项式                | 组合式                     |

###### 1.双向绑定原理

   vue2 的双向数据绑定是利⽤ES5 的⼀个 API ，`Object.defineProperty()`对数据进⾏劫持 结合 发布订阅模式的⽅式来实现的。

   vue3 中使⽤了 ES6 的 `Proxy`对数据代理，通过 reactive() 函数给每⼀个对象都包⼀层 Proxy，通过 Proxy 监听属性的变化，从⽽ 实现对数据的监控。

   > 这⾥是相⽐于vue2版本，使⽤proxy的优势如下

   1.defineProperty只能监听某个属性，不能对全对象监听 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）
   2.可以监听数组，不⽤再去单独的对数组做特异性操作,通过Proxy可以直接拦截所有对象类型数据的操作，完美⽀持对数组的监听。

###### 2.生命周期

| Vue2          | vue3            | 描述         |
| ------------- | --------------- | ------------ |
| beforeCreate  | -               | 实例创建前   |
| created       | -               | 实例创建完成 |
| beforeMount   | onBeforeMount   | Dom挂载前    |
| mounted       | onMounted       | Dom挂载完成  |
| beforeUpdate  | onBeforeUpdate  | 数据更新前   |
| updated       | onUpdated       | 数据更新完成 |
| BeforeDestory | onBeforeUnmount | 组件销毁前   |
| destroyed     | onUnmounted     | 组件销毁完成 |

> 注意⚠️：更新时的生命周期钩子函数只有数据更新引起dom更新时才触发

###### 3.实例化

Vue2中new出的实例对象，所有的东西都在这个vue对象上，这样其实⽆论你⽤到还是没⽤到，都会跑⼀遍，这样不仅提⾼了性能消耗，也⽆疑增加了⽤户加载时间。

⽽vue3.0中可以⽤ES module imports按需引⼊，如：keep-alive内置组件、v-model指令，等等，不仅我们开发起来更加的便捷，减少 了内存消耗，也同时减少了⽤户加载时间，优化⽤户体验。

###### 4.数据和方法的定义

Vue2使⽤的是选项类型API（Options API），Vue3使⽤的是合成型API（Composition API）

###### 5.组件通信

|                  | Vue2      | Vue3       |
| ---------------- | --------- | ---------- |
| 父传子           | props     | props      |
| 父传子           | provide   | provide    |
| 子传父           | $emit     | emits      |
| 子传父           | inject    | inject     |
| 子组件访问父组件 | $parent   | -          |
| 父组件访问子组件 | $children | -          |
| 父组件访问子组件 | $ref      | ref        |
| 兄弟传值         | EventBus  | Mitt(插件) |

> 注意⚠️：在组合式API中，如果想在子组件中用其它变量接收props的值时需要使用toRef将props中的属性转为响应式



###### 问：为什么v-if和v-for不能同时使用？

答：v-if不能和v-for一起使用的原因是v-for的 **优先级** 比v-if高，一起使用会造成性能浪费，解决方案有两种：把v-if放在v-for的外层或者把需要v-for的属性先从计算属性中过滤一次, v-if和v-for的优先级问题在vue3中不需要考虑，vue3更新了v-if和v-for的优先级，使v-if的优先级高于v-for



###### 问：Vue路由的钩子函数（导航守卫）？

答：路由钩子函数有三种：

1. 全局路由钩子： beforeEach、 afterEach、beforeResolve

2. 独享路由钩子：beforeEnter

3. 组件路由钩子：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave

###### 问：nextTick是什么？

答：本质上就是一个**延迟回调函数**，是dom更新之后的回调函数。一般用于获取更新后的dom内容，保证获取的内容是最新的；由于vue的渲染机制是异步渲染，所以当数据改变后，dom内容不会即时更新，这时候就需要调用nextTick来保证获取到的dom是最新的。



###### 问：props 和 data 优先级谁高？

答：1. props => 2. methods => 3. data => 4. computed => 5. watch



###### 问：diff 算法？

答： diff 算法的前提一定是同层级、同类型的节点，核心是列表循环中diff算法，说白了就是加key之后元素怎么移动、删除、创建，vue2和vue3中的有一个非常大的区别：

在vue2中叫做**双端交叉指针**：新老vdom各有两个指针，分别是 => **1.队头与队头 2.队尾与队尾 3.队头与队尾 4.队尾与队头**，进行4次对比，如果4次寻找到元素的key相同，就会去进行复用，移动元素的位子；如果4次都不匹配，就会在Vdom的队头开始，再去寻找老的Vdom里面是否有对应的元素，进行相应的移动、删除和创建。

Vue3叫做**双端快速diff**，也有两个指针，新老Vdom各有两个，只对比两种情况 => 1.队头与队头 2.队尾与队尾 ，如果匹配上和vue2中的操作是一样的，移动元素进行复用，如果没有匹配上，触发对新的Vdom进行**最长递增子序列的计算**，该算法在新的Vdom里面寻找依次递增的元素有哪些，找到之后那这些元素它的顺序就是固定的，去寻找不在这些列表里面的元素和老的Vdom进行对比，再进行移动、删除和创建。

虽然vue3中算法的复杂度是**O(n*log)** ,与vue2中算法复杂度 **O(n)**对比来说更高了，但是减少了dom的移动，在浏览器中dom的移动是非常昂贵的，所以从总体来看，用js损失一点性能来提升浏览器的dom渲染效率是划算的。



问：单页应用（SPA）与多页应用的区别和优缺点？

答：单页应用有以下优缺点：

​	优点：用户体验好 ；局部更新，减少服务器压力 

​	缺点：不利于SEO；首屏加载时间长

## http

###### 问：http1.0 与 http2.0的区别？

答：有以下区别

1. 新的二进制格式（Binary Format）
2. 多路复用（MultiPlexing），即连接共享，多个请求共用一个TCP连接
3. header压缩
4. 服务端推送（server push）



###### 问：跨域？

答：由于浏览器同源策略的限制，只要存在协议、域名、端口有不一致，就会产生跨域。一般可以通过以下方式处理跨域

1. jsonp（json with padding）
2. 反向代理
3. 开启CORS跨域资源共享



###### 问：cookie、localStorage 和 sessionStorage的区别?

答：如下图

|              | cookie                      | localStorage | sessionStorage |
| ------------ | --------------------------- | ------------ | -------------- |
| 大小         | 4kb（由于浏览器限制的原因） | 10Mb         | 5Mb            |
| 兼容性       | 无                          | H5           | H5             |
| 访问         | 任何窗口                    | 任何窗口     | 同一窗口       |
| 有效期       | 手动设置                    | 无           | 窗口关闭       |
| 存储位置     | 浏览器和服务器              | 浏览器       | 浏览器         |
| 是否参与请求 | 是                          | 否           | 否             |
| 语法         | 复杂                        | 简单         | 简单           |
| 安全性       |                             |              |                |





## 性能优化



vue-cli 打包时的项目优化

1. 按需加载UI组件库
2. 移除无效依赖和冗余代码
3. 不生成sourcemap文件
4. 图片和代码压缩

## 安全

###### 问：了解过 JWT 吗？

答：JWT 是 `json web token`的缩写，通过json的形式作为web引用中的令牌，它包含了头部（header）、载荷（payload）、签名（signature）三个部分，可以在各方之间安全的把信息作为json对象进行传输、授权。具体的认证流程是：

1. 前端把账号密码发送给后端接口
2. 后端对账号密码进行认证后，把用户id等其他信息作为JWT的载荷，将它和头部进行`base64`编码后拼接,然后对该拼接字段使用头部中指定的签名算法HS256进行加密，形成一个token
3. 前端在每次请求时，都会将 jwt 放在 http 请求头的	`Authorization`子段内
4. 后端检查前端发送的token是否存在，如果存在就验证token有效性，包括签名是否正确，token是否过期等
5. 验证通过过，后端使用token中包含的信息进行其他操作，并返回对应结果

## 实际开发

###### 问：有没有做过无感登陆？

答：无感登陆我们常用的方案是：在响应器中进行拦截，判断token是否过期，如果过期则调用刷新token的接口，具体流程是：

1. 首次登录成功后保存`token` 和 `refresh_token`
2. 在响应拦截器中对返回`401`状态码进行刷新token接口的调用
3. 替换保存为本地新的 token
4. 替换错误对象里的 token
5. 发送之前未完成的请求
6. 如果refresh_token过期了，则清楚所以token进行重新登录 
